<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>隔离性 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="隔离性" class="main-title"></div></div></header><article><aside class="bg-cultured wolai-block"><div data-symbol="❄️" class="icon"></div><span class="inline-wrap">事务的隔离性是用来处理事务的并发问题的。</span></aside><h2 class="wolai-block"><span class="inline-wrap">事务的并发问题</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">事务的隔离性是用来处理事务的并发问题，在了解隔离性之前，需要先了解这些并发问题。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">事务的并发问题有三种：脏读、不可重复读、幻读。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">脏读：在数据库访问中，事务<span class="jill"></span>T1<span class="jill"></span>将某一值修改，然后事务<span class="jill"></span>T2<span class="jill"></span>读取该值，此后<span class="jill"></span>T1<span class="jill"></span>因为某种原因撤销对该值的修改，这就导致了<span class="jill"></span>T2<span class="jill"></span>所读取到的数据是无效的。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">不可重复读：在数据库访问中，一个事务内执行了两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务<span class="jill"></span>T1<span class="jill"></span>读取某一数据，事务<span class="jill"></span>T2<span class="jill"></span>读取并修改了该数据，T1<span class="jill"></span>为了对读取值进行检验而再次读取该数据，便得到了不同的结果。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">幻读：一个事务中，两次相同的查询，查出来的记录数不相同。</span></li></ul><blockquote class="wolai-block"><span class="inline-wrap"><b>不可重复读与幻读的区别</b></span><span class="inline-wrap">?
不可重复读的重点是修改: 同样的条件, 你读取过的数据, 再次读取出来发现值不一样了
</span><span class="red inline-wrap">幻读的重点在于新增或者删除： 同样的条件, 第<span class="jill"></span>1<span class="jill"></span>次和第<span class="jill"></span>2<span class="jill"></span>次读出来的记录数不一样
</span><span class="inline-wrap">从总的结果来看, 似乎不可重复读和幻读都表现为两次读取的结果不一致。
但如果你从控制的角度来看, 两者的区别就比较大。
对于前者, 只需要锁住满足条件的记录。 对于后者, 要锁住满足条件及其相近的记录。</span></blockquote><h2 class="wolai-block"><span class="inline-wrap">事务的隔离级别</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">为了处理上述三种并发问题，SQL<span class="jill"></span>标准定义了四种隔离级别。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">读未提交(</span><span class="inline-wrap"><code>read uncommited</code></span><span class="inline-wrap">)：一个事务对数据的修改，还没提交就能被另外一个事务所看到。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">读已提交(</span><span class="inline-wrap"><code>read commited</code></span><span class="inline-wrap">)：保证一个事务对数据的修改，只有在提交后才能被另外一个事务所看到。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">可重复度(</span><span class="inline-wrap"><code>repeatable read</code></span><span class="inline-wrap">)：InnoDB<span class="jill"></span>默认的隔离级别。保证一个事务内，多次查询同样的数据，结果是一致的。可以解决脏读、不可重复读的问题。</span><aside class="bg-cultured wolai-block"><div data-symbol="❄️" class="icon"></div><span class="inline-wrap">在规范上，可重复读的隔离级别是不能解决幻读问题的。
但是<span class="jill"></span>InnoDB<span class="jill"></span>使用了<span class="jill"></span>XXX<span class="jill"></span>技术，使得它可以解决幻读问题。</span></aside></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">串行的(</span><span class="inline-wrap"><code>serializable</code></span><span class="inline-wrap">)：所有事务按顺序执行。完全解决脏读、不可重复读之外和幻读等问题。。</span></li></ul><h2 class="wolai-block"><span class="inline-wrap">事务隔离级别的实现</span></h2><h3 class="wolai-block"><span class="inline-wrap">锁</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">并发问题往往可以尝试通过锁来解决，事务的隔离级别就是通过锁来实现的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">例如读已提交，可以通过共享锁和独占锁的方式来实现。多个事务可以同时读同一条数据。但是同一时刻，只有一个事务可以修改这条数据。</span></div></div><div class="wolai-block wolai-text"><div><span class="green inline-wrap"><b>InnoDB<span class="jill"></span>提供了多种粒度的锁：表锁和行锁。</b></span></div></div><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">共享模式的表锁</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果一个事务给表加了<span class="jill"></span>S<span class="jill"></span>锁</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">别的事务可以获取该表的<span class="jill"></span>S<span class="jill"></span>锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">别的事务可以获取该表中某些行的<span class="jill"></span>S<span class="jill"></span>锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">别的事务不可以获取该表的<span class="jill"></span>X<span class="jill"></span>锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">别的事务不可以获取该表中某些行的<span class="jill"></span>X<span class="jill"></span>锁</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">独占模式的表锁</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果一个事务给表加了<span class="jill"></span>X<span class="jill"></span>锁</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">别的事务不可以获取该表的<span class="jill"></span>S<span class="jill"></span>锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">别的事务不可以获取该表中某些行的<span class="jill"></span>S<span class="jill"></span>锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">别的事务不可以获取该表的<span class="jill"></span>X<span class="jill"></span>锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">别的事务不可以获取该表中某些行的<span class="jill"></span>X<span class="jill"></span>锁</span></li></ul></details><div class="wolai-block wolai-text"><div><span class="inline-wrap">因为表锁是很重的，很影响性能，所以<span class="jill"></span>MySQL<span class="jill"></span>里面，表锁不是必须的，可以只用行锁。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">这种方式带来了一个问题，上表锁的时候，怎么知道表里面的记录有没有锁，是什么模式的锁？</span></div></div><div class="wolai-block wolai-text"><div><span class="green inline-wrap"><b>为了解决这个问题，InnoDB<span class="jill"></span>提供了另一种表锁：意向锁。</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">意向锁有两种类型：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">意向共享锁（IS）：表示事务打算在表中的某几行上设置共享锁。</span><span class="inline-wrap"><code>SELECT ... LOCK IN SHARE MODE</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">意向排他锁（IX）：表示事务打算在表中的某几行上设置独占锁。</span><span class="inline-wrap"><code>SELECT ... FOR UPDATE</code></span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">意向锁协议如下：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在事务可以获取表中某一行的共享锁之前，它必须首先在表上获取<span class="jill"></span>IS<span class="jill"></span>锁或更高级别的<span class="jill"></span>IX<span class="jill"></span>锁。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在事务可以获取表中某一行的独占锁之前，它必须首先获取表上的<span class="jill"></span>IX<span class="jill"></span>锁。</span></li></ul><aside class="bg-cultured wolai-block"><div data-symbol="❄️" class="icon"></div><span class="inline-wrap">通过意向锁，可以知道表里面的记录有没有上锁，上的是什么锁。</span></aside><div class="wolai-block wolai-text"><div><span class="inline-wrap">行锁也有三种类型：记录锁、间隙锁、Next-Key<span class="jill"></span>锁。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">记录锁：普通行锁，锁住一条记录</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">间隙锁：锁住两行之间的间隙，在上锁期间不允许在间隙里新增记录，用于解决幻读问题</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Next-Key<span class="jill"></span>锁：记录锁<span class="jill"></span>+<span class="jill"></span>间隙锁，锁定一个范围，并且锁定记录本身</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">create</span> <span class="token keyword">table</span> t <span class="token punctuation">(</span>a <span class="token keyword">int</span> <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token punctuation">,</span> b <span class="token keyword">int</span> <span class="token punctuation">,</span> <span class="token keyword">key</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> z <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> z <span class="token keyword">select</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> z <span class="token keyword">select</span> <span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> z <span class="token keyword">select</span> <span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> z <span class="token keyword">select</span> <span class="token number">10</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">;</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> b <span class="token operator">=</span> <span class="token number">3</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
<span class="token comment">-- 对B在区间[1,6]进行加锁</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> a <span class="token operator">=</span> <span class="token number">5</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
<span class="token comment">-- 由于a是主键，因此只会锁定a=5这一行，而不是[1,5]这个区间</span>
<span class="token comment">-- 这就叫做Next-Key Lock降级为Record Lock</span></pre></div></code-block><aside class="bg-cultured wolai-block"><div data-symbol="❄️" class="icon"></div><span class="inline-wrap">数据库死锁怎么解决？</span></aside><h3 class="wolai-block"><span class="inline-wrap">MVCC</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">数据库的并发问题可以分成三类：读与读并发、读与写并发、写与写并发。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">读与读并发不会产生并发问题。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">写与写并发，只能通过锁来解决。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">对于读与写并发来说，如果用锁来解决，读写相互阻塞，很容易产生性能问题。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">因此<span class="jill"></span>Innodb<span class="jill"></span>引入了<span class="jill"></span>MVCC<span class="jill"></span>机制，通过无锁的方式实现读写并发。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">讲解<span class="jill"></span>MVCC<span class="jill"></span>之前，我们需要了解两样东西：行里面的隐藏字段、Read View。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>
<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>4.日志系统 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="4.日志系统" class="main-title"></div></div></header><article><div class="wolai-bookmark wolai-block"><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDg2OTAxNg==&amp;mid=2652054699&amp;idx=1&amp;sn=018017d9f3a61ca284970bbf65ea5138&amp;scene=21#wechat_redirect">聊聊redo log是什么？</a><div class="info-box"><div class="text-pane"><div data-title="聊聊redo log是什么？"></div><div data-desc="阿星：你知道MySQL是如何实现崩溃恢复的吗？"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://res.wx.qq.com/a/wx_fed/assets/res/MjliNWVm.svg&quot;)"></div><div data-hostname="mp.weixin.qq.com"></div></div></div><div class="preview-pane" style="background-image: url(http://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nzoia78ia1wnynufibsPx05L544AetCjLf3cEwPUVibicFicvVgNGlcZm3bSp4KT8HZOTp0Id3K8OSkRpIw/0?wx_fmt=jpeg)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://mp.weixin.qq.com/s/ty_7eZpIeYqM-CQaPbMjxA">不会吧，不会吧，还有人不知道 binlog ？</a><div class="info-box"><div class="text-pane"><div data-title="不会吧，不会吧，还有人不知道 binlog ？"></div><div data-desc="阿星：不管你知不知道，都要进来看一看（非广告）"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://res.wx.qq.com/a/wx_fed/assets/res/MjliNWVm.svg&quot;)"></div><div data-hostname="mp.weixin.qq.com"></div></div></div><div class="preview-pane" style="background-image: url(http://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nxiaXqrSndLqJZv7ic9wSaRYtVA7ySub8HXd9robSyZyibqicD08BicIo3tUBJYiarkNicUC2wiaoJqKDawog/0?wx_fmt=jpeg)"></div></div></div><h1 class="wolai-block"><span class="inline-wrap">MySQL<span class="jill"></span>日志系统</span></h1><div class="wolai-block wolai-text"><div><span class="inline-wrap">MySQL<span class="jill"></span>中有七种日志文件，分别是：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">重做日志（redo log）</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">回滚日志（undo log）</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">二进制日志（binlog）</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">错误日志（errorlog）</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">慢查询日志（slow query log）</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">一般查询日志（general log）</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">中继日志（relay log）</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">其中重做日志和回滚日志与事务操作息息相关，二进制日志也与事务操作有一定的关系，这三种日志，对理解 MySQL 中的事务操作有着重要的意义。这里简单总结一下这三个具有一定相关性的日志。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">重做日志（redo log）</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">重做日志（redo log）的作用是确保事务的持久性，防止在发生故障的时间点，尚有脏页未写入磁盘。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的持久性这一特性。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">redo log<span class="jill"></span>记录的是物理数据页面修改的信息，其 redo log 是顺序写入 redo log file 的物理文件中去的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>什么时候产生</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">事务开始之后就产生 redo log，redo log 的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入 redo log 文件中。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>什么时候释放</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">当对应事务的脏页写入到磁盘之后，redo log 的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>对应的物理文件</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">默认情况下，对应的物理文件位于数据库的 data 目录下的 ib_logfile1<span class="jill"></span>和<span class="jill"></span>ib_logfile2。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">innodb_log_group_home_dir 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下，innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认为 2。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">关于文件的大小和数量，由以下两个参数配置：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">innodb_log_file_size 重做日志文件的大小。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认 1。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>其他</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">很重要一点，redo log 是什么时候写盘的？前面说了是在事物开始之后逐步写盘的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">原因就是，重做日志有一个缓存区 Innodb_log_buffer，Innodb_log_buffer 的默认大小为 8M(这里设置的 16M)，Innodb 存储引擎先将重做日志写入 innodb_log_buffer 中。</span></div></div><div class="wolai-block wolai-text"><div></div></div><div class="wolai-block wolai-center"><figure><img src="https://s5.51cto.com/oss/201806/27/b9c6288151e018232f28b55897a853a2.jpg-wh_651x-s_784437323.jpg" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">然后会通过以下三种方式将 Innodb 日志缓冲区的日志刷新到磁盘：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Master Thread 每秒一次执行刷新 Innodb_log_buffer 到重做日志文件。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">每个事务提交时会将重做日志刷新到重做日志文件。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">当重做日志缓存可用空间少于一半时，重做日志缓存被刷新到重做日志文件。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于***种方式，Innodb_log_buffer 到重做日志文件是 Master Thread 线程的定时任务。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">另外引用《MySQL<span class="jill"></span>技术内幕 Innodb 存储引擎》（page37）上的原话：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">即使某个事务还没有提交，Innodb 存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">这一点是必须要知道的，因为这可以很好地解释再大的事务提交（commit）的时间也是很短暂的。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">回滚日志（undo log）</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">回滚日志保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>内容</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">逻辑格式的日志，在执行 undo 的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于 redo log 的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>什么时候产生</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">事务开始之前，将当前时的版本生成 undo log，undo 也会产生 redo 来保证 undo log 的可靠性。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>什么时候释放</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">当事务提交之后，undo log 并不能立马被删除，而是放入待清理的链表，由 purge 线程判断是否由其他事务在使用 undo 段中表的上一个事务之前的版本信息，决定是否可以清理 undo log 的日志空间。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>对应的物理文件</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">MySQL 5.6 之前，undo 表空间位于共享表空间的回滚段中，共享表空间的默认名称是 ibdata，位于数据文件目录中。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">MySQL 5.6 之后，undo 表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变 undo log 文件的个数。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">关于 MySQL 5.7 之后的独立 undo 表空间配置参数如下：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">innodb_undo_directory = /data/undospace/ –undo 独立表空间的存放目录</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">innodb_undo_logs = 128 –回滚段为 128KB</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">innodb_undo_tablespaces = 4 –指定有 4 个 undo log 文件</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果 undo 使用的共享表空间，这个共享表空间中又不仅仅是存储了 undo 的信息，共享表空间将默认位于 MySQL 的数据目录下面，其属性由参数 innodb_data_file_path 配置。</span></div></div><div class="wolai-block wolai-text"><div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>其他</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">undo 是在事务开始之前保存的被修改数据的一个版本，产生 undo 日志的时候，同样会伴随类似于保护事务持久化机制的 redolog 的产生。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">默认情况下 undo 文件是保持在共享表空间的，也即 ibdatafile 文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的 undo 信息，全部保存在共享表空间中的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">因此共享表空间可能会变的很大，默认情况下，也就是 undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">因此，MySQL 5.7 之后的“独立 undo 表空间”的配置就显得很有必要了。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>二进制日志（binlog）</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>作用</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">用于复制，在主从复制中，从库利用主库上的 binlog 进行重播，实现主从同步；用于数据库基于时间点的还原。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>内容</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">逻辑格式的日志，可以简单认为就是执行过的事务中的 SQL 语句，但又不完全是 SQL 语句这么简单。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">它包括了执行的 SQL 语句（增删改）反向的信息，也就意味着 delete 对应着 delete 本身和其反向的 insert；update 对应着 update 执行前后的版本的信息；insert 对应着 delete 和 insert 本身的信息。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在使用 MySQLbinlog 解析 binlog 之后一些都会真相大白。因此可以基于 binlog 做到类似于 Oracle 的闪回功能，其实都是依赖于 binlog 中的日志记录。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>什么时候产生</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">事务提交的时候，一次性将事务中的 SQL 语句（一个事物可能对应多个 SQL 语句）按照一定的格式记录到 binlog 中。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">这里与 redo log 很明显的差异就是 redo log 并不一定是在事务提交的时候刷新到磁盘，redo log 是在事务开始之后就开始逐步写入磁盘。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了 bin_log 的情况下，对于较大事务的提交，可能会变得比较慢一些。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">这是因为 binlog 是在事务提交的时候一次性写入造成的，这些可以通过测试验证。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>什么时候释放</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">binlog 默认是保持时间由参数 expire_logs_days 配置，也就是说对于非活动的日志文件，在生成时间超过 expire_logs_days 配置的天数之后，会被自动删除。</span></div></div><div class="wolai-block wolai-text"><div></div></div><div class="wolai-block wolai-center"><figure><img src="https://s3.51cto.com/oss/201806/27/0f201fba4769b3b67c25c6926f2c112e.jpg" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>对应的物理文件</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">配置文件的路径为 log_bin_basename，binlog 日志文件按照指定大小，当日志文件达到指定的***的大小之后，进行滚动更新，生成新的日志文件。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">对于每个 binlog 日志文件，通过一个统一的 index 文件来组织。</span></div></div><div class="wolai-block wolai-text"><div></div></div><div class="wolai-block wolai-center"><figure><img src="https://s1.51cto.com/oss/201806/27/b21f513659034cea3b272c1e6a4150a8.jpg"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>其他</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">二进制日志的作用之一是还原数据库，这与 redo log 很类似，很多人混淆过，但是两者有本质的不同：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">作用不同：redo log 是保证事务的持久性的，是事务层面的；binlog 作为还原的功能，是数据库层面的（当然也可以精确到事务层面的）。虽然都有还原的意思，但是其保护数据的层次是不一样的。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">内容不同：redo log 是物理日志，是数据页面修改之后的物理记录，binlog 是逻辑日志，可以简单认为记录的就是 SQL 语句。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">另外，两者日志产生的时间、可以释放的时间，在可释放的情况下清理机制，都是完全不同的。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">恢复数据时候的效率，基于物理日志的 redo log 恢复数据的效率要高于语句逻辑日志的 binlog。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">关于事务提交时，redo log 和 binlog 的写入顺序，为了保证主从复制时候的主从一致（当然也包括使用 binlog 进行基于时间点还原的情况），是要严格一致的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">MySQL 通过两阶段提交过程来完成事务的一致性的，也即 redo log 和 binlog 的一致性，理论上是先写 redo log，再写 binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">Redo Log</span></h2><h3 class="wolai-block"><span class="inline-wrap">提高存储性能</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果每一次的更新操作先让磁盘找到对应的那条记录，然后再更新，那么整个过程成本很高。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">有了<span class="jill"></span>redo log<span class="jill"></span>后, 当有一条记录需要更新的时候，InnoDB<span class="jill"></span>引擎就会先把记录写到<span class="jill"></span>redo log，然后更新内存中的数据，这个时候更新就算完成了。然后<span class="jill"></span>InnoDB<span class="jill"></span>会在适当的时候，将这个操作记录更新到磁盘里面。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">InnoDB<span class="jill"></span>的<span class="jill"></span>redo log<span class="jill"></span>是固定大小的，比如可以配置为一组<span class="jill"></span>4<span class="jill"></span>个文件，每个文件的大小是<span class="jill"></span>1GB，那么总共就可以记录<span class="jill"></span>4GB<span class="jill"></span>的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/mysql-redo-log.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">write pos<span class="jill"></span>是当前记录的位置，一边写一边后移，写到第<span class="jill"></span>3<span class="jill"></span>号文件末尾后就回到<span class="jill"></span>0<span class="jill"></span>号文件开头。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">checkpoint<span class="jill"></span>是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果<span class="jill"></span>write pos<span class="jill"></span>追上<span class="jill"></span>checkpoint，这时候不能再执行新的更新，要把记录写入硬盘，把<span class="jill"></span>checkpoint<span class="jill"></span>推进一下。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">故障恢复</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">有了<span class="jill"></span>redo log，InnoDB<span class="jill"></span>就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>crash-safe</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">Binary Log</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">二进制日志是属于<span class="jill"></span>server<span class="jill"></span>层的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">redo log<span class="jill"></span>是物理日志，记录的是“在某个数据页上做了什么修改”；binlog<span class="jill"></span>是逻辑日志，记录的是这个语句的原始逻辑，比如“给<span class="jill"></span>ID=2<span class="jill"></span>这一行的<span class="jill"></span>c<span class="jill"></span>字段加<span class="jill"></span>1 ”。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">redo log<span class="jill"></span>是循环写的，空间固定会用完；binlog<span class="jill"></span>是可以追加写入的。“追加写”是指<span class="jill"></span>binlog<span class="jill"></span>文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">最开始<span class="jill"></span>MySQL<span class="jill"></span>里并没有<span class="jill"></span>InnoDB<span class="jill"></span>引擎。MySQL<span class="jill"></span>自带的引擎是<span class="jill"></span>MyISAM，但是<span class="jill"></span>MyISAM<span class="jill"></span>没有<span class="jill"></span>crash-safe<span class="jill"></span>的能力，binlog<span class="jill"></span>日志只能用于归档。而<span class="jill"></span>InnoDB<span class="jill"></span>是另一个公司以插件形式引入<span class="jill"></span>MySQL<span class="jill"></span>的，既然只依靠<span class="jill"></span>binlog<span class="jill"></span>是没有<span class="jill"></span>crash-safe<span class="jill"></span>能力的，所以<span class="jill"></span>InnoDB<span class="jill"></span>使用另外一套日志系统——也就是<span class="jill"></span>redo log<span class="jill"></span>来实现<span class="jill"></span>crash-safe<span class="jill"></span>能力。</span></div></div></article><footer></footer></body></html>
<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>隔离性 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="隔离性" class="main-title"></div></div></header><article><aside class="bg-cultured wolai-block"><div data-symbol="❄️" class="icon"></div><span class="inline-wrap">事务的隔离性是用来处理事务的并发问题的。</span></aside><h2 class="wolai-block"><span class="inline-wrap">事务的并发问题</span></h2><div class="wolai-bookmark wolai-block"><a href="https://juejin.cn/post/6844904096378404872">浅谈MySQL并发控制：隔离级别、锁与MVCC - 掘金</a><div class="info-box"><div class="text-pane"><div data-title="浅谈MySQL并发控制：隔离级别、锁与MVCC - 掘金"></div><div data-desc="如果数据库中的事务都是串行执行的，这种方式可以保障事务的执行不会出现异常和错误，但带来的问题是串行执行会带来性能瓶颈；而事务并发执行，如果不加以控制则会引发诸多问题，包括死锁、更新丢失等等。这就需要我们在性能和安全之间做出合理的权衡，使用适当的并发控制机制保障并发事务的执行。 …"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/apple-touch-icon.png&quot;)"></div><div data-hostname="juejin.cn"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在了解隔离性之前，需要先了解事务的并发问题。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">事务的并发问题主要分为三类：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>读-读</b></span><span class="inline-wrap">：即并发事务相继读取同一记录；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>写-写</b></span><span class="inline-wrap">：即并发事务相继对同一记录做出修改；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>写-读</b></span><span class="inline-wrap">或</span><span class="inline-wrap"><b>读-写</b></span><span class="inline-wrap">：即两个并发事务对同一记录分别进行读操作和写操作。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">其中读-读操作不会并发问题。写-写只能通过互斥锁来解决。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">读写并发有可能出现三种问题：脏读、不可重复读、幻读。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">脏读：在数据库访问中，事务<span class="jill"></span>T1<span class="jill"></span>将某一值修改，然后事务<span class="jill"></span>T2<span class="jill"></span>读取该值，此后<span class="jill"></span>T1<span class="jill"></span>因为某种原因撤销对该值的修改，这就导致了<span class="jill"></span>T2<span class="jill"></span>所读取到的数据是无效的。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">不可重复读：在数据库访问中，一个事务内执行了两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务<span class="jill"></span>T1<span class="jill"></span>读取某一数据，事务<span class="jill"></span>T2<span class="jill"></span>读取并修改了该数据，T1<span class="jill"></span>为了对读取值进行检验而再次读取该数据，便得到了不同的结果。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">幻读：一个事务中，两次相同的查询，查出来的记录数不相同。</span></li></ul><blockquote class="wolai-block"><span class="inline-wrap"><b>不可重复读与幻读的区别</b></span><span class="inline-wrap">?
不可重复读的重点是修改: 同样的条件, 你读取过的数据, 再次读取出来发现值不一样了
</span><span class="red inline-wrap">幻读的重点在于新增或者删除： 同样的条件, 第<span class="jill"></span>1<span class="jill"></span>次和第<span class="jill"></span>2<span class="jill"></span>次读出来的记录数不一样
</span><span class="inline-wrap">从总的结果来看, 似乎不可重复读和幻读都表现为两次读取的结果不一致。
但如果你从控制的角度来看, 两者的区别就比较大。
对于前者, 只需要锁住满足条件的记录。 对于后者, 要锁住满足条件及其相近的记录。</span></blockquote><h2 class="wolai-block"><span class="inline-wrap">事务的隔离级别</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">为了处理上述三种并发问题，SQL<span class="jill"></span>标准定义了四种隔离级别。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">读未提交(</span><span class="inline-wrap"><code>read uncommited</code></span><span class="inline-wrap">)：一个事务对数据的修改，还没提交就能被另外一个事务所看到。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">读已提交(</span><span class="inline-wrap"><code>read commited</code></span><span class="inline-wrap">)：保证一个事务对数据的修改，只有在提交后才能被另外一个事务所看到。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">可重复度(</span><span class="inline-wrap"><code>repeatable read</code></span><span class="inline-wrap">)：InnoDB<span class="jill"></span>默认的隔离级别。保证一个事务内，多次查询同样的数据，结果是一致的。可以解决脏读、不可重复读的问题。</span><aside class="bg-cultured wolai-block"><div data-symbol="❄️" class="icon"></div><span class="inline-wrap">在规范上，可重复读的隔离级别是不能解决幻读问题的。
但是</span><span class="inline-wrap"><code>InnoDB</code></span><span class="inline-wrap">使用了</span><span class="inline-wrap"><code>Next Key Lock</code></span><span class="inline-wrap">技术，使得它可以解决幻读问题。</span></aside></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">串行的(</span><span class="inline-wrap"><code>serializable</code></span><span class="inline-wrap">)：所有事务按顺序执行。完全解决脏读、不可重复读之外和幻读等问题。。</span></li></ul><h2 class="wolai-block"><span class="inline-wrap">事务隔离级别的实现</span></h2><h3 class="wolai-block"><span class="inline-wrap">锁</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">并发问题往往可以尝试通过锁来解决，事务的隔离级别就是通过锁来实现的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">例如读已提交，可以通过共享锁和独占锁的方式来实现。多个事务可以同时读同一条数据。但是同一时刻，只有一个事务可以修改这条数据。</span></div></div><div class="wolai-block wolai-text"><div><span class="green inline-wrap"><b>InnoDB<span class="jill"></span>提供了多种粒度的锁：表锁和行锁。</b></span></div></div><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">共享模式的表锁</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果一个事务给表加了<span class="jill"></span>S<span class="jill"></span>锁</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">别的事务可以获取该表的<span class="jill"></span>S<span class="jill"></span>锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">别的事务可以获取该表中某些行的<span class="jill"></span>S<span class="jill"></span>锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">别的事务不可以获取该表的<span class="jill"></span>X<span class="jill"></span>锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">别的事务不可以获取该表中某些行的<span class="jill"></span>X<span class="jill"></span>锁</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">独占模式的表锁</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果一个事务给表加了<span class="jill"></span>X<span class="jill"></span>锁</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">别的事务不可以获取该表的<span class="jill"></span>S<span class="jill"></span>锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">别的事务不可以获取该表中某些行的<span class="jill"></span>S<span class="jill"></span>锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">别的事务不可以获取该表的<span class="jill"></span>X<span class="jill"></span>锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">别的事务不可以获取该表中某些行的<span class="jill"></span>X<span class="jill"></span>锁</span></li></ul></details><div class="wolai-block wolai-text"><div><span class="inline-wrap">因为表锁是很重的，很影响性能，所以<span class="jill"></span>MySQL<span class="jill"></span>里面，表锁不是必须的，可以只用行锁。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">这种方式带来了一个问题，上表锁的时候，怎么知道表里面的记录有没有锁，是什么模式的锁？</span></div></div><div class="wolai-block wolai-text"><div><span class="green inline-wrap"><b>为了解决这个问题，InnoDB<span class="jill"></span>提供了另一种表锁：意向锁。</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">意向锁有两种类型：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">意向共享锁（IS）：表示事务打算在表中的某几行上设置共享锁。</span><span class="inline-wrap"><code>SELECT ... LOCK IN SHARE MODE</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">意向排他锁（IX）：表示事务打算在表中的某几行上设置独占锁。</span><span class="inline-wrap"><code>SELECT ... FOR UPDATE</code></span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">意向锁协议如下：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在事务可以获取表中某一行的共享锁之前，它必须首先在表上获取<span class="jill"></span>IS<span class="jill"></span>锁或更高级别的<span class="jill"></span>IX<span class="jill"></span>锁。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在事务可以获取表中某一行的独占锁之前，它必须首先获取表上的<span class="jill"></span>IX<span class="jill"></span>锁。</span></li></ul><aside class="bg-cultured wolai-block"><div data-symbol="❄️" class="icon"></div><span class="inline-wrap">通过意向锁，可以知道表里面的记录有没有上锁，上的是什么锁。</span></aside><div class="wolai-block wolai-text"><div><span class="inline-wrap">行锁也有三种类型：记录锁、间隙锁、Next-Key<span class="jill"></span>锁。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">记录锁：普通行锁，锁住一条记录</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">间隙锁：锁住两行之间的间隙，在上锁期间不允许在间隙里新增记录，用于解决幻读问题</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Next-Key<span class="jill"></span>锁：记录锁<span class="jill"></span>+<span class="jill"></span>间隙锁，锁定一个范围，并且锁定记录本身</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">create</span> <span class="token keyword">table</span> t <span class="token punctuation">(</span>a <span class="token keyword">int</span> <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token punctuation">,</span> b <span class="token keyword">int</span> <span class="token punctuation">,</span> <span class="token keyword">key</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> z <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> z <span class="token keyword">select</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> z <span class="token keyword">select</span> <span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> z <span class="token keyword">select</span> <span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> z <span class="token keyword">select</span> <span class="token number">10</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">;</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> b <span class="token operator">=</span> <span class="token number">3</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
<span class="token comment">-- 对B在区间[1,6]进行加锁</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> a <span class="token operator">=</span> <span class="token number">5</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
<span class="token comment">-- 由于a是主键，因此只会锁定a=5这一行，而不是[1,5]这个区间</span>
<span class="token comment">-- 这就叫做Next-Key Lock降级为Record Lock</span></pre></div></code-block><h3 class="wolai-block"><span class="inline-wrap">MVCC</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">对于读与写并发来说，如果用锁来解决，读写相互阻塞，很容易产生性能问题。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">MVCC<span class="jill"></span>是一种机制，它可以读通无锁的方式解决读写并发问题（读写并发问题看上面）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">每一条数据除了建表时声明的字段，他还有两个隐藏字段，分别是事务<span class="jill"></span>Id<span class="jill"></span>和回滚指针。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">每开启一次事务，都会生成一个事务<span class="jill"></span>Id。隐藏字段里的事务<span class="jill"></span>Id<span class="jill"></span>记录的就是修改这条记录的事务<span class="jill"></span>Id。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">数据修改前，会在回滚日志里记录旧数据，回滚指针指向当前数据上一个版本在回滚日志中的位置。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">MVCC<span class="jill"></span>就是通过这两个字段加<span class="jill"></span>Read View<span class="jill"></span>实现的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Read View<span class="jill"></span>里面有四个重要的<span class="jill"></span>Id<span class="jill"></span>字段。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">m_ids：在生成<span class="jill"></span>ReadView<span class="jill"></span>时，系统当前正在执行的事务的<span class="jill"></span>Id<span class="jill"></span>列表</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">min_trx_id：m_ids<span class="jill"></span>中的最小值</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">max_trx_id：在生成<span class="jill"></span>ReadView<span class="jill"></span>时，系统应该分配给下一个事务的事务<span class="jill"></span>Id</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">creator_trx_id：生成该<span class="jill"></span>ReadView<span class="jill"></span>的事务的<span class="jill"></span>Id</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">通过事务<span class="jill"></span>Id、回滚指针、以及<span class="jill"></span>Read View<span class="jill"></span>的这四个<span class="jill"></span>Id<span class="jill"></span>决定你能看到哪个版本的数据。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果被访问版本的<span class="jill"></span>trx_id<span class="jill"></span>等于<span class="jill"></span>ReadView<span class="jill"></span>中的<span class="jill"></span>creator_trx_id，说明该版本是该事务创建的，能被看见</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果被访问版本的<span class="jill"></span>trx_id<span class="jill"></span>小于<span class="jill"></span>ReadView<span class="jill"></span>中的<span class="jill"></span>min_trx_id，说明生成该版本的事务在<span class="jill"></span>ReadView<span class="jill"></span>创建前已提交，所以当前事务能看到这个版本</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果被访问版本的<span class="jill"></span>trx_id 大于<span class="jill"></span>min_trx_id 以及 小于<span class="jill"></span>max_trx_id，判断该<span class="jill"></span>trx_id<span class="jill"></span>是否在<span class="jill"></span>m_ids<span class="jill"></span>中，如果不在，说明创建<span class="jill"></span>ReadView<span class="jill"></span>时，该事务已经提交了，所以这版本是可以被当前事务所看见的</span></li></ul><aside class="bg-cultured wolai-block"><div data-symbol="❄️" class="icon"></div><span class="inline-wrap">trx_id == creator_trx_id
|| trx_id &lt; min_trx_id
|| (trx_id &gt; min_trx_id &amp;&amp; trx_id &lt; max_trx_id &amp;&amp; trx_id in m_ids)</span></aside><div class="wolai-block wolai-text"><div><span class="red inline-wrap">基于事务的隔离级别，Read View<span class="jill"></span>有两种创建方式。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果是读已提交的隔离级别，每执行同一条查询语句，就创建一个<span class="jill"></span>ReadView。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果是可重复读的隔离级别，同一条查询语句只有在首次执行时才会创建<span class="jill"></span>ReadView。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">当前读</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">当前读就是字面意思，读取的数据是</span><span class="inline-wrap"><b>数据的最新版本</b></span><span class="inline-wrap">，以下查询都属于当前读：</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">table</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span> <span class="token comment">-- 手动加共享锁</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">table</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">for</span> <span class="token keyword">update</span> <span class="token comment">-- 手动加排他锁</span>

<span class="token keyword">update</span> <span class="token keyword">table</span> col1<span class="token operator">=</span>val1<span class="token punctuation">,</span> col2<span class="token operator">=</span>val2 <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">-- 更新语句，自动加排他锁</span>

<span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">table</span> <span class="token punctuation">(</span>col1<span class="token punctuation">,</span>col2<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>val1<span class="token punctuation">,</span>val2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 插入语句，自动加排他锁</span>

<span class="token keyword">delete</span> <span class="token keyword">from</span> <span class="token keyword">table</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">-- 插入语句，自动加排他锁</span></pre></div></code-block><h3 class="wolai-block"><span class="inline-wrap">快照读</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">由于数据存在多个版本，因此快照读顾名思义就是读取到的数据是历史数据，默认的<span class="jill"></span>select(不加<span class="jill"></span>for update<span class="jill"></span>以及<span class="jill"></span>lock in share mode)就是读取快照读。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">MySQL<span class="jill"></span>在<span class="jill"></span>RR<span class="jill"></span>隔离级别下能解决幻读吗？怎么实现的？</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果整个事务中只存在读操作，那么是可以解决幻读问题的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果存在修改操作，那要看情况，修改操作会触发当前读，可以读到别的事务最新提交的数据。如果这次修改操作又刚好修改了最新提交的数据，并且使得它们满足查询条件。那么是会有幻读问题的。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image.png" style="width: 100%"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">事务<span class="jill"></span>1<span class="jill"></span>在<span class="jill"></span>update<span class="jill"></span>后，对该数据加锁，事务<span class="jill"></span>B<span class="jill"></span>无法插入新的数据，这样事务<span class="jill"></span>A<span class="jill"></span>在<span class="jill"></span>update<span class="jill"></span>前后数据保持一致，避免了幻读，可以明确的是，update<span class="jill"></span>锁的肯定不只是已查询到的几条数据，因为这样无法阻止<span class="jill"></span>insert，有同学会说,那就是锁住了整张表呗，其实不是，这里的锁是 Next Key Lock。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">比如某一个辅助索引（比如上面的<span class="jill"></span>class_id），如果它有<span class="jill"></span>1,3,5<span class="jill"></span>这几个值，那么当我们使用<span class="jill"></span>next key lock<span class="jill"></span>的锁住<span class="jill"></span>class_id=1<span class="jill"></span>的时候，实际上锁住了（-无穷，1]，或者锁住<span class="jill"></span>class_id=3<span class="jill"></span>的时候，实际上锁住的是（1,3]，也就是一个左开右闭的区间。如果此时别的事务要在这个区间内插入数据，就会被阻塞住。这个锁一直到事务提交才会释放。因此，即使出现了上面图片里面这种情况，也可以保证前后两次去读的内容一致，因为对这个辅助索引上的锁是：“next key lock”，他会锁住一个区间。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">但是注意，对于可重复读默认使用的就是<span class="jill"></span>next key lock，但是对于“唯一索引”，比如主键的索引，next key lock<span class="jill"></span>会降级成行锁，而不会锁住一个区间。因此，如果上面的事务<span class="jill"></span>1<span class="jill"></span>的<span class="jill"></span>update<span class="jill"></span>使用的是主键，事务<span class="jill"></span>2<span class="jill"></span>也使用主键进行插入，那么实际上事务<span class="jill"></span>2<span class="jill"></span>根本不会被阻塞，可以立即插入并返回。而对于非唯一索引，next key lock<span class="jill"></span>则不会降级。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_1.png" style="width: 668px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">事务<span class="jill"></span>2<span class="jill"></span>新增了数据，事务<span class="jill"></span>1<span class="jill"></span>的更新操作触发了当前读，会读取到事务<span class="jill"></span>2<span class="jill"></span>新增的数据，然后事务<span class="jill"></span>1<span class="jill"></span>的更新操作又修改了事务<span class="jill"></span>2<span class="jill"></span>新增的数据。导致这条新增的数据，最新的<span class="jill"></span>trx_id<span class="jill"></span>是事务<span class="jill"></span>1<span class="jill"></span>的<span class="jill"></span>trx_id，并且让它符合了查询条件。最终导致第三次查询出现了幻读。</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://www.cnblogs.com/xuwc/p/13873293.html">MVCC能否解决幻读 - xuwc - 博客园</a><div class="info-box"><div class="text-pane"><div data-title="MVCC能否解决幻读 - xuwc - 博客园"></div><div data-desc="参考： https://blog.csdn.net/qq_35590091/article/details/107734005 https://blog.csdn.net/ashic/article/"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://common.cnblogs.com/favicon.svg&quot;)"></div><div data-hostname="www.cnblogs.com"></div></div></div><div class="preview-pane"></div></div></div></details><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></article><footer></footer></body></html>
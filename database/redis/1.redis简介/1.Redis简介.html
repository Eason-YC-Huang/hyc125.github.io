<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/wolai.css"/><title>1.Redis简介 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="1.Redis简介" class="main-title"></div></div></header><article><h2 class="wolai-block"><span class="inline-wrap">Redis<span class="jill"></span>简介</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Redis<span class="jill"></span>是一个客户端-服务器模式的数据库，Redis<span class="jill"></span>服务器管理着多个<span class="jill"></span>Redis<span class="jill"></span>数据库，我们通过<span class="jill"></span>Redis<span class="jill"></span>客户端连接<span class="jill"></span>Redis<span class="jill"></span>服务器，对<span class="jill"></span>Redis<span class="jill"></span>数据库执行相应的操作。Redis<span class="jill"></span>数据库是<span class="jill"></span>key-value<span class="jill"></span>类型数据库，key<span class="jill"></span>是字符串类型，value<span class="jill"></span>有五种数据结构可以使用，分别是字符串、列表、哈希、有序集合、无序集合。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">Redis<span class="jill"></span>数据结构</span></h2><h3 class="wolai-block"><span class="inline-wrap">Redis<span class="jill"></span>中的字符串</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>Redis</code></span><span class="inline-wrap">的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 </span><span class="inline-wrap"><code>ArrayList</code></span><span class="inline-wrap">，采用预分配冗余空间的方式来减少内存的频繁分配，当字符串长度小于</span><span class="inline-wrap"><code>1M</code></span><span class="inline-wrap">时，扩容都是加倍现有的空间，如果超过 </span><span class="inline-wrap"><code>1M</code></span><span class="inline-wrap">，扩容时一次只会多扩 </span><span class="inline-wrap"><code>1M</code></span><span class="inline-wrap">的空间。需要注意的是字符串最大长度为 </span><span class="inline-wrap"><code>512M</code></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>Redis</code></span><span class="inline-wrap">的字符串是二进制安全的。二进制安全(binary safe)是什么意思？  A binary safe string is one that can consist of any characters (bytes).For example, many programming languages use the 0x00 character as an end-of-string marker, so in that sense a binary safe string is one that can consist of these.比如<span class="jill"></span>C<span class="jill"></span>语言中，用“\0”表示字符串的结束，如果字符串中本身就有“\0”字符，字符串就会被截断，即非二进制安全；若通过某种机制，保证读写字符串时不损害其内容，则是二进制安全。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="PowerShell" class="marker"></div><pre>GET mykey 
<span class="token function">SET</span> mykey <span class="token string">"１"</span>
APPEND mykey <span class="token string">" ２"</span> <span class="token comment">#　往key对应的值新增字符串</span>
INCR mykey <span class="token comment"># 13</span>
DESC mykey <span class="token comment"># 12</span>
INCRBY mykey 3 <span class="token comment"># 15</span>
DESCBY mykey 3 <span class="token comment">#12</span>
STRLEN mykey <span class="token comment">#2</span>

SETEX mykey 1 1 <span class="token comment">#１秒后过期</span>
SETNX mykey 1</pre></div></code-block><h3 class="wolai-block"><span class="inline-wrap">Redis<span class="jill"></span>中的列表</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)，当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Redis<span class="jill"></span>的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进<span class="jill"></span>Redis<span class="jill"></span>的列表，另一个线程从这个列表中轮询数据进行处理。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="PowerShell" class="marker"></div><pre>LLEN  myList <span class="token comment"># list len 列表的长度</span>
LPUSH   LPOP <span class="token comment"># 栈</span>
LPUSH   RPOP <span class="token comment"># 队列</span>
BLPOP <span class="token comment"># 阻塞队列，获取元素时，如果没有元素，会阻塞该请求</span>
LINDEX mylist 1 <span class="token comment"># 获取第一个元素</span></pre></div></code-block><h3 class="wolai-block"><span class="inline-wrap">Redis<span class="jill"></span>中的<span class="jill"></span>hash<span class="jill"></span>表</span></h3><h3 class="wolai-block"><span class="inline-wrap">Redis<span class="jill"></span>中的集合</span></h3><h3 class="wolai-block"><span class="inline-wrap">Redis<span class="jill"></span>中的有序集合</span></h3><h3 class="wolai-block"><span class="inline-wrap">Redis<span class="jill"></span>中的位图</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">Redis<span class="jill"></span>中的位图并不是真实存在的数据类型，只是<span class="jill"></span>Redis<span class="jill"></span>提供了面向位(bit)的方法来操作字符串。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">字符串最大长度为 </span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>512</mn><mi>M</mi><mo>=</mo><mo stretchy="false">(</mo><mn>512</mn><mo>∗</mo><mn>1024</mn><mo>∗</mo><mn>1024</mn><mo>∗</mo><mn>8</mn><mo stretchy="false">)</mo><mi>b</mi><mi>i</mi><mi>t</mi><mo>=</mo><msup><mn>2</mn><mn>32</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">512M = (512*1024*1024*8)bit = 2^{32}bit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">512</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">512</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1024</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1024</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">8</span><span class="mclose">)</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span></span></span></div></div><h3 class="wolai-block"><span class="inline-wrap">Redis<span class="jill"></span>中的<span class="jill"></span>HyperLogLog</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">HyperLogLog<span class="jill"></span>是用来做基数统计的。基数就是指一个集合中不同值的数目，比如[a,b,c,d]的基数就是<span class="jill"></span>4，[a,b,c,d,a]的基数还是<span class="jill"></span>4，因为<span class="jill"></span>a<span class="jill"></span>重复了一个。一般来说，做基数统计需要记住所有数据，但如果数据量很大，会消耗不少的内存，HyperLogLog<span class="jill"></span>用精准度换内存，在<span class="jill"></span>Redis<span class="jill"></span>实现的情况下，该误差小于<span class="jill"></span>1％。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://juejin.im/post/5c7900bf518825407c7eafd0"><span>HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的</span></a></span></div></div><h3 class="wolai-block"><span class="inline-wrap">Redis<span class="jill"></span>中的<span class="jill"></span>geospatial indexes</span></h3><h3 class="wolai-block"><span class="inline-wrap">Redis<span class="jill"></span>中的<span class="jill"></span>streams</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">Redis 5.0 全新的数据类型：streams，官方把它定义为：以更抽象的方式建模日志的数据结构。Redis<span class="jill"></span>的<span class="jill"></span>streams<span class="jill"></span>主要是一个<span class="jill"></span>append only<span class="jill"></span>的数据结构，至少在概念上它是一种在内存中表示的抽象数据类型，只不过它们实现了更强大的操作，以克服日志文件本身的限制。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果你了解<span class="jill"></span>MQ，那么可以把<span class="jill"></span>streams<span class="jill"></span>当做<span class="jill"></span>MQ。如果你还了解<span class="jill"></span>kafka，那么甚至可以把<span class="jill"></span>streams<span class="jill"></span>当做<span class="jill"></span>kafka。(学<span class="jill"></span>Kafka<span class="jill"></span>的时候回过头来看看)</span></div></div><h2 class="wolai-block"><span class="inline-wrap">管道</span></h2><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">使用管道技术将多条命令打包，减少网络<span class="jill"></span>IO<span class="jill"></span>次数。</span></li><li><div class="marker"></div><span class="inline-wrap">管道中的命令数量要适当，并不是越多越好，如果客户端使用管道发送了多条命令，服务器存放命令的队列可能会耗尽内存。</span></li></ol><h2 class="wolai-block"><span class="inline-wrap">发布与订阅</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Redis<span class="jill"></span>的发布与订阅功能由<span class="jill"></span>PUBLISH、SUBSCRIBE、PSUBSCRIBE<span class="jill"></span>等命令组成。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">通过执行<span class="jill"></span>SUBSCRIBE<span class="jill"></span>命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者（subscriber）：每当有其他客户端向被订阅的频道发送消息（message）时，频道的所有订阅者都会收到这条消息。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="PowerShell" class="marker"></div><pre>subscribe <span class="token string">"topic a"</span> <span class="token string">"topic b"</span> <span class="token comment"># 订阅主题</span>
unsubscribe <span class="token string">"topic a"</span> <span class="token comment"># 退订</span>
psubscribe <span class="token string">"topic *"</span> <span class="token comment"># 通过模式订阅主题</span>
unpsubscribe <span class="token string">"topic *"</span> <span class="token comment"># 通过模式退订主题</span>
publish <span class="token string">"topic a"</span> <span class="token string">"hello"</span> <span class="token comment"># 发布消息到特定主题</span></pre></div></code-block><h2 class="wolai-block"><span class="inline-wrap">主从、哨兵、集群</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>1.主从模式</b></span><span class="inline-wrap">：读写分离，备份，一个<span class="jill"></span>Master<span class="jill"></span>可以有多个<span class="jill"></span>Slaves。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>2.哨兵</b></span><span class="inline-wrap">：监控，自动转移，哨兵发现主服务器挂了后，就会从<span class="jill"></span>slave<span class="jill"></span>中重新选举一个主服务器。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>3.集群</b></span><span class="inline-wrap">：为了解决单机<span class="jill"></span>Redis<span class="jill"></span>容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS<span class="jill"></span>不受限于单机，可受益于分布式集群高扩展性。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">Redis<span class="jill"></span>客户端</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>常用的<span class="jill"></span>Redis<span class="jill"></span>客户端有<span class="jill"></span>Jedis、Lettuce、Redison</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">目前市场上大部分都是使用<span class="jill"></span>Jedis，但是<span class="jill"></span>Jedis<span class="jill"></span>有个问题，Jedis<span class="jill"></span>实例并不是线程安全的，Jedis<span class="jill"></span>实例无法被多个线程共享，Jedis<span class="jill"></span>对该问题的解决方案是使用连接池，线程从连接池中获取连接，然后发送指令。使用连接池无可避免增加了资源的消耗。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Lettuce<span class="jill"></span>基于<span class="jill"></span>netty<span class="jill"></span>实现并且是线程安全的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Redison</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://www.cnblogs.com/link1988/p/5503692.html"><span>Jedis<span class="jill"></span>基本使用</span></a></span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token comment">// 建立连接</span>
<span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
jedis<span class="token punctuation">.</span><span class="token function">auth</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 基本使用</span>
jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 管道</span>
<span class="token class-name">Pipeline</span> pipelined <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">pipelined</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pipelined<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"greet"</span><span class="token punctuation">,</span> <span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pipelined<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span><span class="token string">"greet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//  pipelined.sync();</span>
pipelined<span class="token punctuation">.</span><span class="token function">syncAndReturnAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 事务</span>
<span class="token class-name">Transaction</span> tx <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">multi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// tx.set("name","hdr");</span>
<span class="token comment">// ....</span>
tx<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// or tx.discard();</span>

<span class="token comment">// 发布订阅</span></pre></div></code-block></article><footer></footer></body></html>
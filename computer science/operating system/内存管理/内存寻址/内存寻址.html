<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>内存寻址 - wolai 笔记</title><link rel="shortcut icon"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="内存寻址" class="main-title"></div></div></header><article><div class="wolai-block wolai-text"><div><span class="inline-wrap">CPU<span class="jill"></span>要从内存中读写数据，就必须要知道数据所在的内存地址。那么<span class="jill"></span>CPU<span class="jill"></span>是怎么知道要读写的内存地址呢？这个过程就叫做内存寻址。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">实模式</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">上面讲<span class="jill"></span>8086 时说到，8086 CPU 会根据<span class="jill"></span>CS<span class="jill"></span>和<span class="jill"></span>IP<span class="jill"></span>来计算指令所在的内存地址，为什么什么要这么做呢？</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">8086<span class="jill"></span>地址总线的宽度是<span class="jill"></span>20<span class="jill"></span>位，可能当时<span class="jill"></span>Intel<span class="jill"></span>认为，16<span class="jill"></span>位的地址总线（寻址能力<span class="jill"></span>64KB）是不够竞争力的，然后又因为成本问题，</span><span class="inline-wrap"><b>所以最终设计为<span class="jill"></span>20<span class="jill"></span>位</b></span><span class="inline-wrap">。但是<span class="jill"></span>16<span class="jill"></span>位的寄存器是无法完全利用<span class="jill"></span>20<span class="jill"></span>位的地址总线的。天才的设计师们想到了一个解决办法，那就是使用两个寄存器，其中一个寄存器(CS)的值左移<span class="jill"></span>4<span class="jill"></span>位（二进制），然后与另一个寄存器(IP)的值相加，那么就能完全利用<span class="jill"></span>20<span class="jill"></span>位的地址总线了。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>这就是后来被称为实模式下的寻址方式。</b></span></div></div><aside class="bg-cultured wolai-block"><div class="icon"></div><span class="inline-wrap">实模式下段的大小不是完全一样，例如当<span class="jill"></span>CS<span class="jill"></span>的值是<span class="jill"></span>FFFF<span class="jill"></span>时，IP<span class="jill"></span>就只剩下<span class="jill"></span>4<span class="jill"></span>个位可以用了，这时候段的大小是<span class="jill"></span>2^4=16Byte，当<span class="jill"></span>CS<span class="jill"></span>的值位于[0~F]000<span class="jill"></span>时，IP<span class="jill"></span>就能完全利用<span class="jill"></span>16<span class="jill"></span>位，这时候段的大小是<span class="jill"></span>2^16=64Kb</span></aside><h2 class="wolai-block"><span class="inline-wrap">保护模式</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">32<span class="jill"></span>位处理器下，通用寄存器变成了<span class="jill"></span>32<span class="jill"></span>位的，但是段寄存器仍然是<span class="jill"></span>16<span class="jill"></span>位，不过段寄存器的含义已经发生了变化，此时的它被称为段选择子。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">全局描述符表</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">内存中存储着一个叫</span><span class="inline-wrap"><b>全局段描述符表</b></span><span class="inline-wrap">的数据结构，里面记录了多个</span><span class="inline-wrap"><b>段描述符</b></span><span class="inline-wrap">，一个段描述符描述了一个段的特征和属性，例如段的起始位置、段的大小以及访问权限等等。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">CPU<span class="jill"></span>里有一个<span class="jill"></span>48<span class="jill"></span>位</span><span class="inline-wrap"><code>GDTR</code></span><span class="inline-wrap">寄存器，该寄存器分成两个部分，前<span class="jill"></span>16<span class="jill"></span>位存放全局描述符表的大小（</span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="inline-wrap"> Byte = 64Kb），后<span class="jill"></span>32<span class="jill"></span>位用来存放全局描述符在内存中的起始地址。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>简单来讲，把全局描述符当做由段描述符组成的数组，然后段选择子就是用来获取特定段描述符的索引</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">一个段描述符占</span><span class="inline-wrap"><code>8</code></span><span class="inline-wrap">字节，也就是说全局描述符表最多拥有<span class="jill"></span>8192（</span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>÷</mo><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><msup><mn>2</mn><mn>13</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}\div2^{3}=2^{13}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="inline-wrap">）个段描述符。</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/my-gdt.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">上图是段描述符的格式，可以看出描述符中用<span class="jill"></span>32<span class="jill"></span>位记录段的起始地址，用<span class="jill"></span>20<span class="jill"></span>位记录段的大小。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">你可能会疑惑，为什么描述符中的段基地址和和段界限不是连续的？</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">那是因为要向前兼容，在<span class="jill"></span>80386<span class="jill"></span>处理器之前，有一款<span class="jill"></span>80286<span class="jill"></span>处理器，它是<span class="jill"></span>16<span class="jill"></span>位处理器，也有保护模式，地址总线是<span class="jill"></span>24<span class="jill"></span>位的，允许访问最多<span class="jill"></span>16M<span class="jill"></span>的内存，它段描述符格式见下图</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/my-80286-gdt.png" style="width: 754px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以看到，80386<span class="jill"></span>的段描述就是把<span class="jill"></span>80286<span class="jill"></span>段描述剩余的<span class="jill"></span>16<span class="jill"></span>位也利用起来</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">G<span class="jill"></span>位是粒度位（Granularity），表示段界限的单位</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">G<span class="jill"></span>位是“0”时，段界限以<span class="jill"></span>Byte<span class="jill"></span>为单位，此时段的扩展范围是[1B~1MB]</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">G<span class="jill"></span>位是“1”时，段界限以<span class="jill"></span>4KB<span class="jill"></span>为单位，此时段的扩展范围是[4KB~4GB]</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">D/B<span class="jill"></span>位（1<span class="jill"></span>位）0<span class="jill"></span>表示指令中的偏移地址或操作数是<span class="jill"></span>16<span class="jill"></span>位，1<span class="jill"></span>则对应表示<span class="jill"></span>32<span class="jill"></span>位，基本都是<span class="jill"></span>1，因为<span class="jill"></span>16<span class="jill"></span>位的保护模式非常罕见</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">L<span class="jill"></span>位 64<span class="jill"></span>位代码标记位，保留给<span class="jill"></span>64<span class="jill"></span>位处理器使用，32<span class="jill"></span>位处理器下，把此位设“0”即可</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AVL<span class="jill"></span>位 是软件可以使用的位，通常由操作系统来使用，处理器并不使用它</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">P<span class="jill"></span>位（segment present）表示该描述符所对应的段是否存在，1<span class="jill"></span>存在，0<span class="jill"></span>不存在</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">DPL（descriptor privilege level）（2<span class="jill"></span>位）表示描述符的特权级</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">共有四种处理器支持的特权级别，分别是<span class="jill"></span>0、1、2、3，0<span class="jill"></span>的级别最高，3<span class="jill"></span>的级别最低</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">S<span class="jill"></span>位用于指定描述符的类型</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">S<span class="jill"></span>为是“0”时，表示这是一个系统段</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">S<span class="jill"></span>为是“1”时，表示这是一个代码段或数据段（栈段是特殊的数据段）</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">TYPE</span></li></ul><div class="wolai-block wolai-center"><figure><img src="media/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6-type%E8%AF%B4%E6%98%8E.png" style="width: 760px"/></figure></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">X：执行位：0：不可执行，1：可执行</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">E：扩展位：0：段向上扩展，1：段向下扩展</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">W：写位：0：段是不允许写入的，1：段实可以写入的</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">A：已访问位：指示该描述符指向的段最近是否被访问过，每当该段被访问时，处理器自动将其置为“1”，该位的清零由软件（操作系统）负责，通过定期监视该位的状态，就可以统计出该段的使用频率</span></li></ul><h3 class="wolai-block"><span class="inline-wrap">局部描述符表</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">全局描述符是所有进程共用的，对于每个进程还有独自的局部描述符表。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">+</span>
<span class="token operator">|</span> <span class="token class-name">Index</span>       <span class="token operator">|</span><span class="token class-name">T</span><span class="token operator">|</span> RPL<span class="token operator">|</span>
<span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">+</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">段选择子是</span><span class="inline-wrap"><code>16</code></span><span class="inline-wrap">位的，前</span><span class="inline-wrap"><code>13</code></span><span class="inline-wrap">位</span><span class="inline-wrap"><code>Index</code></span><span class="inline-wrap">是描述符表的索引，</span><span class="inline-wrap"><code>T</code></span><span class="inline-wrap">表示描述符表的类型</span><span class="inline-wrap"><code>0=GDT, 1=LDT</code></span><span class="inline-wrap">，</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>RPL</code></span><span class="inline-wrap"> 就是特权级了，一共分为四层，</span><span class="inline-wrap"><code>0</code></span><span class="inline-wrap"> 为最高特权级，</span><span class="inline-wrap"><code>3</code></span><span class="inline-wrap"> 为最低特权级。当地址访问时，如果 </span><span class="inline-wrap"><code>RPL</code></span><span class="inline-wrap"> 的权限低于目标特权级(</span><span class="inline-wrap"><code>DPL</code></span><span class="inline-wrap">)时，就会拒绝访问，于是就起到了保护的作用。</span></div></div><aside class="bg-cultured wolai-block"><div data-symbol="🚀" class="icon"></div><span class="inline-wrap">分段已经是过去式了，Intel<span class="jill"></span>和<span class="jill"></span>AMD<span class="jill"></span>在<span class="jill"></span>64<span class="jill"></span>位模式下内存并不分段，所有的段基址都是<span class="jill"></span>0，就是<span class="jill"></span>32<span class="jill"></span>位<span class="jill"></span>CPU，主流的操作系统也是使用平坦模型。</span></aside><h2 class="wolai-block"><span class="inline-wrap">分页</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">前面讲到段描述符有个标志位“A”，操作系统通过记录该位的变化情况，可以得知该描述符对应段的使用频率，当内存不足时，可以把不频繁使用的段换出到磁盘上，从而空出内存给别的程序使用</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">但是因为段的长度不定，在分配内存时，可能会发生内存中的空闲区域小于要加载的段，或者空闲区域远远大于要加载的段，为了更好的管理和利用内存，从<span class="jill"></span>80386<span class="jill"></span>处理器开始，引入了分页机制。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">页目录、页表、页</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">分页机制把<span class="jill"></span>4G<span class="jill"></span>内存分成大小相同的页，页的最小单位是<span class="jill"></span>4KB（4096<span class="jill"></span>字节），4G<span class="jill"></span>内存一共可分为<span class="jill"></span>4G/4KB=</span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>÷</mo><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}÷2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="inline-wrap">=</span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="inline-wrap">=1048576=0x100000<span class="jill"></span>个页</span></div><div class="wolai-block wolai-center"><figure><img src="media/%E5%88%86%E9%A1%B5-%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png" style="width: 273px"/></figure></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在处理器内部，有一个控制寄存器<span class="jill"></span>CR3，用于存放当前任务的</span><span class="inline-wrap"><b>页目录</b></span><span class="inline-wrap">的物理地址</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>页目录</b></span><span class="inline-wrap">可以看作是一个数组，大小是<span class="jill"></span>4KB，用来存放</span><span class="inline-wrap"><b>页表</b></span><span class="inline-wrap">的物理地址(4Byte)，也就是一共有<span class="jill"></span>1024<span class="jill"></span>个页表的物理地址</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>页表</b></span><span class="inline-wrap">也可以看作是一个数组，大小是<span class="jill"></span>4KB，用来存放</span><span class="inline-wrap"><b>页</b></span><span class="inline-wrap">的物理地址(4Byte)，也就是一共有<span class="jill"></span>1024<span class="jill"></span>个页的物理地址</span></div></div><blockquote class="wolai-block"><span class="inline-wrap">一个页目录记录了<span class="jill"></span>1024<span class="jill"></span>个页表的物理地址，一个页表记录了<span class="jill"></span>1024<span class="jill"></span>个页的物理地址，也就是它们一共记录了</span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="inline-wrap">个页的地址</span></blockquote><h3 class="wolai-block"><span class="inline-wrap">分页机制下的寻址</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">分页机制下，处理器段部件输出的<span class="jill"></span>32<span class="jill"></span>位<span class="jill"></span>0<span class="jill"></span>和<span class="jill"></span>1<span class="jill"></span>被分成了<span class="jill"></span>3<span class="jill"></span>部分</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">高<span class="jill"></span>10<span class="jill"></span>位：页目录的索引</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">中<span class="jill"></span>10<span class="jill"></span>位：页表的索引</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">低<span class="jill"></span>12<span class="jill"></span>位：页内偏移量</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">举个例子</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6-%E5%AF%BB%E5%9D%80%E4%BE%8B%E5%AD%90.png" style="width: 760px"/></figure></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="PowerShell" class="marker"></div><pre>假设CR3寄存器中的内容是`0x00005000`，段部件输出`0x00801050`
0x00801050 = 00_0000_0010 00_0000_0001 0000_0101_0000
<span class="token comment"># 高10位=00_0000_0010=0x2,它是页目录表内的索引</span>
<span class="token comment"># 处理器将它乘以4（因为每个目录项为4字节）= 0x8，作为偏移量访问页目录</span>
<span class="token comment"># 处理器访问0x00005000+0x8，得到页表的物理地址是0x08001000</span>

<span class="token comment"># 中10位=00_0000_0001=0x1,它是页表的索引</span>
<span class="token comment"># 同理，处理器访问0x08001000+0x4，得到页的物理地址是0x08001004</span>

<span class="token comment"># 低12位=0000_0101_0000=0x50，它是页内偏移量</span>
<span class="token comment"># 0x08001004+0x50得到的就是目标物理地址</span></pre></div></code-block><aside class="bg-cultured wolai-block"><div class="icon"></div><span class="inline-wrap">为什么能这么巧，段部件输出的地址为什么能刚好分页</span></aside><aside class="bg-cultured wolai-block"><div data-symbol="🚀" class="icon"></div><span class="inline-wrap">操作系统会根据程序要使用的内存大小，以及内存在虚拟地址空间中的位置，算出需要多少页，以及页的物理地址要写在哪个页目录的哪些页表里。</span></aside><div class="wolai-block wolai-text"><div><span class="inline-wrap">例如，程序要使用虚拟地址空间的一段内存</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">首地址是 </span><span class="inline-wrap"><code>0b0000000001_0000000001_000000000000</code></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">末地址是 </span><span class="inline-wrap"><code>0b0000000001_0000000003_111111111111</code></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以看出它的内存大小是 </span><span class="inline-wrap"><code>0b0000000000_0000000002_111111111111</code></span><span class="inline-wrap">，这需要三个页。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">操作系统根据虚拟地址，算出要把这三页的物理地址写到，哪条页目录下的哪些页表里。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">页目录项和页表的组成</span></h3><div class="wolai-block wolai-center"><figure><img src="media/image.png" style="width: 760px"/></figure></div><aside class="bg-cultured wolai-block"><div data-symbol="🚀" class="icon"></div><span class="inline-wrap">可以看出，页目录项和页表项结构其实是差不多的，除了第七位有点区别</span></aside><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">P(Present) 存在位，1<span class="jill"></span>表示页表或页存位于内存中，否则表示页表或页不存在于内存中，必须先创建，或者从磁盘调入内存后才可使用</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"></span><br/></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">TLB</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">TLB(translation lookaside buffer) ，是<span class="jill"></span>CPU<span class="jill"></span>的一种缓存，用于加速虚拟地址到物理地址的转译速度。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">TLB<span class="jill"></span>中缓存虚拟地址和物理地址映射关系，在地址翻译时比查表要快得多。进程在访问内存地址时，首先把该虚拟地址发往<span class="jill"></span>TLB<span class="jill"></span>确认是否命中<span class="jill"></span>cache，如果<span class="jill"></span>cache hit<span class="jill"></span>直接可以得到物理地址，否则需要老老实实得进行查表操作。同时当进程地址空间中地址映射关系改变后，TLB<span class="jill"></span>需要同步刷新。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">不同于高速缓存，TLB<span class="jill"></span>中放的映射关系跟<span class="jill"></span>OS<span class="jill"></span>相关，不由硬件决定，所以需要<span class="jill"></span>OS<span class="jill"></span>来刷新<span class="jill"></span>TLB（页表改变时，即映射关系改变时需要刷新）。常见的刷新场景有 ：</span></div></div><blockquote class="wolai-block"><span class="inline-wrap">1）进程切换（使用相同进程页表切换，以及内核用户进程切换，不需要刷新）；  
2）页表更改：有新物理地址映射，这时候需要更新<span class="jill"></span>TLB；</span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap">关于<span class="jill"></span>TLB<span class="jill"></span>的详细解释，可以参考</span><span class="inline-wrap"><a href="https://www.zhihu.com/people/smcdef-74"><span>smcdef</span></a></span><span class="inline-wrap">写的一篇《</span><span class="inline-wrap"><a href="https://zhuanlan.zhihu.com/p/108425561?utm_source=wechat_timeline"><span>TLB<span class="jill"></span>原理</span></a></span><span class="inline-wrap">》，写的非常详细易懂。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">页置换策略</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">进程运行时，若其访问的页不在内存而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区。选择调出页面的算法就称为页面置换算法。</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://houbb.github.io/2020/10/04/os-10-page-exchange">操作系统学习(10)页面置换算法</a><div class="info-box"><div class="text-pane"><div data-title="操作系统学习(10)页面置换算法"></div><div data-desc="页面置换算法"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://houbb.github.io/favicon.ico&quot;)"></div><div data-hostname="houbb.github.io"></div></div></div><div class="preview-pane"></div></div></div><h3 class="wolai-block"><span class="inline-wrap">页分配策略</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap"><b>一个进程它的页目录<span class="jill"></span>+<span class="jill"></span>页表一共需要占用多少内存空间？</b></span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">一条记录</span><span class="inline-wrap"><code>4</code></span><span class="inline-wrap">个字节，每个页目录有</span><span class="inline-wrap"><code>1024</code></span><span class="inline-wrap">条记录，也就是</span><span class="inline-wrap"><code>4K</code></span><span class="inline-wrap">的大小。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">每个页表也有</span><span class="inline-wrap"><code>1024</code></span><span class="inline-wrap">条记录，也就是一个页目录有</span><span class="inline-wrap"><code>1024*1024</code></span><span class="inline-wrap">条记录，也就是要占用</span><span class="inline-wrap"><code>4M</code></span><span class="inline-wrap">的大小。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">也就是一个进程的页目录<span class="jill"></span>+<span class="jill"></span>页表一共要占用<span class="jill"></span>4K+4M<span class="jill"></span>的内存。</span></div></div><aside class="bg-cultured wolai-block"><div data-symbol="🚀" class="icon"></div><span class="inline-wrap">一般不会用到这么多的，例如，当你需要用到页目录的第四条记录，它才会创建第四条记录对应的<span class="jill"></span>1024<span class="jill"></span>个页表。</span></aside></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap"><b>为什么要分段、为什么要分页？</b></span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">分段是历史遗留原因，最初的<span class="jill"></span>8086<span class="jill"></span>通过<span class="jill"></span>CS<span class="jill"></span>和<span class="jill"></span>IP<span class="jill"></span>进行寻址，造成了分段。现在<span class="jill"></span>CPU<span class="jill"></span>在<span class="jill"></span>64<span class="jill"></span>位模式下都不分段了，强制每个段的段基址都是<span class="jill"></span>0，段的大小都跟虚拟地址空间一样大。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">因为分段粒度太粗了，导致内存碎片大。分页机制把内存分成大小相同的页，这样就不用把整个段都加载进内存，只需要将用到的页加载进内存。这样内存的利用率就更高了，能同时运行的程序就更多了。由于一页就 4KB， 所以内存交换的性能问题得以缓解，毕竟只要换一定的页，而不需要整个段都换到磁盘中。</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://segmentfault.com/a/1190000038810428">https://segmentfault.com/a/1190000038810428</a><div class="info-box"><div class="text-pane"><div data-title="segmentfault.com"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://segmentfault.com/favicon.ico&quot;)"></div><div data-hostname="segmentfault.com"></div></div></div><div class="preview-pane"></div></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap"><b>什么是虚拟地址？什么是虚拟地址空间？什么是虚拟内存？</b></span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">虚拟内存：从磁盘中找一部分空间当做内存使用，当物理内存不够用时，可以把物理内存的部分数据转存到虚拟内存里，简单来说就是拆东墙补西墙，决定拆哪面墙由页置换算法决定。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">虚拟地址空间是虚拟地址的集合。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap"><b>为什么需要虚拟内存？</b></span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以让系统运行更多的程序</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap"><b>为什么需要虚拟地址？</b></span></summary><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">方便进程间的内存相互隔离</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">每个进程有自己独自的虚拟地址空间，由操作系统负责虚拟地址到物理地址的转换。防止一个进程修改另一个进程的内存数据。</span></div></div></li><li><div class="marker"></div><span class="inline-wrap">方便内存共享</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以把多个虚拟地址空间映射到同一个物理地址空间，从而实现内存共享。</span></div></div></li><li><div class="marker"></div><span class="inline-wrap">简化编译时的链接</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">由于进程使用的是虚拟地址，以<span class="jill"></span>32<span class="jill"></span>位机器为例，每个进程都有<span class="jill"></span>4G<span class="jill"></span>的地址空间。当我们在编译源代码时，就可以为程序里的变量、方法分配这个虚拟地址，链接的时候就可以直接用这个虚拟地址实现链接。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果你不理解什么是链接，你可以简单地理解为：将源代码里的方法调用的地方替换为该方法的内存地址。</span></div></div></li></ol></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap"><b>虚拟内存和物理内存之间什么关系？</b></span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">每个进程有各自完整的虚拟内存，所有进程共享物理内存。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">当进程要访问内存时，CPU<span class="jill"></span>的页部件负责把段部件输出虚拟地址转换成物理地址。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">那么虚拟地址是怎么转换成物理地址呢？</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap"><b>物理地址 线性地址 逻辑地址 虚拟地址 之间什么关系？</b></span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">物理地址就是物理内存真正的地址，相当于内存中每个存储单元的门牌号，具有唯一性。不管在什么模式下，不管什么虚拟地址、线性地址，CPU<span class="jill"></span>最终都要以物理地址去访问内存，只有物理地址才是内存访问的终点站。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在实模式下，“段基址<span class="jill"></span>+<span class="jill"></span>段内偏移地址”经过段部件的处理，直接输出的就是物理地址，CPU<span class="jill"></span>可以直接用此地址访问内存。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">而在保护模式下，“段基址<span class="jill"></span>+<span class="jill"></span>段内偏移地址”称为线性地址。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">若没有开启地址分页功能，此线性地址就被当作物理地址来用，可直接访问内存。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">若开启了分页功能，此线性地址又多了一个名字，就是虚拟地址（虚拟地址、线性地址在分页机制下都是一回事）。虚拟地址要经过<span class="jill"></span>CPU<span class="jill"></span>页部件转换成具体的物理地址，这样<span class="jill"></span>CPU<span class="jill"></span>才能将其送上地址总线去访问内存。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">无论是在实模式或是保护模式下，段内偏移地址又称为逻辑地址，这是程序员可见的地址。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap"><b>描述分页寻址的过程？</b></span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">CPU<span class="jill"></span>有个页目录寄存器，一个任务在运行时，该寄存器存放的是该任务页目录的内存位置。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">段部件输出的虚拟地址，前</span><span class="inline-wrap"><code>10</code></span><span class="inline-wrap">位是页目录的索引，中间</span><span class="inline-wrap"><code>10</code></span><span class="inline-wrap">位是页表的索引，页表的每条记录表示一个页的物理基址，然后结合最后</span><span class="inline-wrap"><code>12</code></span><span class="inline-wrap">表示页内偏移量确定要访问的内存地址。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap"><b>Linux<span class="jill"></span>中进程的理论最大数计算</b></span><span class="inline-wrap">
</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">每个进程的局部段描述表<span class="jill"></span>LDT<span class="jill"></span>都作为一个独立的段而存在，在全局段描述表<span class="jill"></span>GDT<span class="jill"></span>中要有一个表项指向这个段的起始地址，并说明该段的长度以及其他一些 参数。除上之外，每个进程还有一个<span class="jill"></span>TSS<span class="jill"></span>结构。所以，每个进程都要在全局段描述表<span class="jill"></span>GDT<span class="jill"></span>中占据两个表项。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">除一些系统的开销(例如<span class="jill"></span>GDT<span class="jill"></span>中的第<span class="jill"></span>2<span class="jill"></span>项和第<span class="jill"></span>3<span class="jill"></span>项分别用于内核 的代码段和数据段，第<span class="jill"></span>4<span class="jill"></span>项和第<span class="jill"></span>5<span class="jill"></span>项永远用于当前进程的代码段和数据段，第<span class="jill"></span>1<span class="jill"></span>项永远是<span class="jill"></span>0，等等)以外，尚有<span class="jill"></span>8180<span class="jill"></span>个表项可供使用，所以理论上系统中最大的进程数是<span class="jill"></span>8180/2=4090。</span></div></div></details><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">Linux<span class="jill"></span>的内存管理</span></h2><div class="wolai-bookmark wolai-block"><a href="https://zhuanlan.zhihu.com/p/327860921">x86的分页机制和Linux实现</a><div class="info-box"><div class="text-pane"><div data-title="x86的分页机制和Linux实现"></div><div data-desc="前言上一篇《 x86段寄存器和分段机制》了解了x86分段机制原理，以及CPU寻址的整个过程。本片补上寻址的最后一棒：分页机制，并结合linux内核了解下OS中的分页机制实现。为何需要分页机制80x86的两种工作模式：8038…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.a53ae37b.png&quot;)"></div><div data-hostname="zhuanlan.zhihu.com"></div></div></div><div class="preview-pane" style="background-image: url(https://pic1.zhimg.com/v2-14b1f2aa447f3112dc4b4169c8e5a783_720w.jpg?source=172ae18b)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://0xax.gitbooks.io/linux-insides/content/Theory/linux-theory-1.html">Paging · Linux Inside</a><div class="info-box"><div class="text-pane"><div data-title="Paging · Linux Inside"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://0xax.gitbooks.io/linux-insides/content/gitbook/images/apple-touch-icon-precomposed-152.png&quot;)"></div><div data-hostname="0xax.gitbooks.io"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://blog.csdn.net/darmao/article/details/78981649">对linux内核中GDT和LDT的理解_darmao的博客-CSDN博客_gdt linux</a><div class="info-box"><div class="text-pane"><div data-title="对linux内核中GDT和LDT的理解_darmao的博客-CSDN博客_gdt linux"></div><div data-desc="GDT(Global Descriptor Table)　　在实模式下当我们需要对一个内存地址进行访问的时候，使用的是 【段基地址:偏移地址】，这样计算出来的地址就是内存的实际地址。但是到了保护模式，内存管理分为段式，和段页式，也就是段模式必不可少。我们先不考虑页模式。 　　对段模式来说，访问一个内存仍然用的【段基地址：偏移地址】。IA32允许将一个段的基地址设置为32bit所能表示的任何值，li"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://g.csdnimg.cn/static/logo/favicon32.ico&quot;)"></div><div data-hostname="blog.csdn.net"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://aiden-dong.gitee.io/2019/04/03/Linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%E4%B9%8B%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/">Linux 内核 教程 | 内存管理篇之内存寻址 - Aiden Blog</a><div class="info-box"><div class="text-pane"><div data-title="Linux 内核 教程 | 内存管理篇之内存寻址 - Aiden Blog"></div><div data-desc="路漫漫其修远兮，吾将上下而求索."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://aiden-dong.gitee.io/img/aiden.png&quot;)"></div><div data-hostname="aiden-dong.gitee.io"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://www.cntofu.com/book/114/index.html">Linux 内核揭密</a><div class="info-box"><div class="text-pane"><div data-title="Linux 内核揭密"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://www.cntofu.com/favicon.ico&quot;)"></div><div data-hostname="www.cntofu.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="http://kernel.pursuitofcloud.org/531037">Linux内存管理(一) · Linux kernel脉络和主干总结 · 看云</a><div class="info-box"><div class="text-pane"><div data-title="Linux内存管理(一) · Linux kernel脉络和主干总结 · 看云"></div><div data-desc="随着工作的深入，越来越觉得系统性学习内核框架、整理出脉络的必要性。个人认为，通过看书/文章学习内核，不能太沉迷于细节。因为细节和执行步骤不去写代码是难以掌握的，看过之后，也很快忘掉。太多的细节会让学习曲线更加陡峭、难见全貌。所以我试图整理出一系列的文章，根据内核的框架脉络，整理出一些“常识”性的知识点，让从事云计算领域的工程师们觉得够用，并且是能“刻在脑子里的”。"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://kernel.pursuitofcloud.org/favicon.ico&quot;)"></div><div data-hostname="kernel.pursuitofcloud.org"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://lrita.github.io/2019/03/07/linux-page-fault/">Linux Page Fault(缺页异常)</a><div class="info-box"><div class="text-pane"><div data-title="Linux Page Fault(缺页异常)"></div><div data-desc="前言此部分内容需要对linux的虚拟内存和物理内存有所了解，可以先阅读《Linux物理内存描述》、《Linux物理内存页面分配》、《Linux内存地址映射》、《Linux 内核在 x86_64 CPU 中地址映射》和《Linux Virtual Memory》。"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://lrita.github.io/favicon.ico&quot;)"></div><div data-hostname="lrita.github.io"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><hr class="wolai-block"/><h2 class="wolai-block"><span class="inline-wrap">64<span class="jill"></span>位长模式</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">进入<span class="jill"></span>64<span class="jill"></span>位的<span class="jill"></span>x64<span class="jill"></span>处理器时代后，产生了一种新的运行模式，叫<span class="jill"></span>Long Mode（intel<span class="jill"></span>手册里还把它叫做<span class="jill"></span>IA-32e Mode），传统的三种模式则被统称为<span class="jill"></span>Legacy Mode。Long Mode<span class="jill"></span>又分为<span class="jill"></span>2<span class="jill"></span>种子模式，分别是<span class="jill"></span>64<span class="jill"></span>位长模式（64-Bit Mode）和<span class="jill"></span>64<span class="jill"></span>位兼容模式（Compatibility Mode）。</span></div></div><blockquote class="wolai-block"><span class="inline-wrap">传统的三种模式：实模式、保护模型、虚拟<span class="jill"></span>8086<span class="jill"></span>模式</span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap">因为<span class="jill"></span>Long Mode<span class="jill"></span>使用<span class="jill"></span>64<span class="jill"></span>位虚拟地址，所以不管是<span class="jill"></span>64-Bit Mode<span class="jill"></span>还是<span class="jill"></span>Compatibility Mode<span class="jill"></span>的，都要求操作系统和工具链必须是<span class="jill"></span>64<span class="jill"></span>位的，其中<span class="jill"></span>64-Bit Mode<span class="jill"></span>又要求应用程序也得是<span class="jill"></span>64<span class="jill"></span>位的（纯纯的<span class="jill"></span>64<span class="jill"></span>位啊）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">因此，现存的<span class="jill"></span>32<span class="jill"></span>位应用程序可以不经重新编译就在处于<span class="jill"></span>Compatibility Mode<span class="jill"></span>的<span class="jill"></span>64<span class="jill"></span>位操作系统上运行，但要在处于<span class="jill"></span>Long Mode<span class="jill"></span>的<span class="jill"></span>64<span class="jill"></span>位操作系统上运行，就必须重新编译了。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">In long mode, x86 uses a page size of 4096 bytes and a 4 level page table that consists of:</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">the Page-Map Level-4 Table (PML4),</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">the Page-Directory Pointer Table (PDP),</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">the Page-Directory Table (PD),</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">and the Page Table (PT).</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">As I don&#39;t like these names, I will call them P4, P3, P2, and P1 from now on.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Each page table contains 512 entries and one entry is 8 bytes, so they fit exactly in one page (</span><span class="inline-wrap"><code>512*8 = 4096</code></span><span class="inline-wrap">). To translate a virtual address to a physical address the CPU</span><span class="inline-wrap"><a href="https://os.phil-opp.com/entering-longmode/#hardware_lookup"><span>1</span></a></span><span class="inline-wrap"> will do the following</span><span class="inline-wrap"><a href="https://os.phil-opp.com/entering-longmode/#virtual_physical_translation_source"><span>2</span></a></span><span class="inline-wrap">:</span></div></div><div class="wolai-block wolai-center"><figure><img src="https://os.phil-opp.com/entering-longmode/X86_Paging_64bit.svg" style="width: 701px"/></figure></div><div class="wolai-block wolai-center"><figure><img src="media/image_1.png" style="width: 760px"/></figure></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">Get the address of the P4 table from the CR3 register</span></li><li><div class="marker"></div><span class="inline-wrap">Use bits 39-47 (9 bits) as an index into P4 (</span><span class="inline-wrap"><code>2^9 = 512 = number of entries</code></span><span class="inline-wrap">)</span></li><li><div class="marker"></div><span class="inline-wrap">Use the following 9 bits as an index into P3</span></li><li><div class="marker"></div><span class="inline-wrap">Use the following 9 bits as an index into P2</span></li><li><div class="marker"></div><span class="inline-wrap">Use the following 9 bits as an index into P1</span></li><li><div class="marker"></div><span class="inline-wrap">Use the last 12 bits as page offset (</span><span class="inline-wrap"><code>2^12 = 4096 = page size</code></span><span class="inline-wrap">)</span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap">But what happens to bits 48-63 of the 64-bit virtual address? Well, they can&#39;t be used. The “64-bit” long mode is in fact just a 48-bit mode. The bits 48-63 must be copies of bit 47, so each valid virtual address is still unique. For more information see </span><span class="inline-wrap"><a href="https://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details"><span>Wikipedia</span></a></span><span class="inline-wrap">.</span></div></div><blockquote class="wolai-block"><span class="inline-wrap"><a href="https://os.phil-opp.com/entering-longmode/"><span>https://os.phil-opp.com/entering-longmode/</span></a></span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap">只要你好好理解了<span class="jill"></span>32<span class="jill"></span>位的分页模型，64<span class="jill"></span>位下的分页是不难理解的</span></div></div></article><footer></footer></body></html>
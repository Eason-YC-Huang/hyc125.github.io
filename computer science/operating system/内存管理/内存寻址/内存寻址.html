<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>内存寻址 - wolai 笔记</title><link rel="shortcut icon"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="内存寻址" class="main-title"></div></div></header><article><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">todo</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">这里只讨论如何寻址即可，知道分段是什么原理，分页是什么原理，Linux<span class="jill"></span>是怎么分段和分页的</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">先不必理解怎么从实模式进入保护模式，怎么开启分页，怎么分配段，怎么分配页，进程从启动到运行经历了什么</span></li></ul></li></ul><hr class="wolai-block"/><div class="wolai-block wolai-text"><div><span class="inline-wrap">CPU<span class="jill"></span>要从内存中读写数据，就必须要知道数据所在的内存地址。那么<span class="jill"></span>CPU<span class="jill"></span>是怎么知道要读写的内存地址呢？这个过程就叫做内存寻址。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">实模式</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">上面讲<span class="jill"></span>8086 时说到，8086 CPU 会根据<span class="jill"></span>CS<span class="jill"></span>和<span class="jill"></span>IP<span class="jill"></span>来计算指令所在的内存地址，为什么什么要这么做呢？</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">8086<span class="jill"></span>地址总线的宽度是<span class="jill"></span>20<span class="jill"></span>位，可能当时<span class="jill"></span>Intel<span class="jill"></span>认为，16<span class="jill"></span>位的地址总线（寻址能力<span class="jill"></span>64KB）是不够竞争力的，然后又因为成本问题，</span><span class="inline-wrap"><b>所以最终设计为<span class="jill"></span>20<span class="jill"></span>位</b></span><span class="inline-wrap">。但是<span class="jill"></span>16<span class="jill"></span>位的寄存器是无法完全利用<span class="jill"></span>20<span class="jill"></span>位的地址总线的。天才的设计师们想到了一个解决办法，那就是使用两个寄存器，其中一个寄存器(CS)的值左移<span class="jill"></span>4<span class="jill"></span>位（二进制），然后与另一个寄存器(IP)的值相加，那么就能完全利用<span class="jill"></span>20<span class="jill"></span>位的地址总线了。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>这就是后来被称为实模式下的寻址方式。</b></span></div></div><aside class="bg-cultured wolai-block"><div class="icon"></div><span class="inline-wrap">实模式下段的大小不是完全一样，例如当<span class="jill"></span>CS<span class="jill"></span>的值是<span class="jill"></span>FFFF<span class="jill"></span>时，IP<span class="jill"></span>就只剩下<span class="jill"></span>4<span class="jill"></span>个位可以用了，这时候段的大小是<span class="jill"></span>2^4=16Byte，当<span class="jill"></span>CS<span class="jill"></span>的值位于[0~F]000<span class="jill"></span>时，IP<span class="jill"></span>就能完全利用<span class="jill"></span>16<span class="jill"></span>位，这时候段的大小是<span class="jill"></span>2^16=64Kb</span></aside><h2 class="wolai-block"><span class="inline-wrap">保护模式</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">32<span class="jill"></span>位处理器下，通用寄存器变成了<span class="jill"></span>32<span class="jill"></span>位的，但是段寄存器仍然是<span class="jill"></span>16<span class="jill"></span>位，不过段寄存器的含义已经发生了变化，此时的它被称为段选择子。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">全局描述符</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">内存中存储着一个叫</span><span class="inline-wrap"><b>全局描述符表</b></span><span class="inline-wrap">的数据结构，里面记录了多个</span><span class="inline-wrap"><b>段描述符</b></span><span class="inline-wrap">，一个段描述符描述了一个段的特征和属性，例如段的起始位置、段的大小以及访问权限等等。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">CPU<span class="jill"></span>里有一个<span class="jill"></span>48<span class="jill"></span>位<span class="jill"></span>GDTR<span class="jill"></span>寄存器，该寄存器分成两个部分，前<span class="jill"></span>16<span class="jill"></span>位存放全局描述符表的大小（</span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="inline-wrap"> Byte = 64Kb），后<span class="jill"></span>32<span class="jill"></span>位用来存放全局描述符在内存中的起始地址。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>简单来讲，把全局描述符当做由段描述符组成的数组，然后段选择子就是用来获取特定段描述符的索引</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">一个段描述符占<span class="jill"></span>8<span class="jill"></span>字节，也就是说全局描述符表最多拥有<span class="jill"></span>8192（64Kb/8Byte）个段描述符。</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/my-gdt.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">上图是段描述符的格式，可以看出描述符中用<span class="jill"></span>32<span class="jill"></span>位记录段的起始地址，用<span class="jill"></span>20<span class="jill"></span>位记录段的大小。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">你可能会疑惑，为什么描述符中的段基地址和和段界限不是连续的？</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">那是因为要向前兼容，在<span class="jill"></span>80386<span class="jill"></span>处理器之前，有一款<span class="jill"></span>80286<span class="jill"></span>处理器，它是<span class="jill"></span>16<span class="jill"></span>位处理器，也有保护模式，地址总线是<span class="jill"></span>24<span class="jill"></span>位的，允许访问最多<span class="jill"></span>16M<span class="jill"></span>的内存，它段描述符格式见下图</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/my-80286-gdt.png" style="width: 754px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以看到，80386<span class="jill"></span>的段描述就是把<span class="jill"></span>80286<span class="jill"></span>段描述剩余的<span class="jill"></span>16<span class="jill"></span>位也利用起来</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">G<span class="jill"></span>位是粒度位（Granularity），表示段界限的单位</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">G<span class="jill"></span>位是“0”时，段界限以<span class="jill"></span>Byte<span class="jill"></span>为单位，此时段的扩展范围是[1B~1MB]</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">G<span class="jill"></span>位是“1”时，段界限以<span class="jill"></span>4KB<span class="jill"></span>为单位，此时段的扩展范围是[4KB~4GB]</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">D/B<span class="jill"></span>位（1<span class="jill"></span>位）0<span class="jill"></span>表示指令中的偏移地址或操作数是<span class="jill"></span>16<span class="jill"></span>位，1<span class="jill"></span>则对应表示<span class="jill"></span>32<span class="jill"></span>位，基本都是<span class="jill"></span>1，因为<span class="jill"></span>16<span class="jill"></span>位的保护模式非常罕见</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">L<span class="jill"></span>位 64<span class="jill"></span>位代码标记位，保留给<span class="jill"></span>64<span class="jill"></span>位处理器使用，32<span class="jill"></span>位处理器下，把此位设“0”即可</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AVL<span class="jill"></span>位 是软件可以使用的位，通常由操作系统来使用，处理器并不使用它</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">P<span class="jill"></span>位（segment present）表示该描述符所对应的段是否存在，1<span class="jill"></span>存在，0<span class="jill"></span>不存在</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">DPL（descriptor privilege level）（2<span class="jill"></span>位）表示描述符的特权级</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">共有四种处理器支持的特权级别，分别是<span class="jill"></span>0、1、2、3，0<span class="jill"></span>的级别最高，3<span class="jill"></span>的级别最低</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">S<span class="jill"></span>位用于指定描述符的类型</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">S<span class="jill"></span>为是“0”时，表示这是一个系统段</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">S<span class="jill"></span>为是“1”时，表示这是一个代码段或数据段（栈段是特殊的数据段）</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">TYPE</span></li></ul><div class="wolai-block wolai-center"><figure><img src="media/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6-type%E8%AF%B4%E6%98%8E.png" style="width: 760px"/></figure></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">X：执行位：0：不可执行，1：可执行</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">E：扩展位：0：段向上扩展，1：段向下扩展</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">W：写位：0：段是不允许写入的，1：段实可以写入的</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">A：已访问位：指示该描述符指向的段最近是否被访问过，每当该段被访问时，处理器自动将其置为“1”，该位的清零由软件（操作系统）负责，通过定期监视该位的状态，就可以统计出该段的使用频率</span></li></ul><h3 class="wolai-block"><span class="inline-wrap">局部段描述符</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">保护模式下程序</span><span class="inline-wrap">加载</span><span class="inline-wrap">的过程</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Linux<span class="jill"></span>中进程的理论最大数计算</b></span><span class="inline-wrap">
每个进程的局部段描述表<span class="jill"></span>LDT<span class="jill"></span>都作为一个独立的段而存在，在全局段描述表<span class="jill"></span>GDT<span class="jill"></span>中要有一个表项指向这个段的起始地址，并说明该段的长度以及其他一些 参数。除上之外，每个进程还有一个<span class="jill"></span>TSS<span class="jill"></span>结构。所以，每个进程都要在全局段描述表<span class="jill"></span>GDT<span class="jill"></span>中占据两个表项。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">除一些系统的开销(例如<span class="jill"></span>GDT<span class="jill"></span>中的第<span class="jill"></span>2<span class="jill"></span>项和第<span class="jill"></span>3<span class="jill"></span>项分别用于内核 的代码段和数据段，第<span class="jill"></span>4<span class="jill"></span>项和第<span class="jill"></span>5<span class="jill"></span>项永远用于当前进程的代码段和数据段，第<span class="jill"></span>1<span class="jill"></span>项永远是<span class="jill"></span>0，等等)以外，尚有<span class="jill"></span>8180<span class="jill"></span>个表项可供使用，所以理论上系统中最大的进程数是<span class="jill"></span>8180/2=4090。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">分页</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">前面讲到段描述符有个标志位“A”，操作系统通过记录该位的变化情况，可以得知该描述符对应段的使用频率，当内存不足时，可以把不频繁使用的段换出到磁盘上，从而空出内存给别的程序使用</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">但是因为段的长度不定，在分配内存时，可能会发生内存中的空闲区域小于要加载的段，或者空闲区域远远大于要加载的段，为了更好的管理和利用内存，从<span class="jill"></span>80386<span class="jill"></span>处理器开始，引入了分页机制</span></div></div><h3 class="wolai-block"><span class="inline-wrap">页目录、页表、页</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">分页机制把<span class="jill"></span>4G<span class="jill"></span>内存分成大小相同的页，页的最小单位是<span class="jill"></span>4KB（4096<span class="jill"></span>字节），4G<span class="jill"></span>内存一共可分为<span class="jill"></span>4G/4KB=</span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>÷</mo><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}÷2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="inline-wrap">=</span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="inline-wrap">=1048576=0x100000<span class="jill"></span>个页</span></div><div class="wolai-block wolai-center"><figure><img src="media/%E5%88%86%E9%A1%B5-%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png" style="width: 273px"/></figure></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在处理器内部，有一个控制寄存器<span class="jill"></span>CR3，用于存放当前任务的</span><span class="inline-wrap"><b>页目录</b></span><span class="inline-wrap">的物理地址</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>页目录</b></span><span class="inline-wrap">可以看作是一个数组，大小是<span class="jill"></span>4KB，用来存放</span><span class="inline-wrap"><b>页表</b></span><span class="inline-wrap">的物理地址(4Byte)，也就是一共有<span class="jill"></span>1024<span class="jill"></span>个页表的物理地址</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>页表</b></span><span class="inline-wrap">也可以看作是一个数组，大小是<span class="jill"></span>4KB，用来存放</span><span class="inline-wrap"><b>页</b></span><span class="inline-wrap">的物理地址(4Byte)，也就是一共有<span class="jill"></span>1024<span class="jill"></span>个页的物理地址</span></div></div><blockquote class="wolai-block"><span class="inline-wrap">一个页目录记录了<span class="jill"></span>1024<span class="jill"></span>个页表的物理地址，一个页表记录了<span class="jill"></span>1024<span class="jill"></span>个页的物理地址，也就是它们一共记录了</span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="inline-wrap">个页的地址</span></blockquote><h3 class="wolai-block"><span class="inline-wrap">分页机制下的寻址</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">分页机制下，处理器段部件输出的<span class="jill"></span>32<span class="jill"></span>位<span class="jill"></span>0<span class="jill"></span>和<span class="jill"></span>1<span class="jill"></span>被分成了<span class="jill"></span>3<span class="jill"></span>部分</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">高<span class="jill"></span>10<span class="jill"></span>位：页目录的索引</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">中<span class="jill"></span>10<span class="jill"></span>位：页表的索引</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">低<span class="jill"></span>12<span class="jill"></span>位：页内偏移量</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">举个例子</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6-%E5%AF%BB%E5%9D%80%E4%BE%8B%E5%AD%90.png" style="width: 760px"/></figure></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="PowerShell" class="marker"></div><pre>假设CR3寄存器中的内容是`0x00005000`，段部件输出`0x00801050`
0x00801050 = 00_0000_0010 00_0000_0001 0000_0101_0000
<span class="token comment"># 高10位=00_0000_0010=0x2,它是页目录表内的索引</span>
<span class="token comment"># 处理器将它乘以4（因为每个目录项为4字节）= 0x8，作为偏移量访问页目录</span>
<span class="token comment"># 处理器访问0x00005000+0x8，得到页表的物理地址是0x08001000</span>

<span class="token comment"># 中10位=00_0000_0001=0x1,它是页表的索引</span>
<span class="token comment"># 同理，处理器访问0x08001000+0x4，得到页的物理地址是0x08001004</span>

<span class="token comment"># 低12位=0000_0101_0000=0x50，它是页内偏移量</span>
<span class="token comment"># 0x08001004+0x50得到的就是目标物理地址</span></pre></div></code-block><aside class="bg-cultured wolai-block"><div class="icon"></div><span class="inline-wrap">为什么能这么巧，段部件输出的地址为什么能刚好分页</span></aside><div class="wolai-block wolai-text"><div><span class="inline-wrap">当程序加载时，操作系统首先会在虚拟内存中分配段。然后根据段的大小，计算出需要多少页，根据段的首地址和末地址计算出页目录和页表的的位置，然后把页的地址写入到对应的页表位置。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">例如，现在有个段</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">首地址是 </span><span class="inline-wrap"><code>0b0000000001_0000000001_000000000000</code></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">末地址是 </span><span class="inline-wrap"><code>0b0000000001_0000000003_111111111111</code></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以看出</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">它的段大小是 </span><span class="inline-wrap"><code>0b0000000000_0000000002_111111111111</code></span><span class="inline-wrap">，需要三页</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">它需要用到页目录索引为<span class="jill"></span>1<span class="jill"></span>的那一项，需要用到页表索引为<span class="jill"></span>1，2，3<span class="jill"></span>的那一项</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">把操作系统分配的三页的物理地址，写到上面寻址到的页表里</span></div></div><aside class="bg-cultured wolai-block"><div data-symbol="💥" class="icon"></div><span class="inline-wrap">操作系统根据段基址和段大小，算出所需的页数量、页目录的索引、页表的索引，把页的物理地址写到对应的位置</span></aside><h3 class="wolai-block"><span class="inline-wrap">页目录项和页表的组成</span></h3><div class="wolai-block wolai-center"><figure><img src="media/image.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以看出，页目录项和页表项结构其实是差不多的，除了第七位有点区别</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">P(Present) 存在位，1<span class="jill"></span>表示页表或页存位于内存中，否则表示页表或页不存在于内存中，必须先创建，或者从磁盘调入内存后才可使用</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"></span><br/></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">分页模式下程序</span><span class="inline-wrap">加载</span><span class="inline-wrap">的过程</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">长模式</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">进入<span class="jill"></span>64<span class="jill"></span>位的<span class="jill"></span>x64<span class="jill"></span>处理器时代后，产生了一种新的运行模式，叫<span class="jill"></span>Long Mode（intel<span class="jill"></span>手册里还把它叫做<span class="jill"></span>IA-32e Mode），传统的三种模式则被统称为<span class="jill"></span>Legacy Mode。Long Mode<span class="jill"></span>又分为<span class="jill"></span>2<span class="jill"></span>种子模式，分别是<span class="jill"></span>64<span class="jill"></span>位长模式（64-Bit Mode）和<span class="jill"></span>64<span class="jill"></span>位兼容模式（Compatibility Mode）。</span></div></div><blockquote class="wolai-block"><span class="inline-wrap">传统的三种模式：实模式、保护模型、虚拟<span class="jill"></span>8086<span class="jill"></span>模式</span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap">因为<span class="jill"></span>Long Mode<span class="jill"></span>使用<span class="jill"></span>64<span class="jill"></span>位虚拟地址，所以不管是<span class="jill"></span>64-Bit Mode<span class="jill"></span>还是<span class="jill"></span>Compatibility Mode<span class="jill"></span>的，都要求操作系统和工具链必须是<span class="jill"></span>64<span class="jill"></span>位的，其中<span class="jill"></span>64-Bit Mode<span class="jill"></span>又要求应用程序也得是<span class="jill"></span>64<span class="jill"></span>位的（纯纯的<span class="jill"></span>64<span class="jill"></span>位啊）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">因此，现存的<span class="jill"></span>32<span class="jill"></span>位应用程序可以不经重新编译就在处于<span class="jill"></span>Compatibility Mode<span class="jill"></span>的<span class="jill"></span>64<span class="jill"></span>位操作系统上运行，但要在处于<span class="jill"></span>Long Mode<span class="jill"></span>的<span class="jill"></span>64<span class="jill"></span>位操作系统上运行，就必须重新编译了。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">In long mode, x86 uses a page size of 4096 bytes and a 4 level page table that consists of:</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">the Page-Map Level-4 Table (PML4),</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">the Page-Directory Pointer Table (PDP),</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">the Page-Directory Table (PD),</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">and the Page Table (PT).</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">As I don&#39;t like these names, I will call them P4, P3, P2, and P1 from now on.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Each page table contains 512 entries and one entry is 8 bytes, so they fit exactly in one page (</span><span class="inline-wrap"><code>512*8 = 4096</code></span><span class="inline-wrap">). To translate a virtual address to a physical address the CPU</span><span class="inline-wrap"><a href="https://os.phil-opp.com/entering-longmode/#hardware_lookup"><span>1</span></a></span><span class="inline-wrap"> will do the following</span><span class="inline-wrap"><a href="https://os.phil-opp.com/entering-longmode/#virtual_physical_translation_source"><span>2</span></a></span><span class="inline-wrap">:</span></div></div><div class="wolai-block wolai-center"><figure><img src="https://os.phil-opp.com/entering-longmode/X86_Paging_64bit.svg" style="width: 701px"/></figure></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">Get the address of the P4 table from the CR3 register</span></li><li><div class="marker"></div><span class="inline-wrap">Use bits 39-47 (9 bits) as an index into P4 (</span><span class="inline-wrap"><code>2^9 = 512 = number of entries</code></span><span class="inline-wrap">)</span></li><li><div class="marker"></div><span class="inline-wrap">Use the following 9 bits as an index into P3</span></li><li><div class="marker"></div><span class="inline-wrap">Use the following 9 bits as an index into P2</span></li><li><div class="marker"></div><span class="inline-wrap">Use the following 9 bits as an index into P1</span></li><li><div class="marker"></div><span class="inline-wrap">Use the last 12 bits as page offset (</span><span class="inline-wrap"><code>2^12 = 4096 = page size</code></span><span class="inline-wrap">)</span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap">But what happens to bits 48-63 of the 64-bit virtual address? Well, they can&#39;t be used. The “64-bit” long mode is in fact just a 48-bit mode. The bits 48-63 must be copies of bit 47, so each valid virtual address is still unique. For more information see </span><span class="inline-wrap"><a href="https://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details"><span>Wikipedia</span></a></span><span class="inline-wrap">.</span></div></div><blockquote class="wolai-block"><span class="inline-wrap"><a href="https://os.phil-opp.com/entering-longmode/"><span>https://os.phil-opp.com/entering-longmode/</span></a></span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap">只要你好好理解了<span class="jill"></span>32<span class="jill"></span>位的分页模型，64<span class="jill"></span>位下的分页是不难理解的</span></div></div><h2 class="wolai-block"><span class="inline-wrap">Linux<span class="jill"></span>的分段与分页</span></h2><div class="wolai-bookmark wolai-block"><a href="https://zhuanlan.zhihu.com/p/327860921">x86的分页机制和Linux实现</a><div class="info-box"><div class="text-pane"><div data-title="x86的分页机制和Linux实现"></div><div data-desc="前言上一篇《 x86段寄存器和分段机制》了解了x86分段机制原理，以及CPU寻址的整个过程。本片补上寻址的最后一棒：分页机制，并结合linux内核了解下OS中的分页机制实现。为何需要分页机制80x86的两种工作模式：8038…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.a53ae37b.png&quot;)"></div><div data-hostname="zhuanlan.zhihu.com"></div></div></div><div class="preview-pane" style="background-image: url(https://pic1.zhimg.com/v2-14b1f2aa447f3112dc4b4169c8e5a783_720w.jpg?source=172ae18b)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://0xax.gitbooks.io/linux-insides/content/Theory/linux-theory-1.html">Paging · Linux Inside</a><div class="info-box"><div class="text-pane"><div data-title="Paging · Linux Inside"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://0xax.gitbooks.io/linux-insides/content/gitbook/images/apple-touch-icon-precomposed-152.png&quot;)"></div><div data-hostname="0xax.gitbooks.io"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Linux<span class="jill"></span>内容管理</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">分页分段模型</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">创建任务、任务切换要做哪些工作</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></article><footer></footer></body></html>
<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>物理内存管理 - wolai 笔记</title><link rel="shortcut icon"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="物理内存管理" class="main-title"></div></div></header><article><div class="wolai-block wolai-text"><div><span class="inline-wrap">为了同时兼容<span class="jill"></span>UMA<span class="jill"></span>和<span class="jill"></span>NUMA<span class="jill"></span>架构的处理器，Linux<span class="jill"></span>对物理内存的组织管理如下图</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/image.png" style="width: 760px"/></figure></div><h2 class="wolai-block"><span class="inline-wrap">内存节点描述符</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>pg_data</code></span><span class="inline-wrap">代表一个内存节点，在<span class="jill"></span>NUMA<span class="jill"></span>存储结构下可能会有存在多个<span class="jill"></span>pg_data<span class="jill"></span>结构。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">// 节点描述符重要字段解析</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">内存管理区</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">在一个理想的计算机体系结构中，一个页框就是一个内存存储单元，可用于任何事情：存储内核数据和用户数据、缓存磁盘数据等等。任何种类的数据也都可以存放在任何页框中，没有什么限制。</span></div></div><aside class="bg-cultured wolai-block"><div data-symbol="❗" class="icon"></div><span class="inline-wrap">虚拟内存划分得到的是页(page)，物理内存划分得到的是页框(page frame)</span></aside><aside class="bg-cultured wolai-block"><div data-symbol="❗" class="icon"></div><span class="inline-wrap">frame : a structure supporting or containing something</span></aside><div class="wolai-block wolai-text"><div><span class="inline-wrap">但是，实际的计算机体系结构有硬件的制约，这限制了页框可以使用的方式。尤其是<span class="jill"></span>Linux<span class="jill"></span>内核必须处理<span class="jill"></span>80x86<span class="jill"></span>体系结构的两种硬件约束:</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ISA<span class="jill"></span>总线的直接内存存取(DMA)处理器有一个严格的限制：它们只能对<span class="jill"></span>RAM<span class="jill"></span>的前<span class="jill"></span>16MB<span class="jill"></span>寻址。具体看</span><span class="inline-wrap"><a href="https://www.wolai.com/eckFN49d1ToxPTj5hUoabB#eckFN49d1ToxPTj5hUoabB" class="wolai-bi-link"><span class="embed-page">直接内存访问</span></a></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在具有大容量<span class="jill"></span>RAM<span class="jill"></span>的现代<span class="jill"></span>32<span class="jill"></span>位计算机中，CPU<span class="jill"></span>不能直接访问所有的物理内存，因为线性地址空间太小。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">为了应对这两种限制，Linux2.6<span class="jill"></span>把每个内存节点的物理内存划分为<span class="jill"></span>3<span class="jill"></span>个管理区(zone)。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>80x86 UMA<span class="jill"></span>体系结构中的管理区为：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>ZONE_DMA</code></span><span class="inline-wrap">：[</span><span class="inline-wrap">0,16</span><span class="inline-wrap">]MB<span class="jill"></span>的内存页框</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>ZONE_NORMAL</code></span><span class="inline-wrap">：(16,896)MB<span class="jill"></span>的内存页框</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>ZONE_HIGHMEM</code></span><span class="inline-wrap">：[896,]MB<span class="jill"></span>的内存页框</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>ZONE_DMA</code></span><span class="inline-wrap">包含低于<span class="jill"></span>16MB<span class="jill"></span>的内存页框，这些页框可以由老式的基于<span class="jill"></span>ISA<span class="jill"></span>的设备通过<span class="jill"></span>DMA<span class="jill"></span>使用。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>ZONE_DMA</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>ZONE_NORMAL</code></span><span class="inline-wrap">区包含内存的“常规”页框，通过把他们线性地映射到线性地址空间的第<span class="jill"></span>4<span class="jill"></span>个<span class="jill"></span>GB，内核就可以直接进行访问。相反，</span><span class="inline-wrap"><code>ZONE_HIGHMEM</code></span><span class="inline-wrap">区包含的内存页不能由内核直接访问，尽管它们也线性地映射到了线性地址空间的第<span class="jill"></span>4<span class="jill"></span>个<span class="jill"></span>GB。在<span class="jill"></span>64<span class="jill"></span>位体系结构上的</span><span class="inline-wrap"><code>ZONE_HIGHMEM</code></span><span class="inline-wrap">区总是空的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">每个内存管理区都有自己的描述符 // todo 管理区描述符的字段</span></div></div><h2 class="wolai-block"><span class="inline-wrap">保留的页框池</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以使用两种不同的方式来满足内存分配请求。如果有足够的空闲内存可用，请求就会被立刻满足，否则，必须回收一些内存，并且将发出请求的内核控制路径阻塞，直到有内存被释放。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">但是有一些内核控制路径不能被阻塞，例如在处理中断或者在执行临界区内的代码时。在这些情况下，内核控制路径应当产生原子内存分配请求。原子请求不会被阻塞，如果没有的空闲页，仅仅是分配失败而已。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">为了尽可能减少原子内存分配请求的失败，内核保留了一个页框池，只有在内存不足时才使用。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">连续页框管理</span></h2><h3 class="wolai-block"><span class="inline-wrap">分区页框分配器</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">分区页框分配器(zoned page frame allocator)负责处理连续页框的内存分配请求。它的主要组成如下图</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">// todo</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">其中，名为“管理区分配器”部分接受动态内存分配与释放的请求。在请求分配的情况下，该部分搜索一个能满足所请求的一组连续页框内存的管理区。在每个管理区内，页框被名为“伙伴系统”的部分来处理。为了达到更好的系统性能，一小部分页框保留在高速缓存中，用于快速满足对单个页框的分配请求。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">伙伴系统算法</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">内核应该为分配一组连续的页框而建立一种健壮、高效的分配策略。为此，必须解决著名的内存管理问题，也就是所谓的外碎片。频繁地请求和释放不同大小的一组连续页框，必然导致在已分配页框的块内分散了许多小块的空闲页框。由此带来的问题是，就算有足够多的空闲页框可以满足请求，但是要分配一个大块的连续页框就可能无法满足。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">从本质上说，避免外碎片化的方法有两种：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">利用分页单元，把一组非连续的空闲页框映射到连续的线性地址区间</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">开发一种适当的技术来记录现存的空闲连续页框块的情况，以尽量避免为满足对小块的请求而分割大的空闲块</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">基于以下三种原因，内核首选第二种方法：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在某些情况下，连续的页框确实是必要的，因为连续的线性地址不足以满足请求。一个典型的例子就是给<span class="jill"></span>DMA<span class="jill"></span>处理器分配缓冲区的内存请求。因为当在一次单独的<span class="jill"></span>I/O<span class="jill"></span>操作中传送几个磁盘扇区的数据时，DMA<span class="jill"></span>忽略分页单元而直接访问地址总线，因此，所请求的缓冲区就必须位于连续的页框中。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">即使连续页框的分配并不是很必要，但它在保持内核页表不变方面所起的作用也是不容忽视的。频繁地修改页表势必导致平均访问内存次数的增加，因为这会使<span class="jill"></span>CPU<span class="jill"></span>频繁地刷新</span><span class="inline-wrap"><code>转换后援缓冲器(TLB)</code></span><span class="inline-wrap">的内容。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">内核通过<span class="jill"></span>4MB<span class="jill"></span>的页可以访问大块连续的物理内存。这样减少了<span class="jill"></span>TLB<span class="jill"></span>的失效率，因为提高了访问内存的平均速度。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">Linux<span class="jill"></span>采用注明的伙伴系统算法来解决外碎片问题。把所有的空闲页框分组为<span class="jill"></span>11<span class="jill"></span>个块链表，每个块链表分别包含大小为<span class="jill"></span>1，2，4，8，16，32，64，128，256，512，1024<span class="jill"></span>个连续页框。对<span class="jill"></span>1024<span class="jill"></span>个页框的最大请求对应着<span class="jill"></span>4MB<span class="jill"></span>大小的连续<span class="jill"></span>RAM<span class="jill"></span>块。每个块的第一个页框的物理地址是该块大小的整数倍。例如，大小为<span class="jill"></span>16<span class="jill"></span>个页框的块，其起始地址是</span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mo>∗</mo><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">16*2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="inline-wrap">的倍数  (</span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="inline-wrap">= 4096，这是一个常规页的大小)。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">举个列子，假设要请求一个<span class="jill"></span>256<span class="jill"></span>个页框的块（即<span class="jill"></span>1MB）。算法先在<span class="jill"></span>256<span class="jill"></span>个页框的链表中检查是否有一个空闲块。如果没有这样的块，算法会查找下一个更大的块，也就是在<span class="jill"></span>512<span class="jill"></span>个页框的链表中找一个空闲块。如果存在这样的块，内核就把<span class="jill"></span>256<span class="jill"></span>的页框分成两等份，一半用作满足请求，另一半插入到<span class="jill"></span>256<span class="jill"></span>个页框的链表中。如果在<span class="jill"></span>512<span class="jill"></span>个页框的块链表中也没有找到空闲块，就继续找更大的块 — 1024<span class="jill"></span>个页框的块。如果这样的块存在，内核把<span class="jill"></span>1024<span class="jill"></span>个页框块的<span class="jill"></span>256<span class="jill"></span>个页框用作请求，然后从剩余的<span class="jill"></span>768<span class="jill"></span>个页框中拿<span class="jill"></span>512<span class="jill"></span>个插入到<span class="jill"></span>512<span class="jill"></span>页框的链表中，再把最后的<span class="jill"></span>256<span class="jill"></span>个插入到<span class="jill"></span>256<span class="jill"></span>个页框的链表中。如果<span class="jill"></span>1024<span class="jill"></span>个页框的链表还是空的，算法就放弃并发出出错信号。</span></div></div><aside class="bg-cultured wolai-block"><div data-symbol="💥" class="icon"></div><span class="inline-wrap">Linux2.6<span class="jill"></span>为每个管理区使用不同的伙伴系统</span></aside><h3 class="wolai-block"><span class="inline-wrap">每<span class="jill"></span>CPU<span class="jill"></span>页框高速缓存</span></h3><h3 class="wolai-block"><span class="inline-wrap">管理区分配器</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">管理区分配器是内核页框分配器的前端。该构件必须分配一个包含足够多的空闲页框的内存区，使它能满足内存请求。管理区分配器必须满足几个目标：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">它应当保护保留的页框池（</span><span><a href="https://www.wolai.com/rr1njyG7Dadupb1VUBQaa#ivGtKSftnLpf1Q7H9oCFmx" class="wolai-bi-link"><span><span class="embed-jiu embed-h2"></span><span class="inline-wrap">保留的页框池</span></span></a></span><span class="inline-wrap">）</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">当内存不足且允许阻塞当前进程时，它应当触发页框回收算法；一旦某些页框被释放，管理区分配器将再次尝试为进程分配内存</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">尽可能保存小而珍贵的<span class="jill"></span>ZONE_DMA<span class="jill"></span>内存管理区</span></li></ul><h2 class="wolai-block"><span class="inline-wrap">slab<span class="jill"></span>分配器</span></h2><div class="wolai-bookmark wolai-block"><a href="https://zhuanlan.zhihu.com/p/382056680">Slub分配器原理</a><div class="info-box"><div class="text-pane"><div data-title="Slub分配器原理"></div><div data-desc="目录slab分配器设计的需求slab、slob和slub关系slab层在内存管理子系统的层次slub分配器框架slub的重要数据结构slub的分配过程创建slab缓存(kmem_cache)的函数分析分配对象(object)的函数分析slub的frozen（冻结）…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.a53ae37b.png&quot;)"></div><div data-hostname="zhuanlan.zhihu.com"></div></div></div><div class="preview-pane" style="background-image: url(https://pic2.zhimg.com/v2-3736a77133cff278a8a6afd8b7f95c43_r.jpg?source=172ae18b)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://www.dingmos.com/2021/03/22/54.html">Linux 内核 | 内存管理——slab 分配器 - 一丁点儿的网络日志</a><div class="info-box"><div class="text-pane"><div data-title="Linux 内核 | 内存管理——slab 分配器 - 一丁点儿的网络日志"></div><div data-desc="简介在Linux中，伙伴分配器（buddy allocator）是以页为单位管理和分配内存。但在内核中的需求却以字节为单位（在内核中面临频繁的结构体内存分配问题）。假如我们需要动态申请一个内核结..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://www.dingmos.com/usr/themes/Akina/images/favicon.ico&quot;)"></div><div data-hostname="www.dingmos.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://zhuanlan.zhihu.com/p/419114600">深入理解Linux slab分配器</a><div class="info-box"><div class="text-pane"><div data-title="深入理解Linux slab分配器"></div><div data-desc="在Linux中，伙伴系统是以页为单位分配内存。但是现实中很多时候却以字节为单位，不然申请10Bytes内存还要给1页的话就太浪费了。slab分配器就是为小内存分配而生的。slab分配器分配内存以Byte为单位。但是slab分配…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.a53ae37b.png&quot;)"></div><div data-hostname="zhuanlan.zhihu.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://zhuanlan.zhihu.com/p/105582468">内存分配[四] - Linux中的Slab(1)</a><div class="info-box"><div class="text-pane"><div data-title="内存分配[四] - Linux中的Slab(1)"></div><div data-desc="Linux中的buddy分配器是以page frame为最小粒度的，而现实的应用多是以内核objects（比如描述文件的&amp;#34;struct inode&amp;#34;）的大小来申请和释放内存的，这些内核objects的大小通常从几十字节到几百字节不等，远远…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.a53ae37b.png&quot;)"></div><div data-hostname="zhuanlan.zhihu.com"></div></div></div><div class="preview-pane" style="background-image: url(https://pic3.zhimg.com/v2-4d6f53b94bbd3936aff61f6987bbf0b0_720w.jpg?source=172ae18b)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://www.bilibili.com/video/BV1rp4y1z7oh/">C/C++Linux服务器丨slab机制的原理 丨协程机制与io多路复用丨grpc与微服务的认知 丨 协程栈与汇编切换实现_哔哩哔哩_bilibili</a><div class="info-box"><div class="text-pane"><div data-title="C/C++Linux服务器丨slab机制的原理 丨协程机制与io多路复用丨grpc与微服务的认知 丨 协程栈与汇编切换实现_哔哩哔哩_bilibili"></div><div data-desc="https://ke.qq.com/course/417774?flowToken=1017067(先关注，不迷路)内容包括C/C++，Linux，Nginx，ZeroMQ，MySQL，Redis，fastdfs，MongoDB，ZK，流媒体，CDN，P2P，K8S，Docker，TCP/IP，协程，DPDK等等多个知识点高级进阶干货学"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://i0.hdslb.com/bfs/archive/9f244bdad8be2d89509f25b6916b408d05d0e78d.jpg@57w_57h_1c.png&quot;)"></div><div data-hostname="www.bilibili.com"></div></div></div><div class="preview-pane" style="background-image: url(http://i0.hdslb.com/bfs/archive/9f244bdad8be2d89509f25b6916b408d05d0e78d.jpg)"></div></div></div><div class="wolai-block wolai-text"><div></div></div><h2 class="wolai-block"><span class="inline-wrap">非连续页框管理</span></h2><div class="wolai-bookmark wolai-block"><a href="https://www.zhihu.com/question/391044480/answer/1187521267?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=560497139592011776&amp;utm_content=group3_Answer&amp;utm_campaign=shareopn">为什么linux需要物理内存分配器？ - 知乎</a><div class="info-box"><div class="text-pane"><div data-title="为什么linux需要物理内存分配器？ - 知乎"></div><div data-desc="因为内核本身也有内存分配需求，这与是什么操作系统无关，与是Linux还是Windows NT还是FreeBSD无关。内核…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.a53ae37b.png&quot;)"></div><div data-hostname="www.zhihu.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://students.mimuw.edu.pl/ZSO/Wyklady/06_memory2/BuddySlabAllocator.pdf">https://students.mimuw.edu.pl/ZSO/Wyklady/06_memory2/BuddySlabAllocator.pdf</a><div class="info-box"><div class="text-pane"><div data-title="students.mimuw.edu.pl"></div><div class="icon-host"><div data-hostname="students.mimuw.edu.pl"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://hammertux.github.io/slab-allocator">The Slab Allocator in the Linux kernel</a><div class="info-box"><div class="text-pane"><div data-title="The Slab Allocator in the Linux kernel"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://hammertux.github.io/favicon.ico&quot;)"></div><div data-hostname="hammertux.github.io"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://www.kernel.org/doc/gorman/html/understand/understand011.html">Slab Allocator</a><div class="info-box"><div class="text-pane"><div data-title="Slab Allocator"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://www.kernel.org/favicon.ico&quot;)"></div><div data-hostname="www.kernel.org"></div></div></div><div class="preview-pane"></div></div></div></article><footer></footer></body></html>
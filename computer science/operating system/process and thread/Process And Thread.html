<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/wolai.css"/><title>Process And Thread - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div data-symbol="🏐" class="icon"></div></div><div data-title="Process And Thread" class="main-title"></div></div></header><article><div class="wolai-block wolai-text"><div><span class="inline-wrap">人们想让计算机可以运行多个程序，因此有了进程</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">人们想让程序可以同时做多件事情，因此有了线程</span></div></div><h2 class="wolai-block"><span class="inline-wrap">进程与线程</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">运行中的程序叫作进程，进程可以看做是线程和资源的集合</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>更多关于进程和线程的文章</b></span></div></div><div class="wolai-bookmark wolai-block"><a href="https://stackoverflow.com/questions/28476456/threads-and-lwp-in-linux">https://stackoverflow.com/questions/28476456/threads-and-lwp-in-linux</a><div class="info-box"><div class="text-pane"><div data-title="stackoverflow.com"></div><div class="icon-host"><div data-hostname="stackoverflow.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://en.wikipedia.org/wiki/Light-weight_process">https://en.wikipedia.org/wiki/Light-weight_process</a><div class="info-box"><div class="text-pane"><div data-title="en.wikipedia.org"></div><div class="icon-host"><div data-hostname="en.wikipedia.org"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://en.wikipedia.org/wiki/LinuxThreads">https://en.wikipedia.org/wiki/LinuxThreads</a><div class="info-box"><div class="text-pane"><div data-title="en.wikipedia.org"></div><div class="icon-host"><div data-hostname="en.wikipedia.org"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library">https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library</a><div class="info-box"><div class="text-pane"><div data-title="en.wikipedia.org"></div><div class="icon-host"><div data-hostname="en.wikipedia.org"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://en.wikipedia.org/wiki/POSIX_Threads">https://en.wikipedia.org/wiki/POSIX_Threads</a><div class="info-box"><div class="text-pane"><div data-title="en.wikipedia.org"></div><div class="icon-host"><div data-hostname="en.wikipedia.org"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://titanwolf.org/Network/Articles/Article?AID=af2941db-ebcc-4ccb-9301-ab03bf33b1a1#gsc.tab=0">The three thread concepts of kernel thread, lightweight process, and user thread are used to solve the confusion (thread ≠ lightweight process)(Others-Community)</a><div class="info-box"><div class="text-pane"><div data-title="The three thread concepts of kernel thread, lightweight process, and user thread are used to solve the confusion (thread ≠ lightweight process)(Others-Community)"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://titanwolf.org/favicon.ico&quot;)"></div><div data-hostname="titanwolf.org"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="http://www.cs.umsl.edu/~sanjiv/cs476/lectures/thread.pdf">http://www.cs.umsl.edu/~sanjiv/cs476/lectures/thread.pdf</a><div class="info-box"><div class="text-pane"><div data-title="www.cs.umsl.edu"></div><div class="icon-host"><div data-hostname="www.cs.umsl.edu"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">进程控制块</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">PCB(</span><span class="inline-wrap">进程控制块</span><span class="inline-wrap">)：存放操作系统用于控制进程所需的信息</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">例如，进程的状态、程序计数器、栈指针、打开的文件、调度算法 等等。</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/image.png" style="width: 332px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">*   </span><span class="inline-wrap"><b>Pointer –</b></span><span class="inline-wrap"> It is a stack pointer which is required to be saved when the process is switched from one state to another to retain the current position of the process.
*   </span><span class="inline-wrap"><b>Process state –</b></span><span class="inline-wrap"> It stores the respective state of the process.
*   </span><span class="inline-wrap"><b>Process number –</b></span><span class="inline-wrap"> Every process is assigned with a unique id known as process ID or PID which stores the process identifier.
*   </span><span class="inline-wrap"><b>Program counter –</b></span><span class="inline-wrap"> It stores the counter which contains the address of the next instruction that is to be executed for the process.
*   </span><span class="inline-wrap"><b>Register –</b></span><span class="inline-wrap"> These are the CPU registers which includes: accumulator, base, registers and general purpose registers.
*   </span><span class="inline-wrap"><b>Memory limits –</b></span><span class="inline-wrap"> This field contains the information about memory management system used by operating system. This may include the page tables, segment tables etc.
*   </span><span class="inline-wrap"><b>Open files list –</b></span><span class="inline-wrap"> This information includes the list of files opened for a process.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">*   </span><span class="inline-wrap"><b>Miscellaneous accounting and status data –</b></span><span class="inline-wrap"> This field includes information about the amount of CPU used, time constraints, jobs or process number, etc.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">进程表：由多个<span class="jill"></span>PCB<span class="jill"></span>组成的<span class="jill"></span>PCB<span class="jill"></span>数组</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Linux<span class="jill"></span>的<span class="jill"></span>PCB<span class="jill"></span>是</span><span class="inline-wrap"><code>task_struct</code></span></div></div><h2 class="wolai-block"><span class="inline-wrap">Linux<span class="jill"></span>进程状态模型</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">每一个进程拥有自己的状态，在进程的执行期间进程的状态会发生改变。一些进程的状态如下：  </span></div></div><div class="wolai-block wolai-center"><figure><img src="https://pic3.zhimg.com/80/v2-cd72925671408a954e9f625180e55cc6_1440w.jpg" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>TASK_RUNNING </b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在此状态下，表示进程正在<span class="jill"></span>CPU<span class="jill"></span>中运行或在队列中等待运行（运行队列）</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>TASK_INTERRUPTIBLE</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在此状态下，进程被暂停并等待一个某些条件状态的到达。如果一个进程处于<span class="jill"></span>TASK_INTERRUPTIBLE<span class="jill"></span>状态并接收到一个停止的信号，进程的状态将会被改变并中断操作。一个典型的<span class="jill"></span>TASK_INTERRUPTIBLE<span class="jill"></span>状态的进程的例子是一个进程等待键盘中断</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>TASK_UNINTERRUPTIBLE</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">与<span class="jill"></span>TASK_INTERRUPTIBLE<span class="jill"></span>相似。当一个进程处于<span class="jill"></span>TASK_UNINTERRUPTIBLE<span class="jill"></span>状态可以被中断，向处于<span class="jill"></span>TASK_UNINTERRUPTIBLE<span class="jill"></span>状态的进程发送一个信号不会发生任何操作。一个<span class="jill"></span>TASK_UNINTERRUPTIBLE<span class="jill"></span>进程的典型的例子是等待磁盘<span class="jill"></span>I/O<span class="jill"></span>操作</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>TASK_STOPPED</b></span><span class="inline-wrap"> </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在此状态下的进程被某些信号（如<span class="jill"></span>SIGINT，SIGSTOP）暂停。进程正在等待通过一个信号恢复运行，例如<span class="jill"></span>SIGCONT</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>TASK_TRACED</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">正被调试程序等其他进程监控时，进程将进入这种状态。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>EXIT_ZOMBIE</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">当一个进程调用</span><span class="inline-wrap"><code>exit()</code></span><span class="inline-wrap">或收到信号而终止时，它会释放它持有的所有资源，然后发送一个</span><span class="inline-wrap"><code>SIGCHLD</code></span><span class="inline-wrap">信号给它的父进程，由它的父进程负责把该进程从进程表中移除。从发出信号到被移出进程表，该进程处于<span class="jill"></span>TASK_ZOMBIE<span class="jill"></span>状态。</span></div></div><aside class="bg-cultured wolai-block"><div data-symbol="🔥" class="icon"></div><span class="inline-wrap">使用<span class="jill"></span>kill<span class="jill"></span>命令来关闭这样的一个进程是不可能的，因为该进程已经被认为已经死掉了。如果你不能清除僵尸进程，你可以结束其父进程，然后僵尸进程也随之消失。但是，如果父进程为<span class="jill"></span>init<span class="jill"></span>进程，你不能结束它。init<span class="jill"></span>进程是一个非常重要的进程，因此可能需要重启系统来清除僵尸进程。</span></aside><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>EXIT_DEAD</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">当进程从系统中删除时，它将进入此状态，因为其父进程已经通过 wait4() 或 waitpid() 调用收集了所有统计信息。EXIT_DEAD<span class="jill"></span>状态是非常短暂的，几乎不可能通过<span class="jill"></span>ps<span class="jill"></span>命令捕捉到。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap"> Linux 任务调度</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Linux<span class="jill"></span>使用完全公平调度器(CFS)进行任务调度(Linux<span class="jill"></span>不严格区分线程和进程，统称为<span class="jill"></span>task)，通过设置任务的优先级和任务的调度策略，可以调整调度器的行为。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">nice 和 priority</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>在了解调度之前，我们需要先了解两个概念，友好值(nice)和优先级(priority)</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">nice<span class="jill"></span>值越小表示该任务越不友好，抢占<span class="jill"></span>CPU<span class="jill"></span>能力就越强，nice<span class="jill"></span>值的取值范围是</span><span class="inline-wrap"><code>[-20,19]</code></span><span class="inline-wrap">,默认是<span class="jill"></span>0</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">priority<span class="jill"></span>越低，调度越优先，priority<span class="jill"></span>的取值范围</span><span class="inline-wrap"><code>[0,139]</code></span></div></div><aside class="bg-cultured wolai-block"><div data-symbol="🔥" class="icon"></div><span class="inline-wrap">priority=运行时优先级<span class="jill"></span>+ nice<span class="jill"></span>值<span class="jill"></span>+ 20</span></aside><div class="wolai-block wolai-text"><div><span class="inline-wrap">通过</span><span class="inline-wrap"><code>ps -o s,pid,pri,ni,cls</code></span><span class="inline-wrap"> 命令，我们可以查看任务的<span class="jill"></span>nice<span class="jill"></span>值和<span class="jill"></span>priority</span></div></div><h3 class="wolai-block"><span class="inline-wrap">调度策略</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">Linux<span class="jill"></span>有以下六种调度策略</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SCHED_FIFO</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SCHED_RR</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SCHED_OTHER(SCHED_NORMAL)</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SCHED_BATCH</code></span><span class="inline-wrap"> </span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SCHED_IDLE</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SCHED_DEADLINE</code></span></li></ul><aside class="bg-cultured wolai-block"><div data-symbol="💥" class="icon"></div><span class="inline-wrap">使用</span><span class="inline-wrap"><code>SCHED_FIFO</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>SCHED_RR</code></span><span class="inline-wrap">调度策略的叫做实时任务，其它的叫做非实时任务 。</span></aside><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>SCHED_FIFO</code></span><span class="inline-wrap">实现了一种简单的、先入先出的调度算法， 它不使用时间片。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">SCHED_FIFO<span class="jill"></span>的进程不基于时间片，一旦处于可执行状态，就会一直执行，直到它自己阻塞或者显式地释放处理器为止。只有较高优先级的<span class="jill"></span>SCHED_FIFO<span class="jill"></span>或者<span class="jill"></span>SCHED_RR<span class="jill"></span>任务才能抢占<span class="jill"></span>SCHED_FIFO<span class="jill"></span>任务。 只要有<span class="jill"></span>SCHED_FIFO<span class="jill"></span>级进程在执行，其他级别较低的进程就只能等待它结束后才有机会执行，除非它主动让出处理器才会退出。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>SCHED_RR</code></span><span class="inline-wrap">是一种带有时间片的<span class="jill"></span>SCHED_FIFO。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">当<span class="jill"></span>SCHED_RR<span class="jill"></span>任务耗尽它的时间片，在同一优先级的其他实时进程被轮流调度。时间片只能用来重新调度同一优先级的进程。对于<span class="jill"></span>SCHED_FIFO<span class="jill"></span>进程，高优先级总是立刻抢占低优先级，但是低优先级进程决不能抢占<span class="jill"></span>SCHED_RR<span class="jill"></span>任务，即使它的时间片耗尽。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-bookmark wolai-block"><a href="https://www.bilibili.com/video/BV1D5411p7Nx?p=1">Linux进阶之进程、线程及调度算法_哔哩哔哩_bilibili</a><div class="info-box"><div class="text-pane"><div data-title="Linux进阶之进程、线程及调度算法_哔哩哔哩_bilibili"></div><div data-desc="视频版权归原有作者所有， 仅供学习参考Linux入门基础视频"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://i2.hdslb.com/bfs/archive/c68e22a15e67e79b19a13a5ac3b91441518c5e5a.jpg@57w_57h_1c.png&quot;)"></div><div data-hostname="www.bilibili.com"></div></div></div><div class="preview-pane" style="background-image: url(http://i2.hdslb.com/bfs/archive/c68e22a15e67e79b19a13a5ac3b91441518c5e5a.jpg)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://man7.org/linux/man-pages/man7/sched.7.html">sched(7) - Linux manual page</a><div class="info-box"><div class="text-pane"><div data-title="sched(7) - Linux manual page"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://man7.org/favicon.ico&quot;)"></div><div data-hostname="man7.org"></div></div></div><div class="preview-pane"></div></div></div><h2 class="wolai-block"><span class="inline-wrap">Linux<span class="jill"></span>进程间通信</span></h2><div class="wolai-bookmark wolai-block"><a href="https://cloud.tencent.com/developer/column/1272/tag-10308">邹立巍的专栏的全部内容 - 云+社区 - 腾讯云</a><div class="info-box"><div class="text-pane"><div data-title="邹立巍的专栏的全部内容 - 云+社区 - 腾讯云"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cloud.tencent.com/favicon.ico&quot;)"></div><div data-hostname="cloud.tencent.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>进程通信的概念</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">进程用户空间是相互独立的，一般而言是不能相互访问的。但很多情况下进程间需要互相通信，来完成系统的某项功能。进程通过与内核及其它进程之间的互相通信来协调它们的行为。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>进程通信的应用场景</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">资源共享：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">进程控制：有些进程希望完全控制另一个进程的执行（如<span class="jill"></span>Debug<span class="jill"></span>进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>进程通信的方式</b></span></div></div><div class="wolai-block wolai-center"><figure><img src="media/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.jpeg" style="width: 759.5px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>1.管道</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">管道分为无名管道和</span><span class="inline-wrap">有名管道</span><span class="inline-wrap">(FIFO)</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">无名管道是一种半双工的通信方式,数据只能单向流动,而且只能在具有亲缘关系的进程间使用.进程的亲缘关系一般指的是父子关系。无明管道一般用于两个不同进程之间的通信。当一个进程创建了一个管道,并调用<span class="jill"></span>fork<span class="jill"></span>创建自己的一个子进程后,父进程关闭读管道端,子进程关闭写管道端,这样提供了两个进程之间数据流动的一种方式。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">有名管道也是一种半双工的通信方式,但是它允许无亲缘关系进程间的通信。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>2.信号</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>3.消息队列</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">消息队列是消息的链表,存放在内核中并由消息队列标识符标识.消息队列克服了信号传递信息少,管道只能承载无格式字节流以及缓冲区大小受限等特点.消息队列是<span class="jill"></span>UNIX<span class="jill"></span>下不同进程之间可实现共享资源的一种机制,UNIX<span class="jill"></span>允许不同进程将格式化的数据流以消息队列形式发送给任意进程.对消息队列具有操作权限的进程都可以使用<span class="jill"></span>msget<span class="jill"></span>完成对消息队列的操作控制.通过使用消息类型,进程可以按任何顺序读信息,或为消息安排优先级顺序.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">4</span><span class="inline-wrap"><b>.信号量</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">信号量是一个计数器,可以用来控制多个线程对共享资源的访问.,它不是用于交换大批数据,而用于多线程之间的同步.它常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源.因此,主要作为进程间以及同一个进程内不同线程之间的同步手段.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://www.linuxprobe.com/"><span>Linux</span></a></span><span class="inline-wrap">提供了一组精心设计的信号量接口来对信号进行操作，它们不只是针对二进制信号量，下面将会对这些函数进行介绍，但请注意，这些函数都是用来对成组的信号量值进行操作的。它们声明在头文件<span class="jill"></span>sys/sem.h<span class="jill"></span>中</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">semget<span class="jill"></span>函数：它的作用是创建一个新信号量或取得一个已有信号量</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">semop<span class="jill"></span>函数：它的作用是改变信号量的值</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">semctl<span class="jill"></span>函数：该函数用来直接控制信号量信息</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>5.共享内存</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">共享内存就是映射一段能被其他进程所访问的内存,这段共享内存由一个进程创建,但多个进程都可以访问.共享内存是最快的<span class="jill"></span>IPC(进程间通信)方式,它是针对其它进程间通信方式运行效率低而专门设计的.它往往与其他通信机制,如信号量,配合使用,来实现进程间的同步与通信.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>6.套接字</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">socket，即套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。也因为这样，套接字明确地将客户端和服务器区分开来。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">套接字的特性由<span class="jill"></span>3<span class="jill"></span>个属性确定，它们分别是：域、类型和协议。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">Linux<span class="jill"></span>进程的创建流程</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-bookmark wolai-block"><a href="https://www.eefocus.com/column/%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E6%9E%81%E5%AE%A2/">人人都是极客的专栏文章 - 专栏 - 与非网 - eefocus: 国内领先的电子技术门户网站</a><div class="info-box"><div class="text-pane"><div data-title="人人都是极客的专栏文章 - 专栏 - 与非网 - eefocus: 国内领先的电子技术门户网站"></div><div data-desc="人人都是极客关于半导体、集成电路、芯片及电子产业的所有深度分析文"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://www.eefocus.com/asset/custom/image/favicon.ico&quot;)"></div><div data-hostname="www.eefocus.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://zhuanlan.zhihu.com/p/88017448">操作系统（三）—进程管理</a><div class="info-box"><div class="text-pane"><div data-title="操作系统（三）—进程管理"></div><div data-desc="引言续接上文，这次磕进程管理~文章导读进程概述进程控制块进程的状态线程管理进程控制处理机/CPU调度同步&amp;amp;互斥信号量与管程进程间通信的方式一、进程概述进程：一个具有一定独立功能的程序在一个数据集合上一…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.a53ae37b.png&quot;)"></div><div data-hostname="zhuanlan.zhihu.com"></div></div></div><div class="preview-pane" style="background-image: url(https://pic3.zhimg.com/v2-4645d20748c5ccee52b735502bd77ec4_720w.jpg?source=172ae18b)"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">Linux<span class="jill"></span>线程的创建流程</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></article><footer></footer></body></html>
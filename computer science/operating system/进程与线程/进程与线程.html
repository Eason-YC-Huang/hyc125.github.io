<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/wolai.css"/><title>进程与线程 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div data-symbol="🏐" class="icon"></div></div><div data-title="进程与线程" class="main-title"></div></div></header><article><blockquote class="wolai-block"><span class="inline-wrap">人们想让计算机可以同时运行多个程序，因此有了进程。
人们想让程序可以同时做多件事情，因此有了线程。</span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap">运行中的程序叫作进程，进程是操作系统进行资源分配的最小单位。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">线程是<span class="jill"></span>CPU<span class="jill"></span>调度的最小单位，一条线程是进程里面的一条执行流程。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">进程可以看做是线程和资源的集合。</span></div></div><aside class="bg-cultured wolai-block"><div data-symbol="🚀" class="icon"></div><span class="inline-wrap">有哪些资源？</span></aside><div class="wolai-bookmark wolai-block"><a href="https://zhuanlan.zhihu.com/p/337978321">干货 | 进程、线程、协程 10 张图讲明白了！</a><div class="info-box"><div class="text-pane"><div data-title="干货 | 进程、线程、协程 10 张图讲明白了！"></div><div data-desc="本文已收录Github：imcoderlemon/CodeClass从小白到架构师，关于编程所有你需要掌握的内容都在这里 进程线程可以说是操作系统基础，看过很多关于这方面知识的文章都是纯理论讲述，编程新手有些难以下咽。 我准备用…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.a53ae37b.png&quot;)"></div><div data-hostname="zhuanlan.zhihu.com"></div></div></div><div class="preview-pane" style="background-image: url(https://pic2.zhimg.com/v2-ead2b6e7212fd8b54495d0b4b415b539_720w.jpg?source=172ae18b)"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">进程控制块</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">为了更好的管理进程，操作系统使用了一种叫进程控制块(PCB)的数据结构。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">进程控制块存放了操作系统用于控制进程所需的信息。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">例如，进程的状态、程序计数器、栈指针、打开的文件、调度算法 等等。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">进程表：由多个</span><span class="inline-wrap"><code>PCB</code></span><span class="inline-wrap">组成的</span><span class="inline-wrap"><code>PCB</code></span><span class="inline-wrap">数组。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">进程调度算法</span></h2><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="red inline-wrap">先来先服务调度算法</span><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</b></span></div></div></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="red inline-wrap">最短作业优先调度算法</span><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>优先选择运行时间最短的进程来运行</b></span><span class="inline-wrap">，这有助于提高系统的吞吐量，但是对长作业不利，极端可能导致长作业长期不会被运行。</span></div></div></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="red inline-wrap">时间片轮转调度算法</span><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>每个进程被分配一个时间片（</b></span><span class="inline-wrap"><i><b>Quantum</b></i></span><span class="inline-wrap"><b>），即允许该进程在该时间片中运行。</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。</span></div></div></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="red inline-wrap">最高优先级调度算法</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能</span><span class="inline-wrap"><b>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（</b></span><span class="inline-wrap"><i><b>Highest Priority First，HPF</b></i></span><span class="inline-wrap"><b>）调度算法</b></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">进程的优先级可以分为，静态优先级或动态优先级：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是</span><span class="inline-wrap"><b>随着时间的推移增加等待进程的优先级</b></span><span class="inline-wrap">。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">该算法也有两种处理优先级高的方法，非抢占式和抢占式：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">但是依然有缺点，可能会导致低优先级的进程永远不会运行。</span></div></div></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="red inline-wrap">多级反馈队列调度算法</span><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></li></ul><div class="wolai-bookmark wolai-block"><a href="https://www.cnblogs.com/xiaolincoding/p/13631224.html">大厂面试爱问的「调度算法」，20 张图一举拿下 - 小林coding - 博客园</a><div class="info-box"><div class="text-pane"><div data-title="大厂面试爱问的「调度算法」，20 张图一举拿下 - 小林coding - 博客园"></div><div data-desc="前言 最近，我偷偷潜伏在各大技术群，因为秋招在即，看到不少小伙伴分享的大厂面经。 然后发现，操作系统的知识点考察还是比较多的，大厂就是大厂就爱问基础知识。其中，关于操作系统的「调度算法」考察也算比较频"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://common.cnblogs.com/favicon.svg&quot;)"></div><div data-hostname="www.cnblogs.com"></div></div></div><div class="preview-pane"></div></div></div><h2 class="wolai-block"><span class="inline-wrap">进程状态</span></h2><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image.png" style="width: 100%"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">Linux<span class="jill"></span>进程控制块</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Linux<span class="jill"></span>的</span><span class="inline-wrap"><code>PCB</code></span><span class="inline-wrap">是</span><span class="inline-wrap"><code>task_struct</code></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_1.png" style="width: 100%"/></figure></div><div class="wolai-bookmark wolai-block"><a href="https://blog.csdn.net/w_y_x_y/article/details/80016975">Linux：进程控制块PCB_桔飞飞-CSDN博客_linux 进程控制块</a><div class="info-box"><div class="text-pane"><div data-title="Linux：进程控制块PCB_桔飞飞-CSDN博客_linux 进程控制块"></div><div data-desc="想要有顺序地学习Linux，入口在这里哦：Linux：目录索引PCB：进程控制块0.PCB是干什么的？  学了操作系统后，我们都知道操作系统要想管理一个对象，它不是直接进行管理的，而是通过得到被管理者的一些有效信息加以管理的，因此在这里我们也可以这样理解，操作系统管理进程，实则是将进程的有效信息提取出来然后通过管理这些信息来管理进程，而所有的进程信息被存放在一个叫做进程控制块的数..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://g.csdnimg.cn/static/logo/favicon32.ico&quot;)"></div><div data-hostname="blog.csdn.net"></div></div></div><div class="preview-pane"></div></div></div><h2 class="wolai-block"><span class="inline-wrap">Linux<span class="jill"></span>进程状态</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">每一个进程拥有自己的状态，在进程的执行期间进程的状态会发生改变。一些进程的状态如下：  </span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://pic3.zhimg.com/80/v2-cd72925671408a954e9f625180e55cc6_1440w.jpg" style="width: 760px"/></figure></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>TASK_RUNNING </b></span><div class="wolai-block wolai-text"><div><span class="inline-wrap">进程可能正在运行也可能在队列中等待运行。</span></div></div></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>TASK_INTERRUPTIBLE</b></span><span class="inline-wrap"> </span><div class="wolai-block wolai-text"><div><span class="inline-wrap">进程处于可中断的睡眠状态。</span></div></div></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>TASK_UNINTERRUPTIBLE</b></span><div class="wolai-block wolai-text"><div><span class="inline-wrap">进程处于不可中断的睡眠状态。</span></div></div></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>TASK_STOPPED</b></span><span class="inline-wrap"> </span><div class="wolai-block wolai-text"><div><span class="inline-wrap">在此状态下的进程被某些信号暂停，例如</span><span class="inline-wrap"><code>SIGINT</code></span><span class="inline-wrap">，</span><span class="inline-wrap"><code>SIGSTOP</code></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">进程正在等待通过一个信号恢复运行，例如</span><span class="inline-wrap"><code>SIGCONT</code></span><span class="inline-wrap">。</span></div></div></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>EXIT_ZOMBIE</b></span><div class="wolai-block wolai-text"><div><span class="inline-wrap">当一个进程调用</span><span class="inline-wrap"><code>exit()</code></span><span class="inline-wrap">或收到信号而终止时，它会释放它持有的所有资源，然后发送一个</span><span class="inline-wrap"><code>SIGCHLD</code></span><span class="inline-wrap">信号给它的父进程，由它的父进程负责把该进程从进程表中移除。从发出信号到被移出进程表，该进程处于</span><span class="inline-wrap"><code>TASK_ZOMBIE</code></span><span class="inline-wrap">状态。</span></div></div><aside class="bg-cultured wolai-block"><div data-symbol="🔥" class="icon"></div><span class="inline-wrap">使用</span><span class="inline-wrap"><code>kill</code></span><span class="inline-wrap">命令来关闭这样的一个进程是不可能的，因为该进程已经被认为已经死掉了。如果你不能清除僵尸进程，你可以结束其父进程，然后僵尸进程也随之消失。但是，如果父进程为</span><span class="inline-wrap"><code>init</code></span><span class="inline-wrap">进程，你不能结束它。</span><span class="inline-wrap"><code>init</code></span><span class="inline-wrap">进程是一个非常重要的进程，因此可能需要重启系统来清除僵尸进程。</span></aside></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>EXIT_DEAD</b></span><div class="wolai-block wolai-text"><div><span class="inline-wrap">当进程从系统中删除时，它将进入此状态，因为其父进程已经通过 wait4() 或 waitpid() 调用收集了所有统计信息。EXIT_DEAD<span class="jill"></span>状态是非常短暂的，几乎不可能通过<span class="jill"></span>ps<span class="jill"></span>命令捕捉到。</span></div></div></li></ul><h2 class="wolai-block"><span class="inline-wrap"> Linux 任务调度</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Linux<span class="jill"></span>使用完全公平调度器(CFS)进行任务调度(Linux<span class="jill"></span>不严格区分线程和进程，统称为<span class="jill"></span>task)，通过设置任务的优先级和任务的调度策略，可以调整调度器的行为。</span></div></div><aside class="bg-cultured wolai-block"><div data-symbol="❄️" class="icon"></div><span class="inline-wrap">有些任务有独自的内存空间，有些任务要与别的任务共享内存空间。</span></aside><h3 class="wolai-block"><span class="inline-wrap">nice 和 priority</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>在了解调度之前，我们需要先了解两个概念，友好值(</b></span><span class="inline-wrap"><b><code>nice</code></b></span><span class="inline-wrap"><b>)和优先级(</b></span><span class="inline-wrap"><b><code>priority</code></b></span><span class="inline-wrap"><b>)</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">nice<span class="jill"></span>值越小表示该任务越不友好，抢占<span class="jill"></span>CPU<span class="jill"></span>能力就越强，</span><span class="inline-wrap"><code>nice</code></span><span class="inline-wrap">值的取值范围是</span><span class="inline-wrap"><code>[-20,19]</code></span><span class="inline-wrap">,默认是<span class="jill"></span>0</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">priority<span class="jill"></span>越低，调度越优先，priority<span class="jill"></span>的取值范围</span><span class="inline-wrap"><code>[0,139]</code></span></div></div><aside class="bg-cultured wolai-block"><div data-symbol="🔥" class="icon"></div><span class="inline-wrap">priority=运行时优先级<span class="jill"></span>+ nice<span class="jill"></span>值<span class="jill"></span>+ 20</span></aside><div class="wolai-block wolai-text"><div><span class="inline-wrap">通过</span><span class="inline-wrap"><code>ps -o s,pid,pri,ni,cls</code></span><span class="inline-wrap"> 命令，我们可以查看任务的<span class="jill"></span>nice<span class="jill"></span>值和<span class="jill"></span>priority</span></div></div><h3 class="wolai-block"><span class="inline-wrap">调度策略</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">Linux<span class="jill"></span>有以下六种调度策略</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SCHED_FIFO</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SCHED_RR</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SCHED_OTHER(SCHED_NORMAL)</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SCHED_BATCH</code></span><span class="inline-wrap"> </span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SCHED_IDLE</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SCHED_DEADLINE</code></span></li></ul><aside class="bg-cultured wolai-block"><div data-symbol="💥" class="icon"></div><span class="inline-wrap">使用</span><span class="inline-wrap"><code>SCHED_FIFO</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>SCHED_RR</code></span><span class="inline-wrap">调度策略的叫做实时任务，其它的叫做非实时任务 。</span></aside><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>SCHED_FIFO</code></span><span class="inline-wrap">实现了一种简单的、先入先出的调度算法， 它不使用时间片。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">SCHED_FIFO<span class="jill"></span>的进程不基于时间片，一旦处于可执行状态，就会一直执行，直到它自己阻塞或者显式地释放处理器为止。只有较高优先级的<span class="jill"></span>SCHED_FIFO<span class="jill"></span>或者<span class="jill"></span>SCHED_RR<span class="jill"></span>任务才能抢占<span class="jill"></span>SCHED_FIFO<span class="jill"></span>任务。 只要有<span class="jill"></span>SCHED_FIFO<span class="jill"></span>级进程在执行，其他级别较低的进程就只能等待它结束后才有机会执行，除非它主动让出处理器才会退出。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>SCHED_RR</code></span><span class="inline-wrap">是一种带有时间片的<span class="jill"></span>SCHED_FIFO。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">当<span class="jill"></span>SCHED_RR<span class="jill"></span>任务耗尽它的时间片，在同一优先级的其他实时进程被轮流调度。时间片只能用来重新调度同一优先级的进程。对于<span class="jill"></span>SCHED_FIFO<span class="jill"></span>进程，高优先级总是立刻抢占低优先级，但是低优先级进程决不能抢占<span class="jill"></span>SCHED_RR<span class="jill"></span>任务，即使它的时间片耗尽。</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://www.eefocus.com/embedded/493882">Linux 进程管理之CFS调度器-嵌入式系统-与非网</a><div class="info-box"><div class="text-pane"><div data-title="Linux 进程管理之CFS调度器-嵌入式系统-与非网"></div><div data-desc="详解CFS调度器。"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://www.eefocus.com/asset/custom/image/favicon.ico&quot;)"></div><div data-hostname="www.eefocus.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://www.bilibili.com/video/BV1D5411p7Nx?p=1">Linux进阶之进程、线程及调度算法_哔哩哔哩_bilibili</a><div class="info-box"><div class="text-pane"><div data-title="Linux进阶之进程、线程及调度算法_哔哩哔哩_bilibili"></div><div data-desc="视频版权归原有作者所有， 仅供学习参考Linux入门基础视频"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://i2.hdslb.com/bfs/archive/c68e22a15e67e79b19a13a5ac3b91441518c5e5a.jpg@57w_57h_1c.png&quot;)"></div><div data-hostname="www.bilibili.com"></div></div></div><div class="preview-pane" style="background-image: url(http://i2.hdslb.com/bfs/archive/c68e22a15e67e79b19a13a5ac3b91441518c5e5a.jpg)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://man7.org/linux/man-pages/man7/sched.7.html">sched(7) - Linux manual page</a><div class="info-box"><div class="text-pane"><div data-title="sched(7) - Linux manual page"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://man7.org/favicon.ico&quot;)"></div><div data-hostname="man7.org"></div></div></div><div class="preview-pane"></div></div></div><h2 class="wolai-block"><span class="inline-wrap">Linux<span class="jill"></span>进程间通信</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>进程通信的概念</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">进程用户空间是相互独立的，一般而言是不能相互访问的。但很多情况下进程间需要互相通信，来完成系统的某项功能。进程通过与内核及其它进程之间的互相通信来协调它们的行为。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>进程通信的应用场景</b></span><span class="inline-wrap">：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">资源共享：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">进程控制：有些进程希望完全控制另一个进程的执行（如<span class="jill"></span>Debug<span class="jill"></span>进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>进程通信的方式</b></span><span class="inline-wrap">：</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.jpeg" style="width: 759.5px"/></figure></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap"><b>管道</b></span><div class="wolai-block wolai-text"><div><span class="inline-wrap">管道分为无名管道和有名管道(</span><span class="inline-wrap"><code>FIFO</code></span><span class="inline-wrap">)</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">无名管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系一般指的是父子关系。无名管道一般用于两个不同进程之间的通信。当一个进程创建了一个管道，并调用</span><span class="inline-wrap"><code>fork</code></span><span class="inline-wrap">创建自己的一个子进程后，父进程关闭读管道端，子进程关闭写管道端，这样提供了两个进程之间数据流动的一种方式。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">有名管道也是一种半双工的通信方式，但是它允许无亲缘关系进程间的通信。</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://cloud.tencent.com/developer/article/1005566">Linux 的进程间通信：管道 - 云+社区 - 腾讯云</a><div class="info-box"><div class="text-pane"><div data-title="Linux 的进程间通信：管道 - 云+社区 - 腾讯云"></div><div data-desc="管道，英文为 pipe 。这是一个我们在学习 Linux 命令行的时候就会引入的一个很重要的概念。管道是UNIX 环境中历史最悠久的进程间通信方式。本文主要说明..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cloud.tencent.com/favicon.ico&quot;)"></div><div data-hostname="cloud.tencent.com"></div></div></div><div class="preview-pane"></div></div></div></li><li><div class="marker"></div><span class="inline-wrap"><b>信号</b></span><div class="wolai-block wolai-text"><div><span class="inline-wrap">信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生。</span></div></div></li><li><div class="marker"></div><span class="inline-wrap"><b>消息队列</b></span><div class="wolai-block wolai-text"><div><span class="inline-wrap">消息队列是消息的链表,存放在内核中并由消息队列标识符标识.消息队列克服了信号传递信息少,管道只能承载无格式字节流以及缓冲区大小受限等特点。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">消息队列是<span class="jill"></span>UNIX<span class="jill"></span>下不同进程之间可实现共享资源的一种机制,UNIX<span class="jill"></span>允许不同进程将格式化的数据流以消息队列形式发送给任意进程.对消息队列具有操作权限的进程都可以使用<span class="jill"></span>msget<span class="jill"></span>完成对消息队列的操作控制.通过使用消息类型,进程可以按任何顺序读信息,或为消息安排优先级顺序。</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://cloud.tencent.com/developer/article/1005533">Linux 的进程间通信：消息队列 - 云+社区 - 腾讯云</a><div class="info-box"><div class="text-pane"><div data-title="Linux 的进程间通信：消息队列 - 云+社区 - 腾讯云"></div><div data-desc="Linux 环境提供了 XSI 和 POSIX 两套消息队列，本文将帮助您掌握以下内容：如何使用 XSI 消息队列，如何使用 POSIX 消息队列，它们的底层实..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cloud.tencent.com/favicon.ico&quot;)"></div><div data-hostname="cloud.tencent.com"></div></div></div><div class="preview-pane"></div></div></div></li><li><div class="marker"></div><span class="inline-wrap"><b>信号量</b></span><div class="wolai-block wolai-text"><div><span class="inline-wrap">信号量是一个计数器,可以用来控制多个线程对共享资源的访问.,它不是用于交换大批数据,而用于多线程之间的同步.它常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源.因此,主要作为进程间以及同一个进程内不同线程之间的同步手段。</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://cloud.tencent.com/developer/article/1005536">Linux 的进程间通信:信号量 - 云+社区 - 腾讯云</a><div class="info-box"><div class="text-pane"><div data-title="Linux 的进程间通信:信号量 - 云+社区 - 腾讯云"></div><div data-desc="Linux环境下主要实现的信号量有两种。根据标准的不同，它们跟共享内存类似，一套XSI的信号量，一套POSIX的信号量。下面我们分别使用它们实现一套类似文件锁的..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cloud.tencent.com/favicon.ico&quot;)"></div><div data-hostname="cloud.tencent.com"></div></div></div><div class="preview-pane"></div></div></div></li><li><div class="marker"></div><span class="inline-wrap"><b>共享内存</b></span><div class="wolai-block wolai-text"><div><span class="inline-wrap">共享内存就是映射一段能被其他进程所访问的内存,这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的进程间通信方式，它是针对其它进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步与通信。</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://cloud.tencent.com/developer/article/1005542">Linux 进程间通信 : 共享内存（上） - 云+社区 - 腾讯云</a><div class="info-box"><div class="text-pane"><div data-title="Linux 进程间通信 : 共享内存（上） - 云+社区 - 腾讯云"></div><div data-desc="使用文件或管道进行进程间通信会有很多局限性，比如效率问题以及数据处理使用文件描述符而不如内存地址访问方便，于是多个进程以共享内存的方式进行通信就成了很自然要实现..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cloud.tencent.com/favicon.ico&quot;)"></div><div data-hostname="cloud.tencent.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://cloud.tencent.com/developer/article/1005543">Linux进程间通信：共享内存 （下） - 云+社区 - 腾讯云</a><div class="info-box"><div class="text-pane"><div data-title="Linux进程间通信：共享内存 （下） - 云+社区 - 腾讯云"></div><div data-desc="使用文件或管道进行进程间通信会有很多局限性，比如效率问题以及数据处理使用文件描述符而不如内存地址访问方便，于是多个进程以共享内存的方式进行通信就成了很自然要实现..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cloud.tencent.com/favicon.ico&quot;)"></div><div data-hostname="cloud.tencent.com"></div></div></div><div class="preview-pane"></div></div></div></li><li><div class="marker"></div><span class="inline-wrap"><b>套接字</b></span><div class="wolai-block wolai-text"><div><span class="inline-wrap">socket，即套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。也因为这样，套接字明确地将客户端和服务器区分开来。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">套接字的特性由<span class="jill"></span>3<span class="jill"></span>个属性确定，它们分别是：域、类型和协议。</span></div></div></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">Linux<span class="jill"></span>进程的创建</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>在<span class="jill"></span>Linux<span class="jill"></span>系统中，除了系统启动之后的第一个进程由系统来创建，其余的进程都必须由已存在的进程来创建，新创建的进程叫做子进程，而创建子进程的进程叫做父进程。</b></span></div></div><h3 class="wolai-block"><span class="red inline-wrap">fork</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>在<span class="jill"></span>Linux<span class="jill"></span>中，父进程以分裂的方式来创建子进程，创建一个子进程的系统调用叫做</b></span><span class="inline-wrap"><b><code>fork</code></b></span><span class="inline-wrap"><b>。</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">创建出来的子进程跟父进程具有同样的代码段。也就是他们的代码执行逻辑是一模一样的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在父进程中调用</span><span class="inline-wrap"><code>fork()</code></span><span class="inline-wrap">之后会产生两种结果：一种为分裂子进程失败，另一种就是分裂子进程成功。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>如果</b></span><span class="inline-wrap"><b><code>fork()</code></b></span><span class="inline-wrap"><b>失败，返回-1，否则会出现父进程和子进程两个进程，子进程的</b></span><span class="inline-wrap"><b><code>fork()</code></b></span><span class="inline-wrap"><b>返回</b></span><span class="inline-wrap"><b><code>0</code></b></span><span class="inline-wrap"><b>，父进程的</b></span><span class="inline-wrap"><b><code>fork()</code></b></span><span class="inline-wrap"><b>返回子进程的</b></span><span class="inline-wrap"><b><code>ID</code></b></span><span class="inline-wrap"><b>。</b></span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
 
    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                <span class="token comment">//打印fork()失败信息</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                <span class="token comment">//子进程代码</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                <span class="token comment">//父进程代码</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
</pre></div></code-block><h3 class="wolai-block"><span class="red inline-wrap">execv</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果只能创建跟父进程一样子进程，那么意义是不大的。为此<span class="jill"></span>Linux<span class="jill"></span>提供了另一个系统调用</span><span class="inline-wrap"><b><code>execv</code></b></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b><code>execv</code></b></span><span class="inline-wrap">让</span><span class="inline-wrap"><b>程序可以在运行中加载并运行一个可执行文件</b></span><span class="inline-wrap">。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre><span class="token keyword">int</span> <span class="token function">execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">参数<span class="jill"></span>path<span class="jill"></span>为可执行文件路径，argv[]为执行该可执行文件时传递的命令行参数。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">execv<span class="jill"></span>其实是<span class="jill"></span>Linux<span class="jill"></span>的</span><span class="inline-wrap"><code>exec</code></span><span class="inline-wrap">函数族成员之一，该函数族一共有<span class="jill"></span>5<span class="jill"></span>个函数和<span class="jill"></span>1<span class="jill"></span>个系统调用。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre><span class="token keyword">int</span> <span class="token function">execl</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execle</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execve</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">其中，</span><span class="inline-wrap"><b>只有</b></span><span class="inline-wrap"><b><code>execv</code></b></span><span class="inline-wrap"><b>是真正意义上的系统调用，其他的都是在此基础上经过包装的库函数。</b></span></div></div><div class="wolai-bookmark wolai-block"><a href="https://stackoverflow.com/questions/50421197/what-does-the-ve-in-execve-mean">What does the &quot;ve&quot; in &quot;execve&quot; mean?</a><div class="info-box"><div class="text-pane"><div data-title="What does the &quot;ve&quot; in &quot;execve&quot; mean?"></div><div data-desc="What does the ve in execve mean?

I read through man execve but didn&apos;t see what it means. I gather it might be &quot;vector&quot; but not sure. What does the ve mean?"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon.png?v=c78bd457575a&quot;)"></div><div data-hostname="stackoverflow.com"></div></div></div><div class="preview-pane" style="background-image: url(https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon.png?v=c78bd457575a)"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b><code>exec*</code></b></span><span class="inline-wrap">函数执行成功后一般不会返回调用点，因为它运行了一个新的程序，进程的代码段、数据段和堆栈等都已经被新的数据所取代，只留下进程<span class="jill"></span>ID<span class="jill"></span>等一些表面信息仍保持原样。只有调用失败了，它们才会返回一个-1，从原程序的调用点接着往下执行。</span></div></div><h3 class="wolai-block"><span class="red inline-wrap">wait</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">子进程由父进程分裂而来，</span><span class="inline-wrap"><b>父进程需要负责在子进程结束之后释放子进程所占用的系统资源。</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">当子进程运行结束后，系统会向其父进程发出一个信息，请求父进程释放子进程所占用的系统资源。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">为了避免父进程先于子进程结束，父进程可以调用</span><span class="inline-wrap"><b><code>wait</code></b></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>父进程一旦调用了</b></span><span class="inline-wrap"><b><code>wait</code></b></span><span class="inline-wrap"><b>就立即阻塞自己，由</b></span><span class="inline-wrap"><b><code>wait</code></b></span><span class="inline-wrap"><b>自动分析当前进程的某个子进程是否已经退出，如果有就把它彻底销毁后返回；如果没有找到这样一个子进程，</b></span><span class="inline-wrap"><b><code>wait</code></b></span><span class="inline-wrap"><b>就会一直阻塞在这里，直到有一个出现为止。</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果父进程先于子进程结束进程，则子进程会因为失去父进程而成为“孤儿进程”。</span><span class="inline-wrap"><b>在<span class="jill"></span>Linux<span class="jill"></span>中，如果一个进程变成了“孤儿进程”，那么这个进程将以系统在初始化时创建的<span class="jill"></span>init<span class="jill"></span>进程(1<span class="jill"></span>号进程)为父进程。</b></span></div></div><aside class="bg-cultured wolai-block"><div data-symbol="❄️" class="icon"></div><span class="inline-wrap">孤儿进程与</span><span class="inline-wrap">僵尸进程</span></aside><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">僵尸进程：一个进程使用</span><span class="inline-wrap"><b><code>fork</code></b></span><span class="inline-wrap">创建子进程，如果子进程退出，而父进程并没有调用</span><span class="inline-wrap"><b><code>wait</code></b></span><span class="inline-wrap">或</span><span class="inline-wrap"><b><code>waitpid</code></b></span><span class="inline-wrap">获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。</span></li></ul><h3 class="wolai-block"><span class="red inline-wrap">exit</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">Linux<span class="jill"></span>提供系统调用</span><span class="inline-wrap"><b><code>exit</code></b></span><span class="inline-wrap">来终结一个进程。</span><span class="inline-wrap"><b>如果一个进程调用</b></span><span class="inline-wrap"><b><code>exit</code></b></span><span class="inline-wrap"><b>，那么这个进程会立即退出运行，并释放除了进程控制块之外的各种内核数据结构。</b></span></div></div><h3 class="wolai-block"><span class="red inline-wrap">vfork</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>vfork</code></span><span class="inline-wrap">是<span class="jill"></span>Linux<span class="jill"></span>提供的另一个用来生成一个子进程的系统调用。

它跟<span class="jill"></span>fork<span class="jill"></span>有什么区别呢？</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>fork</code></span><span class="inline-wrap">：子进程</span><span class="red inline-wrap">拷贝</span><span class="inline-wrap">父进程的数据段，代码段</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>vfork</code></span><span class="inline-wrap">：子进程与父进程</span><span class="red inline-wrap">共享</span><span class="inline-wrap">数据段</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>fork</code></span><span class="inline-wrap">：父子进程的执行次序不确定</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>vfork</code></span><span class="inline-wrap"> ：保证子进程先运行，在它调用</span><span class="inline-wrap"><code>exec</code></span><span class="inline-wrap">或</span><span class="inline-wrap"><code>exit</code></span><span class="inline-wrap"> 之后父进程才可能被调度运行</span></li></ul><div class="wolai-bookmark wolai-block"><a href="https://stackoverflow.com/questions/4259629/what-is-the-difference-between-fork-and-vfork">https://stackoverflow.com/questions/4259629/what-is-the-difference-between-fork-and-vfork</a><div class="info-box"><div class="text-pane"><div data-title="stackoverflow.com"></div><div class="icon-host"><div data-hostname="stackoverflow.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://stackoverflow.com/questions/4856255/the-difference-between-fork-vfork-exec-and-clone">The difference between fork(), vfork(), exec() and clone()</a><div class="info-box"><div class="text-pane"><div data-title="The difference between fork(), vfork(), exec() and clone()"></div><div data-desc="I was looking to find the difference between these four on Google and I expected there to be a huge amount of information on this, but there really wasn&apos;t any solid comparison between the four call..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon.png?v=c78bd457575a&quot;)"></div><div data-hostname="stackoverflow.com"></div></div></div><div class="preview-pane" style="background-image: url(https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon.png?v=c78bd457575a)"></div></div></div><aside class="bg-cultured wolai-block"><div data-symbol="❄️" class="icon"></div><span class="inline-wrap">虽然<span class="jill"></span>fork<span class="jill"></span>使用写时复制技术，不会真正的拷贝内存，但是创建子进程时，它会向系统申请与父进程同样的内存大小。</span></aside><h3 class="wolai-block"><span class="inline-wrap">深入<span class="jill"></span>Linux<span class="jill"></span>进程的创建过程</span></h3><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">地址空间是怎么设置的？</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">页表是怎么设置的？</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">一个进程的虚拟地址空间主要由两个数据结来描述。一个是最高层次的：</span><span class="inline-wrap"><code>mm_struct</code></span><span class="inline-wrap">，一个是较高层次的：</span><span class="inline-wrap"><code>vm_area_structs</code></span><span class="inline-wrap">。最高层次的</span><span class="inline-wrap"><code>mm_struct</code></span><span class="inline-wrap">结构描述了一个进程的整个虚拟地址空间。较高层次的结构</span><span class="inline-wrap"><code>vm_area_truct</code></span><span class="inline-wrap">描述了虚拟地址空间的一个区间。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_2.png" style="width: 100%"/></figure></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_3.png" style="width: 100%"/></figure></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_4.png" style="width: 716px"/></figure></div><div class="wolai-block wolai-text"><div></div></div><h2 class="wolai-block"><span class="inline-wrap">Linux<span class="jill"></span>线程的创建</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">Linux<span class="jill"></span>线程状态</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">Linux 线程同步</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap"><b>为什么线程切换比进程切换快？</b></span></summary><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">进程切换会涉及到虚拟地址映射的切换，也就是页表。</span><span class="inline-wrap"><b>页表的切换实质上导致<span class="jill"></span>TLB<span class="jill"></span>的缓存全部失效，这些寄存器里的内容需要全部重写。而线程切换无需经历此步骤。</b></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">进程切换涉及到上下文(寄存器组)的切换。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">进程都被切换了，进程内的线程肯定也要被切换了。</span></li></ul><div class="wolai-bookmark wolai-block"><a href="https://www.heapdump.cn/article/1935039">深入理解Linux内核进程上下文切换 | HeapDump性能社区</a><div class="info-box"><div class="text-pane"><div data-title="深入理解Linux内核进程上下文切换 | HeapDump性能社区"></div><div data-desc="我都知道操作系统的一个重要功能就是进行进程管理，而进程管理就是在合适的时机选择合适的进程来执行，在单个cpu运行队列上各个进程宏观并行微观串行执行，多个cpu运行队列上的各个进程之间完全的并行执行。进 | HeapDump性能社区"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://www.heapdump.cn/favicon.ico?v=2&quot;)"></div><div data-hostname="www.heapdump.cn"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></details><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">参考文献</span></h2><div class="wolai-bookmark wolai-block"><a href="https://www.eefocus.com/column/%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E6%9E%81%E5%AE%A2/">人人都是极客的专栏文章 - 专栏 - 与非网 - eefocus: 国内领先的电子技术门户网站</a><div class="info-box"><div class="text-pane"><div data-title="人人都是极客的专栏文章 - 专栏 - 与非网 - eefocus: 国内领先的电子技术门户网站"></div><div data-desc="人人都是极客关于半导体、集成电路、芯片及电子产业的所有深度分析文"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://www.eefocus.com/asset/custom/image/favicon.ico&quot;)"></div><div data-hostname="www.eefocus.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://zhuanlan.zhihu.com/p/88017448">操作系统（三）—进程管理</a><div class="info-box"><div class="text-pane"><div data-title="操作系统（三）—进程管理"></div><div data-desc="引言续接上文，这次磕进程管理~文章导读进程概述进程控制块进程的状态线程管理进程控制处理机/CPU调度同步&amp;amp;互斥信号量与管程进程间通信的方式一、进程概述进程：一个具有一定独立功能的程序在一个数据集合上一…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.a53ae37b.png&quot;)"></div><div data-hostname="zhuanlan.zhihu.com"></div></div></div><div class="preview-pane" style="background-image: url(https://pic3.zhimg.com/v2-4645d20748c5ccee52b735502bd77ec4_720w.jpg?source=172ae18b)"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>
<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/wolai.css"/><title>计算机组成原理 - wolai 笔记</title><link rel="shortcut icon"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="计算机组成原理" class="main-title"></div></div></header><article><h2 class="wolai-block"><span class="inline-wrap">计算机的工作模式</span></h2><div class="wolai-block wolai-center"><figure><img src="media/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.jpeg" style="width: 760px"/></figure></div><h3 class="wolai-block"><span class="inline-wrap">总线</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">计算机的各个部件通过总线来传递信息。总线主要分为数据总线、地址总线和控制总线。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>数据总线(Data Bus)</b></span><span class="inline-wrap"> 用于传送数据信息。它既可以把<span class="jill"></span>CPU<span class="jill"></span>的数据传送到存储器或<span class="jill"></span>I/O<span class="jill"></span>接口等其它部件，也可以将其它部件的数据传送到<span class="jill"></span>CPU。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>地址总线(Address Bus)</b></span><span class="inline-wrap"> 是专门用来传送地址的，地址只能从<span class="jill"></span>CPU<span class="jill"></span>传向外部存储器或<span class="jill"></span>I/O<span class="jill"></span>端口。地址总线的位数，决定了地址空间的大小，例如<span class="jill"></span>32<span class="jill"></span>位的地址总线，可以提供由<span class="jill"></span>2^32<span class="jill"></span>个地址所组成的地址空间，如果把地址空间全部分配给内存，那么一共可以表示<span class="jill"></span>2^32÷1024^3=4G<span class="jill"></span>的内存。</span></div></div><blockquote class="wolai-block"><span class="inline-wrap">ps：2^32-1<span class="jill"></span>指的是<span class="jill"></span>32<span class="jill"></span>位能表示的最大无符号数，2^32<span class="jill"></span>指的是<span class="jill"></span>32<span class="jill"></span>位有多少总排列组合的方式</span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>控制总线(Control Bus)</b></span><span class="inline-wrap"> 用来传送控制信号和时序信号。控制信号中，有的是微处理器送往存储器和<span class="jill"></span>I/O<span class="jill"></span>接口电路的，如读/写信号，片选信号、中断响应信号等；也有是其它部件反馈给<span class="jill"></span>CPU<span class="jill"></span>的，比如：中断申请信号、复位信号、总线请求信号、设备就绪信号等。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">内存</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">程序的运行本质就是<span class="jill"></span>CPU<span class="jill"></span>不停的执行指令，而指令存储在内存中，从物理上来说， 内存是由一组动态随机存取存储器(DRAM)芯片组成的。 从逻辑上来说，内存是一个线性的字节数组， 每个字节都有其唯一的地址(数组索引)， 这些地址是从零开始的。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">CPU</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">对于一个计算机来讲，最核心的就是</span><span class="inline-wrap"><b>CPU</b></span><span class="inline-wrap">（Central Processing Unit，中央处理器）。它包括三个部分，</span><span class="inline-wrap"><b>运算单元</b></span><span class="inline-wrap">、</span><span class="inline-wrap"><b>数据单元</b></span><span class="inline-wrap">和</span><span class="inline-wrap"><b>控制单元</b></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/cpu%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%861.jpeg" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">进程一旦运行，就会有独立的内存空间，进程之间互相隔离，比如图中两个进程 A 和 B。程序会分别加载到进程 A 和进程 B 的内存空间里面，形成各自的代码段。当然真实情况肯定比我说的要复杂的多，进程的内存除了简单的区分代码段和数据段，还会分的更细。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">CPU 的控制单元里面，有一个</span><span class="inline-wrap"><b>指令指针寄存器</b></span><span class="inline-wrap">，它里面存放的是下一条指令在内存中的地址。控制单元会不停地将代码段的指令拿进来，先放入</span><span class="inline-wrap"><b>指令寄存器</b></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">指令分为两部分，一部分是做什么操作；一部分是操作哪些数据。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">要执行这条指令，就要把第一部分交给运算单元，第二部分交给数据单元。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">数据单元根据数据的地址，从数据段里读到数据寄存器里，就可以参与运算了。运算单元做完运算，产生的结果会暂存在数据单元的数据寄存器里。最终，会有指令将数据写回内存中的数据段。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>8086 处理器</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">以<span class="jill"></span>8086 处理器为例，虽然它已经很老了，但是咱们现在操作系统中的很多特性都和它有关。</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/8086cpu%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.jpeg" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>数据单元</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">8086 处理器内部有<span class="jill"></span>8<span class="jill"></span>个通用寄存器，这些寄存器主要用于在计算过程中暂存数据。
4<span class="jill"></span>个数据寄存器：AX、BX、CX、DX
2<span class="jill"></span>个地址指针寄存器：SP(stack pointer),BP(base pointer)
2<span class="jill"></span>个变址寄存器：SI(source index),DI(destination index)</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">AX、BX、CX、DX 可以分成两个 8 位的寄存器来使用，分别是 AH、AL、BH、BL、CH、CL、DH、DL，其中 H 就是 High（高位），L 就是 Low（低位）的意思。这样，比较长的数据也能暂存，比较短的数据也能暂存。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>控制单元</b></span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">CS 就是代码段寄存器（Code Segment Register）；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">IP 是指令指针寄存器（Instruction Pointer Register)，CPU 会根据它和代码寄存器来计算指令所在的地址；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">DS 是数据段的寄存器（Data Segment Register）；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ES 是扩展段寄存器（Extra Segment Register）段寄存器不够用的时候，可以考虑使用<span class="jill"></span>ES；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">SS 是栈段寄存器（Stack Segment Register）；</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>实模式</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">上面讲到，CPU 会根据<span class="jill"></span>CS<span class="jill"></span>和<span class="jill"></span>IP<span class="jill"></span>来计算指令所在的地址，为什么什么要这么做呢？</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">8086<span class="jill"></span>地址总线的宽度是<span class="jill"></span>20<span class="jill"></span>位，可能当时<span class="jill"></span>Intel<span class="jill"></span>认为，16<span class="jill"></span>位的地址总线（寻址能力<span class="jill"></span>64KB）是不够竞争力的，然后又因为成本问题，</span><span class="inline-wrap"><b>所以最终设计为<span class="jill"></span>20<span class="jill"></span>位</b></span><span class="inline-wrap">。但是<span class="jill"></span>16<span class="jill"></span>位的寄存器是无法完全利用<span class="jill"></span>20<span class="jill"></span>位的地址总线的。天才的设计师们想到了一个解决办法，那就是使用两个寄存器，其中一个寄存器的值左移<span class="jill"></span>4<span class="jill"></span>位（二进制），然后与另一个寄存器的值相加，那么就能完全利用<span class="jill"></span>20<span class="jill"></span>位的地址总线了。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>这就是后来被称为实模式下的寻址方式。</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>PS</b></span><span class="inline-wrap">：段的大小不是完全一样，例如当<span class="jill"></span>CS<span class="jill"></span>的值是<span class="jill"></span>FFFF<span class="jill"></span>时，IP<span class="jill"></span>就只剩下<span class="jill"></span>4<span class="jill"></span>个位可以用了，这时候段的大小是<span class="jill"></span>2^4=16Byte，当<span class="jill"></span>CS<span class="jill"></span>的值位于[0~F]000<span class="jill"></span>时，IP<span class="jill"></span>就能完全利用<span class="jill"></span>16<span class="jill"></span>位，这时候段的大小是<span class="jill"></span>2^</span><span class="inline-wrap">16</span><span class="inline-wrap">=64Kb</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://www.jianshu.com/p/d1721bd48c88"><span>CS<span class="jill"></span>与<span class="jill"></span>IP<span class="jill"></span>例子</span></a></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://www.cnblogs.com/x54256/p/8082595.html"><span>DS<span class="jill"></span>与内存数据访问</span></a></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>32 位处理器</b></span></div></div><div class="wolai-block wolai-center"><figure><img src="media/32%E4%BD%8Dcpu%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.jpeg" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">PS: E<span class="jill"></span>是<span class="jill"></span>Extension<span class="jill"></span>扩展的意思。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">到了<span class="jill"></span>32<span class="jill"></span>位处理器，原来的寻址方式已经无法完全利用<span class="jill"></span>32<span class="jill"></span>位的地址总线了，一种新的寻址方式也因此诞生。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">虽然段寄存器还是<span class="jill"></span>16<span class="jill"></span>位，但是它们的含义已经发生了变化，此时的它们被称为段选择子。内存中存储着一个叫</span><span class="inline-wrap"><b>全局描述符表</b></span><span class="inline-wrap">的数据结构，里面记录了多个</span><span class="inline-wrap"><b>段描述符</b></span><span class="inline-wrap">，一个段描述符描述了一个段的特征和属性，例如段的起始位置、段的大小以及访问权限等等。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>通俗点，把全局描述符当做由段描述符组成的数组，然后段选择子就是用来获取特定段描述符的索引</b></span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">CPU<span class="jill"></span>里有一个<span class="jill"></span>gdtr<span class="jill"></span>寄存器，用来存放全局描述符在内存中的地址</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">为了快速拿到段起始地址，段寄存器会从内存中拿到段描述符放入 CPU 的描述符高速缓存器中。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://blog.csdn.net/bfboys/article/details/52396314"><span>段描述符</span></a></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://blog.csdn.net/qq_37924084/article/details/78360003"><span>分段和分页机制</span></a></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://blog.csdn.net/Alatebloomer/article/details/79841088"><span>地址空间与内存分配</span></a></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">计算机启动过程</span></h2><h3 class="wolai-block"><span class="inline-wrap">BIOS</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">计算机的本质就是<span class="jill"></span>CPU<span class="jill"></span>不断的从内存中读取指令并执行</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">计算机刚启动时会处于一种叫实模式的状态下，这时<span class="jill"></span>CPU<span class="jill"></span>只有<span class="jill"></span>20<span class="jill"></span>位的寻址能力，拥有（0x00000～0xFFFFF）的地址空间，1M(2^20Byte)的内存</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">下图是实模式下地址空间的划分</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">0x00000~0x9FFFF:基本内存</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">0xA0000~0xBFFFF:图形视频缓存区</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">0xC0000~0xFFFFF:BIOS</span></li></ul><div class="wolai-block wolai-center"><figure><img src="media/x86%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.jpg" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">计算机启动时，CPU<span class="jill"></span>会从规定的内存地址读取指令，这是<span class="jill"></span>CPU<span class="jill"></span>厂商设置好的，这个地址就是</span><span class="inline-wrap"><code>0xFFFF0</code></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>0xFFFF0</code></span><span class="inline-wrap">是<span class="jill"></span>BIOS<span class="jill"></span>程序的入口地址，也就是说接下来<span class="jill"></span>CPU<span class="jill"></span>会执行<span class="jill"></span>BIOS<span class="jill"></span>程序，现在问题来了，BIOS<span class="jill"></span>程序会做些什么呢？</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">实模式下内存的下边界就是 </span><span class="inline-wrap"><code>0xFFFFF</code></span><span class="inline-wrap">，BIOS<span class="jill"></span>程序的入口地址</span><span class="inline-wrap"><code>0xFFFF0</code></span><span class="inline-wrap">，也就是只剩下 16 个字节的空间可以写代码了，这够干啥的呢？</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果你有心的话应该能猜出，入口地址处可能是个跳转指令，跳到一个更大范围的空间去执行自己的任务。没错就是这样，</span><span class="inline-wrap"><code>0xFFFF0</code></span><span class="inline-wrap"> 处存储的机器指令，翻译成汇编语言是 </span><span class="inline-wrap"><code>jmp far f000:e05b</code></span><span class="inline-wrap"> 意思是跳转到物理地址 </span><span class="inline-wrap"><code>0xfe05b</code></span><span class="inline-wrap"> 处开始执行</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">地址 </span><span class="inline-wrap"><code>0xfe05b</code></span><span class="inline-wrap"> 处开始，便是 BIOS 真正发挥作用的代码了，这块代码会检测一些外设信息，并初始化好硬件，建立中断向量表并填写中断例程。这里的部分不要展开，这只是一段写死的程序而已，而且对理解开机启动过程无帮助，我们看后面精彩的部分，也就是 BIOS 的最后一项工作：</span><span class="inline-wrap"><b>加载启动区</b></span><span class="inline-wrap">。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">加载启动区</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">在计算机领域，加载指的是</span><span class="inline-wrap"><b>把某设备上（比如硬盘）的程序复制到内存中的过程</b></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">加载启动区这个过程，翻译过来就是，</span><span class="inline-wrap"><b>BIOS 程序把启动区的内容复制到了内存中的某个区域</b></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">好了，问题又来了，启动区是哪里？被复制到了内存的哪个位置？然后呢？</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">什么是启动区呢？即使你不知道，你也应该能够猜到，一定是符合某种特征的一块区域，于是人们把它就叫做启动区了，那要符合什么特征呢？先不急，不知道你有没有过设置 BIOS 启动顺序的经历，通常有 U 盘启动、硬盘启动、软盘启动、光盘启动等等，</span><span class="inline-wrap"><b>BIOS 会按照顺序，读取这些启动盘中位于 0 盘 0 道 1 扇区的内容</b></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">这 0 盘 0 道 1 扇区的内容一共有 512 个字节，</span><span class="inline-wrap"><b>如果末尾的两个字节分别是 </b></span><span class="inline-wrap"><b><code>0x55</code></b></span><span class="inline-wrap"><b> 和 </b></span><span class="inline-wrap"><b><code>0xaa</code></b></span><span class="inline-wrap"><b>，那么 BIOS 就会认为它是个启动区</b></span><span class="inline-wrap">。如果不是，那么按顺序继续向下个设备中寻找位于 0 盘 0 道 1 扇区的内容。如果最后发现都没找到符合条件的，那直接报出一个无启动区的错误。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">BIOS 找到了这个启动区之后干嘛呢？哦，前面说过了是加载，</span><span class="inline-wrap"><b>就是把这 512 个字节的内容，一个比特都不少的全部复制到内存的 0x7c00 这个位置</b></span><span class="inline-wrap">。怎么复制的？当然是指令啦。哪些指令呢？这里我只能简单说指令集中是有 in 和 out 的，用来将外设中的数据复制到内存，或者将内存中的数据复制到外设，用这两个指令，以及外设给我们提供的读取方式，就能做到这一点啦。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">启动区内容此时已经被 BIOS 程序复制到了内存的 </span><span class="inline-wrap"><code>0x7c00</code></span><span class="inline-wrap"> 这个位置，然后呢？这个其实也不难猜测，启动区的内容就是我们自己写的代码了，复制到这里之后，就开始执行呗，之后我们的程序就接管了接下来的流程，BIOS 的使命也就结束啦。所以复制完之后，接下来应该是一个跳转指令吧！没错，正是这样，PC 寄存器的值变为 </span><span class="inline-wrap"><code>0x7c00</code></span><span class="inline-wrap">，指令开始从这里执行。</span></div></div><blockquote class="wolai-block"><span class="inline-wrap">为什么非要是 </span><span class="inline-wrap"><code>0x7c00</code></span><span class="inline-wrap"> 呢？好问题，当然答案也很简单，那就是人家 BIOS 开发团队就是这样定的，之后也不好改了，不然不兼容。</span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap">当然了，启动区<span class="jill"></span>512 个字节，是做不了什么的，所以它的作用也是加载操作系统内核，并跳转到加载处</span></div></div><h3 class="wolai-block"><span class="inline-wrap">总结</span></h3><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">按下开机键，CPU 将 PC 寄存器的值强制初始化为 </span><span class="inline-wrap"><code>0xffff0</code></span><span class="inline-wrap">，这个位置是 BIOS 程序的入口地址（一跳）</span></li><li><div class="marker"></div><span class="inline-wrap">该入口地址处是一个跳转指令，跳转到 </span><span class="inline-wrap"><code>0xfe05b</code></span><span class="inline-wrap"> 位置，开始执行（二跳）</span></li><li><div class="marker"></div><span class="inline-wrap">执行了一些硬件检测工作后，最后一步将启动区内容加载到内存 </span><span class="inline-wrap"><code>0x7c00</code></span><span class="inline-wrap">，并跳转到这里（三跳）</span></li><li><div class="marker"></div><span class="inline-wrap">启动区代码主要是加载操作系统内核，并跳转到加载处（四跳）</span></li></ol><h2 class="wolai-block"><span class="inline-wrap">在屏幕上显示文字</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">传统上，显卡有文本模式和图形模式两种工作模式，文本模式专门用于显示字符，接下来我们只讲的文本模式的工作原理。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">计算机是如何让显示器显示文字的呢？</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">为了显示文字，通常需要两种硬件，一是显卡，二是显示器。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">显卡的职责是为显示器提供内容并控制显示器的显示模式和状态</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">显示器的职责是将内容以视觉可见的方式呈现在屏幕上</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">显卡控制显示器的最小单位是像素，一个像素对应着屏幕上的一个点，通过控制每个像素的明亮和颜色，我们就能让这大量的像素形成文字和美丽的图像</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">问题来了，如何控制这些像素呢？</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">显卡都有自己的存储器，简称显存，要显示的内容都预先写入显存。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">为了方便，工程师们想出了一个办法，那就是字符编码，每个字符用一个数字与之对应，例如字符&quot;L&quot;用数字<span class="jill"></span>0x4C<span class="jill"></span>来表示，那么只要在显存上写入<span class="jill"></span>0x4C，那么显示器就会显示字符&quot;L&quot;</span></div></div><blockquote class="wolai-block"><span class="inline-wrap">由于历史的原因，所有个人计算机上使用的显卡，在通电自检之后都会把自己初始化到<span class="jill"></span>80x25<span class="jill"></span>的文本模式。在这种模式下，屏幕上可以显示<span class="jill"></span>25<span class="jill"></span>行，每行<span class="jill"></span>80<span class="jill"></span>个字符，每屏总共<span class="jill"></span>2000<span class="jill"></span>个字符。</span></blockquote><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="6502 Assembly" class="marker"></div><pre><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span>mbr<span class="token punctuation">.</span><span class="token property-access">asm</span>
<span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token constant">BIOS</span>把启动区加载到内存的该位置，所以需设置地址偏移量
section mbr vstart<span class="token operator">=</span><span class="token number">0x7c00</span>
                                        
<span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span>卷屏中断，目的是清屏
mov ax<span class="token punctuation">,</span><span class="token number">0x0600</span>
mov bx<span class="token punctuation">,</span><span class="token number">0x0700</span>
mov cx<span class="token punctuation">,</span><span class="token number">0</span>
mov dx<span class="token punctuation">,</span><span class="token number">0x184f</span>
int <span class="token number">0x10</span>

<span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span>直接往显存中写数据
mov ax<span class="token punctuation">,</span><span class="token number">0xb800</span>
mov gs<span class="token punctuation">,</span>ax
<span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span>用两个字节表示一个字符，第一个字节表示字符，第二个字节表示字符的颜色
mov byte <span class="token punctuation">[</span>gs<span class="token operator">:</span><span class="token number">0x00</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'h'</span>
mov byte <span class="token punctuation">[</span>gs<span class="token operator">:</span><span class="token number">0x02</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'e'</span>
mov byte <span class="token punctuation">[</span>gs<span class="token operator">:</span><span class="token number">0x04</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'l'</span>
mov byte <span class="token punctuation">[</span>gs<span class="token operator">:</span><span class="token number">0x06</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'l'</span>
mov byte <span class="token punctuation">[</span>gs<span class="token operator">:</span><span class="token number">0x08</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'o'</span>

<span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token number">512</span>字节的最后两字节是启动区标识
times <span class="token number">510</span><span class="token operator">-</span><span class="token punctuation">(</span>$<span class="token operator">-</span>$$<span class="token punctuation">)</span> db <span class="token number">0</span>
db <span class="token number">0x55</span><span class="token punctuation">,</span><span class="token number">0xaa</span></pre></div></code-block><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="PowerShell" class="marker"></div><pre><span class="token comment"># 把汇编程序编译成二进制文件</span>
nasm <span class="token operator">-</span>f bin mbr<span class="token punctuation">.</span>asm <span class="token operator">-</span>o mbr<span class="token punctuation">.</span>bin
<span class="token comment"># 创建一个容量是512x2字节的磁盘</span>
dd <span class="token keyword">if</span>=<span class="token operator">/</span>dev<span class="token operator">/</span>zero of=mbr<span class="token punctuation">.</span>img count=2
<span class="token comment"># 把内容写入磁盘</span>
dd <span class="token keyword">if</span>=mbr<span class="token punctuation">.</span>bin of=mbr<span class="token punctuation">.</span>img conv=notrunc
<span class="token comment"># 启动虚拟机</span>
qemu<span class="token operator">-</span>system<span class="token operator">-</span>x86_64 mbr<span class="token punctuation">.</span>img </pre></div></code-block><h2 class="wolai-block"><span class="inline-wrap">读写硬盘</span></h2><h3 class="wolai-block"><span class="inline-wrap">磁盘的结构</span></h3><div class="wolai-block wolai-center"><figure><img src="media/%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84.png" style="width: 690px"/></figure></div><div class="wolai-block wolai-center"><figure><img src="media/%E7%9B%98%E7%89%87%E7%9A%84%E7%BB%93%E6%9E%84.png" style="width: 554px"/></figure></div><div class="wolai-block wolai-center"><figure><img src="media/%E7%A3%81%E7%9B%98-%E6%9F%B1%E9%9D%A2.png" style="width: 569px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">关键：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">确定一个磁头、扇区、柱面，就确定了一个 512 字节大小的区域</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">硬盘的容量 = 柱面数 × 磁头数 × 扇区数 × 512Byte。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://www.cnblogs.com/jswang/p/9071847.html"><span>硬盘基本知识</span></a></span></div></div><div class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>
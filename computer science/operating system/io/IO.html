<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/wolai.css"/><title>IO - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div data-symbol="🪶" class="icon"></div></div><div data-title="IO" class="main-title"></div></div></header><article><div class="wolai-bookmark wolai-block"><a href="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/13_IOSystems.html">Operating Systems: I/O Systems</a><div class="info-box"><div class="text-pane"><div data-title="Operating Systems: I/O Systems"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://www.cs.uic.edu/favicon.ico&quot;)"></div><div data-hostname="www.cs.uic.edu"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-task-block"><input type="checkbox" disabled=""/><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="fill: currentColor; fill-rule: evenodd;"><path clip-rule="evenodd" d="M16.6 6.2H7.4a1.2 1.2 0 00-1.2 1.2v9.2a1.2 1.2 0 001.2 1.2h9.2a1.2 1.2 0 001.2-1.2V7.4a1.2 1.2 0 00-1.2-1.2zM7.4 5A2.4 2.4 0 005 7.4v9.2A2.4 2.4 0 007.4 19h9.2a2.4 2.4 0 002.4-2.4V7.4A2.4 2.4 0 0016.6 5H7.4z"></path></svg></div><span class="wrapper"><span class="inline-wrap">CPU<span class="jill"></span>与<span class="jill"></span>IO<span class="jill"></span>设备进行交互已经有了基本的了解，最好可以写下笔记</span></span></div><div class="wolai-block wolai-task-block"><input type="checkbox" disabled=""/><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="fill: currentColor; fill-rule: evenodd;"><path clip-rule="evenodd" d="M16.6 6.2H7.4a1.2 1.2 0 00-1.2 1.2v9.2a1.2 1.2 0 001.2 1.2h9.2a1.2 1.2 0 001.2-1.2V7.4a1.2 1.2 0 00-1.2-1.2zM7.4 5A2.4 2.4 0 005 7.4v9.2A2.4 2.4 0 007.4 19h9.2a2.4 2.4 0 002.4-2.4V7.4A2.4 2.4 0 0016.6 5H7.4z"></path></svg></div><span class="wrapper"><span class="inline-wrap">了解操作系统提供的软件<span class="jill"></span>IO<span class="jill"></span>接口</span></span></div><div class="wolai-block wolai-task-block"><input type="checkbox" disabled=""/><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="fill: currentColor; fill-rule: evenodd;"><path clip-rule="evenodd" d="M16.6 6.2H7.4a1.2 1.2 0 00-1.2 1.2v9.2a1.2 1.2 0 001.2 1.2h9.2a1.2 1.2 0 001.2-1.2V7.4a1.2 1.2 0 00-1.2-1.2zM7.4 5A2.4 2.4 0 005 7.4v9.2A2.4 2.4 0 007.4 19h9.2a2.4 2.4 0 002.4-2.4V7.4A2.4 2.4 0 0016.6 5H7.4z"></path></svg></div><span class="wrapper"><span class="inline-wrap">了解<span class="jill"></span>C<span class="jill"></span>语言提供的软件<span class="jill"></span>IO<span class="jill"></span>接口</span></span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">数据读写的过程</span></h2><div class="wolai-block wolai-text"><div><span class="red inline-wrap"><b>读取数据</b></span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">应用程序向内核发起 </span><span class="inline-wrap"><code>read</code></span><span class="inline-wrap">调用，CPU<span class="jill"></span>由用户态转变成内核态</span></li><li><div class="marker"></div><span class="inline-wrap">内核通知存储设备读取数据，存储设备读取到数据后，通过<span class="jill"></span>DMA<span class="jill"></span>把数据写入到内核的数据缓冲区</span></li><li><div class="marker"></div><span class="inline-wrap">内核把数据缓冲区的数据复制到应用程序的数据缓冲区，CPU<span class="jill"></span>由内核态转换为用户态</span></li></ol><div class="wolai-block wolai-text"><div><span class="red inline-wrap"><b>写入数据</b></span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">应用程序向内核发起</span><span class="inline-wrap"><code>wirte</code></span><span class="inline-wrap">调用，CPU<span class="jill"></span>由用户态转变成内核态</span></li><li><div class="marker"></div><span class="inline-wrap">应用程序数据缓冲区中的数据被复制到内核的数据缓冲区</span></li><li><div class="marker"></div><span class="inline-wrap">内核把数据缓冲区中的数据写入到存储设备，完成后<span class="jill"></span>CPU<span class="jill"></span>由内核态转换为用户态</span></li></ol><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/syscall-read.png" style="width: 760px"/></figure></div><h2 class="wolai-block"><span class="inline-wrap">Linux<span class="jill"></span>五种<span class="jill"></span>IO<span class="jill"></span>模型</span></h2><blockquote class="wolai-block"><span class="inline-wrap">​Linux<span class="jill"></span>和<span class="jill"></span>Unix<span class="jill"></span>的一个基本理念就是，一切事物皆“文件”，我们通过文件描述符（file descriptor）来指向“文件”。</span></blockquote><blockquote class="wolai-block"><span class="inline-wrap">同步和异步，例如你要发起并处理<span class="jill"></span>100<span class="jill"></span>个请求，同步的话发起一个请求处理一个响应，异步的话尽可能发起请求，接收到响应就处理响应，从而缩短等待响应的时间</span></blockquote><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">阻塞<span class="jill"></span>I/O<span class="jill"></span>模型</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">调用<span class="jill"></span>read<span class="jill"></span>后，进程一直阻塞，直至数据到达进程的内存空间。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image.png" style="width: 537px"/></figure></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/blocking-io.png" style="width: 523px"/></figure></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">非阻塞<span class="jill"></span>I/O<span class="jill"></span>模型</span></summary><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/no-blocking-io.png" style="width: 533px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">调用<span class="jill"></span>read，如果数据已经从设备拷贝到内核缓冲区，返回成功，否则返回-1。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_1.png" style="width: 516px"/></figure></div><aside class="bg-cultured wolai-block"><div data-symbol="🚀" class="icon"></div><span class="inline-wrap">这里的<span class="jill"></span>read<span class="jill"></span>不是指<span class="jill"></span>linux<span class="jill"></span>的<span class="jill"></span>read<span class="jill"></span>函数，不要跟<span class="jill"></span>read<span class="jill"></span>函数搞混淆了</span></aside></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">异步<span class="jill"></span>I/O<span class="jill"></span>模型</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">调用<span class="jill"></span>read，直接返回，当数据到达用户空间后，内核会调用<span class="jill"></span>read<span class="jill"></span>时指定的回调函数</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_2.png" style="width: 542px"/></figure></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/asynchronous-io.png" style="width: 523px"/></figure></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">信号驱动<span class="jill"></span>I/O<span class="jill"></span>模型(很少用)</span></summary><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/signal-driven-io.png" style="width: 531px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">调用<span class="jill"></span>read，立即返回，如果数据已经从设备拷贝到内核缓冲区，内核发送信号通知进程</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_3.png" style="width: 558px"/></figure></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">I/O<span class="jill"></span>多路复用模型</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">上面讲的都是针对单个文件描述符的操作，如果要处理多个文件描述符，要进行多次系统调用。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">为了改进这个问题，系统提供了<span class="jill"></span>I/O<span class="jill"></span>多路复用功能。可以同时监控多个文件描述符。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">线程会被阻塞，直至指定数量的文件描述符准备好。然后线程再处理准备的文件描述符。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_4.png" style="width: 523px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">多路复用技术原本指的是，在通信方面，多种信号或数据（从宏观上看）交织在一起，使用同一条传输通道进行传输， 这里的重点就是处理好“混合”和“分离”，对于不同的信号或数据，有不同的处理方法。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/io-multiplexing.png" style="width: 532px"/></figure></div><div class="wolai-bookmark wolai-block"><a href="https://imageslr.com/2020/02/27/select-poll-epoll.html">📔【操作系统】I/O 多路复用，select / poll / epoll 详解</a><div class="info-box"><div class="text-pane"><div data-title="📔【操作系统】I/O 多路复用，select / poll / epoll 详解"></div><div data-desc="更多面试题总结请看：🗂【面试题】技术面试题汇总"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://imageslr.com/favicon.ico&quot;)"></div><div data-hostname="imageslr.com"></div></div></div><div class="preview-pane"></div></div></div></details><h2 class="wolai-block"><span class="inline-wrap">select、poll、epoll</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Linux<span class="jill"></span>提供了 </span><span class="inline-wrap"><code>select</code></span><span class="inline-wrap">、</span><span class="inline-wrap"><code>poll</code></span><span class="inline-wrap">、</span><span class="inline-wrap"><code>epoll</code></span><span class="inline-wrap"> 这三个支持 I/O 多路复用的系统调用。</span></div></div><div class="wolai-block wolai-text"><div><span class="red inline-wrap"><b>select</b></span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre><span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> nfds<span class="token punctuation">,</span> 
           fd_set <span class="token operator">*</span>restrict readfds<span class="token punctuation">,</span>
           fd_set <span class="token operator">*</span>restrict writefds<span class="token punctuation">,</span> 
           fd_set <span class="token operator">*</span>restrict exceptfds<span class="token punctuation">,</span>
           <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>restrict timeout<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">每次调用</span><span class="inline-wrap"><code>select</code></span><span class="inline-wrap">都需要将参数中的 </span><span class="inline-wrap"><code>fd_set</code></span><span class="inline-wrap"> 从用户空间拷贝到内核空间</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">内核需要遍历传递进来的所有 </span><span class="inline-wrap"><code>fd_set</code></span><span class="inline-wrap"> 的每一位，不管它们是否就绪</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">能同时够监听的文件描述符数量太少，一般是<span class="jill"></span>1024</span></div></div><div class="wolai-block wolai-text"><div><span class="red inline-wrap"><b>poll</b></span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre><span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> <span class="token class-name">nfds_t</span> nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token punctuation">{</span>
   <span class="token keyword">int</span>   fd<span class="token punctuation">;</span>         <span class="token comment">/* file descriptor */</span>
   <span class="token keyword">short</span> events<span class="token punctuation">;</span>     <span class="token comment">/* requested events */</span>
   <span class="token keyword">short</span> revents<span class="token punctuation">;</span>    <span class="token comment">/* returned events */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">poll 和 select 几乎没有区别。poll 在用户态通过</span><span class="inline-wrap"><b>数组</b></span><span class="inline-wrap">方式</span><span class="inline-wrap"><b>传递</b></span><span class="inline-wrap">文件描述符，在内核会转为</span><span class="inline-wrap"><b>链表</b></span><span class="inline-wrap">方式</span><span class="inline-wrap"><b>存储</b></span><span class="inline-wrap">，没有最大数量的限制。从性能开销上看，poll 和 select 的差别不大</span></div></div><div class="wolai-block wolai-text"><div><span class="red inline-wrap"><b>epoll</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">select、poll 模型都只使用一个函数，而 epoll 模型使用三个函数：epoll_create、epoll_ctl 和 epoll_wait。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>epoll_create</code></span><span class="inline-wrap">：创建<span class="jill"></span>epoll<span class="jill"></span>实例</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>epoll_ctl</code></span><span class="inline-wrap">：将文件描述符 </span><span class="inline-wrap"><code>fd</code></span><span class="inline-wrap"> 添加到 </span><span class="inline-wrap"><code>epoll</code></span><span class="inline-wrap"> 实例的监听列表(红黑树)，当 </span><span class="inline-wrap"><code>fd</code></span><span class="inline-wrap"> 发生相应事件时， 该</span><span class="inline-wrap"><code>fd</code></span><span class="inline-wrap"> 会被添加到 </span><span class="inline-wrap"><code>epoll</code></span><span class="inline-wrap"> 实例的就绪队列(链表)</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// epoll_create 会创建一个epoll实例，同时返回一个引用该实例的文件描述符epfd</span>
<span class="token comment">// 其他 API 如 epoll_ctl、epoll_wait 会使用这个文件描述符来操作相应的 epoll 实例</span></pre></div></code-block><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// epoll_ctl 会监听文件描述符 fd 上发生的 event 事件</span>
<span class="token comment">// epfd 即 epoll_create 返回的文件描述符，指向一个 epoll 实例</span>
<span class="token comment">// op 表示要对 fd 执行的操作，有以下几种：</span>
<span class="token comment">// - EPOLL_CTL_ADD：为 fd 添加一个监听事件 event</span>
<span class="token comment">// - EPOLL_CTL_MOD：</span>
<span class="token comment">// - EPOLL_CTL_DEL：删除 fd 的所有监听事件，这种情况下 event 参数没用</span>
<span class="token comment">// fd 表示要监听的目标文件描述符</span>
<span class="token comment">// event 表示要监听的事件（可读、可写、发送错误…）</span>
<span class="token comment">// 返回值 0 或 -1，表示上述操作成功与否</span></pre></div></code-block><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 这是 epoll 模型的主要函数，功能相当于 select</span>
<span class="token comment">// epfd 即 epoll_create 返回的文件描述符，指向一个 epoll 实例</span>
<span class="token comment">// events 是一个数组，保存就绪状态的文件描述符，其空间由调用者负责申请</span>
<span class="token comment">// maxevents 指定 events 的大小</span>
<span class="token comment">// timeout 最长阻塞时间，如果 timeout 设为 -1，则 epoll_wait 会一直阻塞，直到有足够数量的文件描述符就绪</span>
<span class="token comment">// 返回值表示 events 中存储的就绪描述符个数，最大不超过 maxevents</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="red inline-wrap"><b>简而言之，epoll 有以下几个特点：</b></span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">每个</span><span class="inline-wrap"><b>文件描述符</b></span><span class="inline-wrap">只需在添加时传入一次</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">使用</span><span class="inline-wrap"><b>红黑树</b></span><span class="inline-wrap">存储文件描述符集合</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">使用</span><span class="inline-wrap"><b>链表</b></span><span class="inline-wrap">存储就绪的文件描述符</span></li></ul><div class="wolai-bookmark wolai-block"><a href="https://imageslr.com/2020/02/27/select-poll-epoll.html">📔【操作系统】I/O 多路复用，select / poll / epoll 详解</a><div class="info-box"><div class="text-pane"><div data-title="📔【操作系统】I/O 多路复用，select / poll / epoll 详解"></div><div data-desc="更多面试题总结请看：🗂【面试题】技术面试题汇总"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://imageslr.com/favicon.ico&quot;)"></div><div data-hostname="imageslr.com"></div></div></div><div class="preview-pane"></div></div></div><h3 class="wolai-block"><span class="inline-wrap">零拷贝</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">Zero Copy </span><span class="inline-wrap">I</span><span class="inline-wrap">: User Perspective</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Zero Copy II: Kernel Perspective</span></div></div><hr class="wolai-block"/><div class="wolai-block wolai-text"><div><span class="red inline-wrap"><b>用户态、内核态、用户空间、内核空间</b></span></div></div><div class="wolai-bookmark wolai-block"><a href="https://segmentfault.com/a/1190000039774784">https://segmentfault.com/a/1190000039774784</a><div class="info-box"><div class="text-pane"><div data-title="segmentfault.com"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://segmentfault.com/favicon.ico&quot;)"></div><div data-hostname="segmentfault.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">操作系统把内存空间分成两部分，一部分是用户空间、一部分是内核空间。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">以为<span class="jill"></span>32<span class="jill"></span>位<span class="jill"></span>Linux<span class="jill"></span>系统为例，1~3GB<span class="jill"></span>为用户空间，3~4GB<span class="jill"></span>为内核空间。进程的用户空间是相互独立的，而内核空间是公用的。</span><span class="inline-wrap">进程切换时，用户空间切换，内核空间不变</span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="red inline-wrap"><b>DMA</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Direct memory access (直接内存访问)，操作系统允许某些硬件系统无需经过<span class="jill"></span>CPU<span class="jill"></span>处理，直接访问物理内存。如果没有<span class="jill"></span>DMA，把数据从存储设备拷贝到内核需要一直占用<span class="jill"></span>CPU。使用<span class="jill"></span>DMA，数据拷贝时<span class="jill"></span>CPU<span class="jill"></span>可以干别的事情，数据拷贝完毕后，DMA<span class="jill"></span>控制器发送中断信号给<span class="jill"></span>CPU，告诉它数据拷贝完毕，从而提高<span class="jill"></span>CPU<span class="jill"></span>的利用率。</span></div></div><div class="wolai-block wolai-text"><div><span class="red inline-wrap"><b>零拷贝</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">有些时候，我们的程序需要把一个文件原封不动的从一个地方拷贝到另一个地方。在<span class="jill"></span>Java<span class="jill"></span>中，实现该需求的常用方法就是使用</span><span class="inline-wrap"><code>InputStream</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>OutputStream</code></span><span class="inline-wrap">。然后这种方法对性能不怎么友好，从上面数据读写过程我们知道，一次读写过程需要经历<span class="jill"></span>4<span class="jill"></span>次状态转换和<span class="jill"></span>4<span class="jill"></span>次数据复制</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">但是其实对于数据拷贝来说，有<span class="jill"></span>2<span class="jill"></span>次状态转换和<span class="jill"></span>2<span class="jill"></span>次数据复制是多余的，零拷贝技术可以让我们减少这不必要的<span class="jill"></span>2<span class="jill"></span>次状态转换和<span class="jill"></span>2<span class="jill"></span>次复制。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/zero-copy.png" style="width: 760px"/></figure></div><div class="wolai-bookmark wolai-block"><a href="https://mp.weixin.qq.com/s/TEUrcD4c_8Aw7bzTXr83kw">Linux I/O 原理和 Zero-copy 技术全面揭秘</a><div class="info-box"><div class="text-pane"><div data-title="Linux I/O 原理和 Zero-copy 技术全面揭秘"></div><div data-desc="全网最详尽的 Linux I/O 和零拷贝技术的深度解析文章。"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://res.wx.qq.com/a/wx_fed/assets/res/MjliNWVm.svg&quot;)"></div><div data-hostname="mp.weixin.qq.com"></div></div></div><div class="preview-pane" style="background-image: url(http://mmbiz.qpic.cn/mmbiz_jpg/dZbLsg7Jh63y0pvS9wGyBIMyKlDZ5jeDKic10EHjU4AhOUDpZDiaic7TRaOM1zgLjAa5T3wW7nibPluCQxK9ia51iaDw/0?wx_fmt=jpeg)"></div></div></div><h3 class="wolai-block"><span class="inline-wrap">内存映射</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">零拷贝也有它的缺点，就是应用程序无法对数据进行修改，那么我们就真的只能用原始方法，把数据拷贝到内核，再拷贝到用户空间，然后再对数据进行修改，然后原路返回吗？不不不，还有一种方法，那就是内存映射。</span></div></div><hr class="wolai-block"/><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div></div></div><div class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE.html"><span>直接内存访问</span></a></div></article><footer></footer></body></html>
<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>TCP - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body class="font-kai"><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="TCP" class="main-title"></div></div></header><article><h2 class="wolai-block"><span class="inline-wrap">TCP<span class="jill"></span>简介</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Transmission Control Protocol 传输控制协议，是一种面向连接的、可靠的、基于字节流的全双工通信传输协议。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">TCP<span class="jill"></span>是面向连接: 数据传送前必须先建立<span class="jill"></span>TCP<span class="jill"></span>连接, 数据传送完以后需要关闭<span class="jill"></span>TCP<span class="jill"></span>连接.</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">TCP<span class="jill"></span>只支持点对点的通信方式.</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">TCP<span class="jill"></span>提供可靠交付的服务: 通过<span class="jill"></span>TCP<span class="jill"></span>连接传输的数据, 无差错, 不丢失, 不重复, 按序到达.</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">TCP<span class="jill"></span>提供全双工通信: 建立<span class="jill"></span>TCP<span class="jill"></span>连接后,通信双方都可以发送数据.</span></li></ul><h2 class="wolai-block"><span class="inline-wrap">TCP<span class="jill"></span>首部结构</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">TCP<span class="jill"></span>传送数据的基本单元是报文段, 一个<span class="jill"></span>TCP<span class="jill"></span>报文段分为两个部分, 分别是首部和数据部分.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">TCP<span class="jill"></span>的全部功能都体现在它首部各字段的作用, 只有弄清楚<span class="jill"></span>TCP<span class="jill"></span>首部各字段的意义, 才能真正掌握<span class="jill"></span>TCP<span class="jill"></span>的工作原理.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">下图是<span class="jill"></span>TCP<span class="jill"></span>报文段的结构图, 我们主要观察<span class="jill"></span>TCP<span class="jill"></span>首部</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image.png" style="width: 760px"/></figure></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>源端口和目标端口</b></span><span class="inline-wrap">：各<span class="jill"></span>16<span class="jill"></span>位，分别记录发送方的端口和接收方的端口</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>序号</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">TCP<span class="jill"></span>是面向字节流的，它把需要传输的数据看作字节流，并为每个字节编号</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">序号记录的是本报文段传输的数据的第一个序号</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">序号字段占用<span class="jill"></span>32<span class="jill"></span>位，所以序号的范围是【0 ~ </span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="inline-wrap">-1】, 序号到达最大值后,下一个序号会回到<span class="jill"></span>0 (mod </span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="inline-wrap">)</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>确认号</b></span><span class="inline-wrap"> : 接收方告诉发送方</span><span class="red inline-wrap">下次发送的数据的第一个序号</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">假设 A<span class="jill"></span>是发送方 B<span class="jill"></span>是接收方.</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">A<span class="jill"></span>发送<span class="jill"></span>200<span class="jill"></span>个字节, 第一个字节的序号是<span class="jill"></span>100, 此时序号字段是<span class="jill"></span>100</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">B<span class="jill"></span>接收到<span class="jill"></span>A<span class="jill"></span>的数据后, 设置确认号为<span class="jill"></span>301, 要求发送方下次发送的数据的第一个序号是<span class="jill"></span>301</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>数据偏移</b></span><span class="inline-wrap"> :</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">由于<span class="jill"></span>TCP<span class="jill"></span>首部长度可变, 因此需要一个字段标记出首部大小, 数据偏移就是做这个的</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数据偏移字段记录数据的起始位置距离首部的起始位置有多远,  实际就是指出首部的长度。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数据偏移占用<span class="jill"></span>4<span class="jill"></span>位，单位是<span class="jill"></span>4<span class="jill"></span>字节，(2</span><span class="inline-wrap">4</span><span class="inline-wrap"> - 1) * 4 = 60, 也就是说<span class="jill"></span>TCP<span class="jill"></span>首部最大是<span class="jill"></span>60<span class="jill"></span>字节。</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>保留</b></span><span class="inline-wrap"> ： 占用<span class="jill"></span>3<span class="jill"></span>位，保留日后使用</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">NS ：</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">CWR：与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 为 1 时，通知对方已将拥塞窗口缩小；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ECE ：</span><span class="inline-wrap">若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>URG</b></span><span class="inline-wrap"> ： (urgent) 当<span class="jill"></span>URG=1<span class="jill"></span>时，说明有紧急数据要发送，发送方<span class="jill"></span>TCP<span class="jill"></span>就把紧急数据插入到本报文段数据部分的最前面，紧急数据的后面仍是普通数据。 该字段要与首部的紧急指针字段配合使用。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>紧急指针</b></span><span class="inline-wrap">： 占<span class="jill"></span>16<span class="jill"></span>位，当<span class="jill"></span>URG=1<span class="jill"></span>时才有意义，该字段指出紧急数据末尾在报文段的位置</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>PSH （push）</b></span><span class="inline-wrap"> 当接收方<span class="jill"></span>TCP<span class="jill"></span>收到一个<span class="jill"></span>PSH=1<span class="jill"></span>的报文段，它会尽快的把该报文上交给应用</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>ACK</b></span><span class="inline-wrap"> ：当<span class="jill"></span>ACK=1<span class="jill"></span>时，确认号才有效。TCP<span class="jill"></span>规定，建立连接后，所有传送的报文都必须把<span class="jill"></span>ACK<span class="jill"></span>设为<span class="jill"></span>1.</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>RST （reset）</b></span><span class="inline-wrap"> ：当<span class="jill"></span>RST=1<span class="jill"></span>时，表明<span class="jill"></span>TCP<span class="jill"></span>连接出现了严重的错误，必须释放连接并重新建立新的连接</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>SYN</b></span><span class="inline-wrap"> ：在建立连接时使用，当<span class="jill"></span>SYN=1，ACK=0<span class="jill"></span>的时候，说明这是个建立连接的请求报文。若对方同意建立连接，则返回<span class="jill"></span>SYN=1 ACK=1<span class="jill"></span>的报文</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>FIN （finish）</b></span><span class="inline-wrap">  ：当<span class="jill"></span>FIN=1<span class="jill"></span>时，说明该报文的发送方已经发送完所有数据，并且要求释放连接</span></li></ul><h3 class="wolai-block"><span class="inline-wrap">TCP<span class="jill"></span>三次握手</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">TCP<span class="jill"></span>采用<span class="jill"></span>CS<span class="jill"></span>架构,主动要请建立连接的是客户端,被动等待建立连接的是服务端.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">建立<span class="jill"></span>TCP<span class="jill"></span>连接需要在客户端和服务端之间交换三次报文</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/tcp%E4%B8%89%E6%8A%A5%E6%96%87%E6%8F%A1%E6%89%8B.png" style="width: 759.5px"/></figure></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">客户端向服务端发出建立连接请求报文段,这时候<span class="jill"></span>TCP<span class="jill"></span>首部<span class="jill"></span>SYN<span class="jill"></span>置为<span class="jill"></span>1,由于<span class="jill"></span>TCP<span class="jill"></span>规定<span class="jill"></span>SYN<span class="jill"></span>报文段不能发送数据,但是要消耗一个序号,所以要设置序号(seq=x)</span></li><li><div class="marker"></div><span class="inline-wrap">服务端收到请求报文后,如果同意建立连接,则向客户发送确认.确认报文的<span class="jill"></span>SYN<span class="jill"></span>和<span class="jill"></span>ACK<span class="jill"></span>都置为<span class="jill"></span>1,确认号(x+1),同样也要消耗一个序号(seq=y)</span></li><li><div class="marker"></div><span class="inline-wrap">客户端收到服务端的确认报文后,还要向<span class="jill"></span>B<span class="jill"></span>给出确认.确认报文<span class="jill"></span>ACK=1,确认号(y+1),序号(x+1),TCP<span class="jill"></span>规定<span class="jill"></span>ACK<span class="jill"></span>报文段可以携带数据,如果不携带数据,则不用消耗序号,也就是下一个报文的序号还是<span class="jill"></span>req=x+1.</span></li></ol><h3 class="wolai-block"><span class="inline-wrap">TCP<span class="jill"></span>四次挥手</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">建立连接后,通信双方都可主动申请关闭连接</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" style="width: 760px"/></figure></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">A<span class="jill"></span>请求释放连接，把发送的报文段首部的<span class="jill"></span>FIN<span class="jill"></span>标志位设为<span class="jill"></span>1，由于<span class="jill"></span>TCP<span class="jill"></span>规定，FIN<span class="jill"></span>报文段即使不携带数据，它也消耗一个序号，所以你能看到上图中有个</span><span class="inline-wrap"><code>seq=u</code></span><span class="inline-wrap">，u<span class="jill"></span>等于前面已传送过的数据的最后一个字节的序号加<span class="jill"></span>1。这时<span class="jill"></span>A<span class="jill"></span>进入</span><span class="inline-wrap"><code>FIN-WAIT-1</code></span><span class="inline-wrap">状态，等到<span class="jill"></span>B<span class="jill"></span>的确认。</span></li><li><div class="marker"></div><span class="inline-wrap">B<span class="jill"></span>收到连接释放报文段后，通知上层应用，然后再返回确认报文，此时<span class="jill"></span>B<span class="jill"></span>进入</span><span class="inline-wrap"><code>CLOSE-WAIT</code></span><span class="inline-wrap">状态（等待发起连接释放报文）。这时<span class="jill"></span>TCP<span class="jill"></span>连接处于</span><span class="bg-uranian_blue inline-wrap"><b>半关闭</b></span><span class="inline-wrap">状态，从<span class="jill"></span>A<span class="jill"></span>到<span class="jill"></span>B<span class="jill"></span>这个方向的连接已经释放了，A<span class="jill"></span>已经没有数据要发送了，但<span class="jill"></span>B<span class="jill"></span>如果要发送数据，A<span class="jill"></span>仍要接收。</span></li><li><div class="marker"></div><span class="inline-wrap">A<span class="jill"></span>受到来自<span class="jill"></span>B<span class="jill"></span>的确认后，进入</span><span class="inline-wrap"><code>FIN-WAIT-2</code></span><span class="inline-wrap">状态，等待<span class="jill"></span>B<span class="jill"></span>发出连接释放报文</span></li><li><div class="marker"></div><span class="inline-wrap">B<span class="jill"></span>数据传输完以后，发出连接释放报文，同样也是把<span class="jill"></span>FIN<span class="jill"></span>标志位设为<span class="jill"></span>1，这时<span class="jill"></span>B<span class="jill"></span>进入了</span><span class="inline-wrap"><code>LAST-ACK</code></span><span class="inline-wrap">状态，等待该连接的最后一个<span class="jill"></span>ACK<span class="jill"></span>报文，等<span class="jill"></span>B<span class="jill"></span>接受到<span class="jill"></span>A<span class="jill"></span>的确认报文后，就会进入<span class="jill"></span>CLOSE<span class="jill"></span>状态</span></li><li><div class="marker"></div><span class="inline-wrap">A<span class="jill"></span>收到<span class="jill"></span>B<span class="jill"></span>的连接释放报文段后，发出确认，然后进入</span><span class="inline-wrap"><code>TIME-WAIT</code></span><span class="inline-wrap">(时间等待)状态，此时<span class="jill"></span>TCP<span class="jill"></span>连接还没释放调，需要等待<span class="jill"></span>2MSL<span class="jill"></span>后，A<span class="jill"></span>才进入<span class="jill"></span>CLOSE<span class="jill"></span>状态。MSL(Maximum Sement Lifetime)最长报文段寿命。</span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>以上就是<span class="jill"></span>TCP<span class="jill"></span>释放连接的过程。</b></span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>窗口</b></span><span class="inline-wrap"> ：窗口值告诉对方，从本报文段的确认号算起，你最多能发送多少字节的数据给我。</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">例如，确认号是<span class="jill"></span>101，窗口值是<span class="jill"></span>1000，那就是告诉对方，我目前还能接收<span class="jill"></span>1000<span class="jill"></span>字节的数据（序号<span class="jill"></span>101-1101），你在给我发数据时必须考虑到这一点。对于紧急数据，就算窗口为<span class="jill"></span>0<span class="jill"></span>也能发送。</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>校验和</b></span><span class="inline-wrap"> ：进行数据校验时使用，使用方式与<span class="jill"></span>UDP<span class="jill"></span>一样，也是添加<span class="jill"></span>12<span class="jill"></span>字节的伪首部，只是要把伪首部第四个字段从<span class="jill"></span>17<span class="jill"></span>改为<span class="jill"></span>6，（TCP<span class="jill"></span>的协议号是<span class="jill"></span>6），第五个字段中<span class="jill"></span>UDP<span class="jill"></span>长度改为<span class="jill"></span>TCP<span class="jill"></span>长度。如果使用<span class="jill"></span>IPV6，伪首部也要做出相应的改变。</span></li></ul><h3 class="wolai-block"><span class="inline-wrap">TCP<span class="jill"></span>选项</span></h3><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>选项</b></span><span class="inline-wrap"> ： 长度可变，最长可达<span class="jill"></span>40<span class="jill"></span>个字节，最初只规定了一种选项，那就是 </span><span class="inline-wrap"><b>MSS</b></span><span class="inline-wrap">（maximum segment size）最大报文段长度，然后后面又增加了 </span><span class="inline-wrap"><b>窗口扩大</b></span><span class="inline-wrap">  </span><span class="inline-wrap"><b>时间戳</b></span><span class="inline-wrap"> </span><span class="inline-wrap"><b>选择确认</b></span><span class="inline-wrap"> 等选项.</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>时间戳</b></span><span class="inline-wrap"> ：时间戳选项占<span class="jill"></span>10<span class="jill"></span>个字节，其中最主要的是</span><span class="inline-wrap"><b>时间戳字段</b></span><span class="inline-wrap">和</span><span class="inline-wrap"><b>时间戳回送回答字段</b></span><span class="inline-wrap">，这两个字段分别占用<span class="jill"></span>4<span class="jill"></span>个字节，时间戳选项主要有两个作用</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">计算<span class="jill"></span>TCP<span class="jill"></span>报文往返时间 （RTT）</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">序号重复时，区分报文的先后顺序，如果数据发送速率很大，那序号就很可能出现重复。</span></li></ul></li></ul><h2 class="wolai-block"><span class="inline-wrap">TCP<span class="jill"></span>可靠传输的工作原理</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">可靠传输必须要满足以下两个要求：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数据传输出现差错的时候，发送方重传出现差错的数据 (失败重传)</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">发送方发送的数据量不能超过接收方的处理能力</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">下面我们来看实现可靠传输的最简单的一种方法，停止等待协议</span></div></div><h3 class="wolai-block"><span class="inline-wrap">停止等待<span class="jill"></span>ARQ<span class="jill"></span>协议</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>ARQ<span class="jill"></span>自动重传请求(automatic repeat request)，重传是发送方自动发起的</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">设发送方为<span class="jill"></span>A，接收方为<span class="jill"></span>B   【TCP<span class="jill"></span>是全双工通信，既能做发送方，也能做接收方，这里为了方便讨论，仅考虑一个发送，一个接收】</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>无差错情况</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">A<span class="jill"></span>发送数据<span class="jill"></span>D1，B<span class="jill"></span>收到后返回确认，然后<span class="jill"></span>A<span class="jill"></span>再发送<span class="jill"></span>D2，以此类推</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>有差错情况</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果<span class="jill"></span>B<span class="jill"></span>没有收到<span class="jill"></span>A<span class="jill"></span>发送的数据<span class="jill"></span>D3，或者校验出<span class="jill"></span>D3<span class="jill"></span>有问题(丢掉<span class="jill"></span>D3)，那么<span class="jill"></span>B<span class="jill"></span>不发送确认</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">A<span class="jill"></span>在一定时间内没有收到<span class="jill"></span>B<span class="jill"></span>的确认，重新发送<span class="jill"></span>D3（超时重传）</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>确认丢失</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">A<span class="jill"></span>发送<span class="jill"></span>D4，B<span class="jill"></span>返回<span class="jill"></span>D4<span class="jill"></span>的确认，但是确认丢失了，A<span class="jill"></span>永远都收不到，A<span class="jill"></span>超时重传<span class="jill"></span>D4，B<span class="jill"></span>再次接收到<span class="jill"></span>D4(丢掉<span class="jill"></span>D4)，B<span class="jill"></span>再次返回确认</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>确认迟到</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">A<span class="jill"></span>发送<span class="jill"></span>D5，B<span class="jill"></span>返回<span class="jill"></span>D5<span class="jill"></span>的确认，该确认在网络中长时间滞留，导致<span class="jill"></span>A<span class="jill"></span>超时重传<span class="jill"></span>D4，B<span class="jill"></span>再次接收到<span class="jill"></span>D4(丢掉<span class="jill"></span>D4)，B<span class="jill"></span>再次返回确认</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">A<span class="jill"></span>最终会收到重复的确认，对于重复的确认，丢掉即可</span></div></div><h3 class="wolai-block"><span class="inline-wrap">连续<span class="jill"></span>ARQ<span class="jill"></span>协议</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">停止等待<span class="jill"></span>ARQ<span class="jill"></span>协议有性能问题，那就是需要阻塞等待接收方返回确认。为了提高传输效率，我们可以采用流水线传输的方式，就是发送方可以连续发送多份数据，不必每发送一份数据就停止等待接收方的确认，从而大大提高传输效率，这就是</span><span class="inline-wrap"><b>连续<span class="jill"></span>ARQ<span class="jill"></span>协议</b></span><span class="inline-wrap">。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">滑动窗口协议</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">连续发送多份数据，我们之前讲过，发送方发送的数据量不能超过接收方的处理能力，也就是我们需要一种协商机制，确保数据不会超过对方的处理能力？那就要用到滑动窗口协议了。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">假设发送方<span class="jill"></span>A<span class="jill"></span>收到了接收方<span class="jill"></span>B<span class="jill"></span>响应的确认报文段，确认号是<span class="jill"></span>31，窗口是<span class="jill"></span>20，根据这两个数据，A<span class="jill"></span>构造出自己的发送窗口，如下图所示</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/tcp%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-1.png" style="width: 759.5px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>A<span class="jill"></span>的发送窗口</b></span><span class="inline-wrap">：在没有收到<span class="jill"></span>B<span class="jill"></span>的确认的情况下，A<span class="jill"></span>可以连续把窗口内的数据都发送出去。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>现在假定<span class="jill"></span>A<span class="jill"></span>发送了序号为<span class="jill"></span>31~41<span class="jill"></span>的数据，见下图</b></span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/tcp%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-2.png" style="width: 759.5px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">从上图可以看出，要描述一个发送窗口的状态需要三个指针：P1、P2、P3</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">P1<span class="jill"></span>的左边表示已经收到确认的部分，P2<span class="jill"></span>的左边到<span class="jill"></span>P1<span class="jill"></span>表示已经发送但是还没收到确认的部分</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">P2<span class="jill"></span>的右边（包括<span class="jill"></span>P2）到<span class="jill"></span>P3<span class="jill"></span>的左边表示可以发送的部分，P3<span class="jill"></span>的右边（包括右边）表示不允许发送的部分</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>现在来看看<span class="jill"></span>B<span class="jill"></span>的接受窗口，见下图</b></span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/tcp%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-3.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">由于数据没有按序到达，B<span class="jill"></span>收到了序号为<span class="jill"></span>32<span class="jill"></span>和<span class="jill"></span>33<span class="jill"></span>的数据，没有收到序号为<span class="jill"></span>31<span class="jill"></span>的数据（可能滞留在网络中或者是丢失了），由于没有收到序号为<span class="jill"></span>31<span class="jill"></span>的数据，所以在接收到序号为<span class="jill"></span>32<span class="jill"></span>和<span class="jill"></span>33<span class="jill"></span>的数据时，接收方返回的确认号依然是<span class="jill"></span>31，而不是<span class="jill"></span>32<span class="jill"></span>或<span class="jill"></span>33。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">TCP<span class="jill"></span>的拥塞控制</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">计算机网络中的带宽、交换节点中的缓存、处理机等，都是网络的资源。在某段时间，若网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。（对资源的需求量大于可用资源的总数）</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">TCP<span class="jill"></span>拥塞控制用到的算法有四种：慢开始、拥塞避免、快重传、快恢复。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">下面介绍这些算法的原理，为了集中精力讨论拥塞控制，我们假定：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数据是单向传输的，对方只传送确认报文</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">接收方总是有足够打的缓存空间，因而发送窗口的大小由网络的拥塞程度来决定</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">下面讨论的拥塞控制也叫作基于窗口的拥塞控制，发送方维持一个叫做</span><span class="inline-wrap"><b>拥塞窗口</b></span><span class="inline-wrap">的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化，发送方让自己的发送窗口等于拥塞窗口。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就可以再增大一些，如过网络出现拥塞或者有可能出现拥塞，就把拥塞窗口缩小一点。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">现在通信线路的传输质量一般都很好，因传输出差错而丢弃分组的概率很小，因此，出现超时就可以认为是出现了网络拥塞。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">慢开始</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">拥塞窗口的数值由小到大逐渐增大，RFC5681<span class="jill"></span>规定，拥塞窗口初始值不超过<span class="jill"></span>2<span class="jill"></span>至<span class="jill"></span>4<span class="jill"></span>个<span class="jill"></span>SMSS<span class="jill"></span>的数值。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">SMSS（Sender Maximum Segment Size 发送方的最大报文段）</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">慢开始规定，</span><span class="bg-uranian_blue inline-wrap">在收到一个(不是重发的)报文段的确认后</span><span class="inline-wrap">，可以把拥塞窗口增加最多一个<span class="jill"></span>SMSS<span class="jill"></span>值。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">假设拥塞窗口初始值为<span class="jill"></span>1，发送一个报文段，收到确认后，拥塞窗口增加<span class="jill"></span>1</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">拥塞窗口为<span class="jill"></span>2，发送两个报文，每收到一个确认，拥塞窗口增加<span class="jill"></span>1</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">这时候拥塞窗口变为<span class="jill"></span>4，也就是说每经过一个传输轮次，拥塞窗口翻倍</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">为了防止拥塞窗口增长过大引起网络拥塞，还需要设置一个慢开始门限（ssthresh）状态变量。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">当拥塞窗口&lt;慢开始门限时，使用慢开始算法</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">当拥塞窗口&gt;慢开始门限时，使用拥塞避免算法</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">当拥塞窗口=慢开始门限时，两者都可使用</span></li></ul><h3 class="wolai-block"><span class="inline-wrap">拥塞避免</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">拥塞避免算法让拥塞窗口缓慢地增长，每经过一个传输伦次，拥塞窗口加<span class="jill"></span>1。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">快重传</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">有时，个别报文段会在网络中丢失，但是网络并没有发生拥塞，如果发送方迟迟收到不确认，那么就会认为网络拥塞，导致发送方错误地启动慢开始，降低了传输效率。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">快速重传要求接收方收到报文段后要立即发送确认，就算收到的报文段并不是按序到达，也要对收到的报文段发送确认。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6-%E5%BF%AB%E9%87%8D%E4%BC%A0.png" style="width: 760px"/></figure></div><h3 class="wolai-block"><span class="inline-wrap">快恢复</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">TCP<span class="jill"></span>知道不是网络拥塞，而是报文丢失，就不会启用慢开始算法，而是用快恢复算法对拥塞窗口进行调整。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">主动队列管理</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">上面讨论的<span class="jill"></span>TCP<span class="jill"></span>拥塞控制并没有与网络层采取的策略联系起来，其实，他们之间是有着密切的关系。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">假如某一个路由器对某些分组的处理时间特别长，那么这就可能使这些分组中的数据部分(即<span class="jill"></span>TCP<span class="jill"></span>报文)，经过很长时间才能到达终点，结果引起接收方对这些报文段的重传，重传会让<span class="jill"></span>TCP<span class="jill"></span>采取拥塞控制措施，但实际上网络并没有拥塞。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">网络层对<span class="jill"></span>TCP<span class="jill"></span>拥塞控制影响最大的就是路由器的分组丢弃策略。如果路由器的队列使用<span class="jill"></span>FIFO<span class="jill"></span>策略，当队列满时，后面到达的数据会被丢弃，这些数据很可能来自不同的<span class="jill"></span>TCP<span class="jill"></span>发送方，导致这些发送方同时采取拥塞控制措施，在<span class="jill"></span>TCP<span class="jill"></span>术语中，这种情况称为全局同步。全局同步使得全网的通信量突然下降了很多，但是在一段时间后，其通信量又突然增大很多。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">为了避免发生全局同步现象，1998<span class="jill"></span>年提出了主动队列管理，当队列长度到达某个值得警惕的数值时，就主动随机丢弃部分到达的数据。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">TCP<span class="jill"></span>保活机制</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果在一段时间(keepalive time)内连接处于非活动状态，开启保活功能的一端将向对方发送一个保活探测报文。如果发送端没有接收到响应报文，那么经过一个已经提前配置好的保活时间间隔(keepalive interval)，将继续发送保活探测报文，直到探测报文发送次数达到保活探测数(keepalive probe)，这时对方主机将被确认为不可到达，连接也将被中断。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>保活探测报文</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">保活探测报文为一个空报文段。它的序列号等于对方主机发送的<span class="jill"></span>ACK<span class="jill"></span>报文的最大序列号减<span class="jill"></span>1。因为这一序列号的数据段已经被成功接收，所以不会对到达的报文段造成影响，但是报文返回的响应可以确认连接是否仍在工作。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>保活机制相关时间的设置</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>保活机制的风险</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">常见问题</span></h2><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap"><b>为什么<span class="jill"></span>TCP<span class="jill"></span>需要三次握手？两次不行吗？</b></span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">因为<span class="jill"></span>tcp<span class="jill"></span>要提供可靠的全双工通信的服务，为了这个目的，通信双方在通信前需要测试对方能否收到自己的信息。简单来说就是，双方都会给对方发送一条信息，如果对方能返回正确的响应，说明对方能收到自己的信息。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果没有第三次握手(客户端没返回正确的响应)，那么服务端就不确定客户端能否收到自己的信息。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>还有就是防止消失的请求再次出现导致的问题</b></span><span class="inline-wrap">
</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">假设客户端发送建立连接请求<span class="jill"></span>R1,但是因为网络问题,R1<span class="jill"></span>没有传到服务端
</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">由于没有收到服务端的确认报文,客户端再次发送建立连接请求<span class="jill"></span>R2,这次服务端接收到了,双方建立完连接,数据也传送完,连接也关闭了
</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">这时候<span class="jill"></span>R1<span class="jill"></span>突然到达服务端,服务端以为客户端又想跟它建立连接,就返回一个确认报文给客户端,如果是两次握手,这时候服务端认为已经建立了连接了,但是客户端永远不会通过该连接发送任何数据</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap"><b>TCP<span class="jill"></span>的序列号和确认号有什么作用？</b></span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">TCP<span class="jill"></span>要提供可靠的传输服务，而数据报在网络中传输时有可能会丢失，所以它要支持失败重传。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">那么问题来了：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">对于接收方来说，它怎么知道这个数据报它接收过没有？（因为有可能收到同样的数据报）</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">对于发送方来说，它怎么知道对方有没有收到数据报？对方收到的是哪个数据报？（其实对于发送方来说，它不需要知道对方收到的是哪个数据报，它只需要知道对方接下来要哪些数据即可）</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">这就要靠序列号和确认号了</span></div></div><blockquote class="wolai-block"><span class="inline-wrap">TCP<span class="jill"></span>是面向字节流的，它把需要传输的数据看作字节流，并为每个字节编个序号</span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap">接收方收到数据报，看数据报上的序列号(seq)，可以判断出自己有没有收到过这个报文</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">发送方收到数据报，就可以知道接收方收到了报文，然后看数据报上的确认号(ack)，就可以知道接下来要发送哪些数据</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap"><b>TCP<span class="jill"></span>的初始序号(ISN)为什么要是随机生成，不能统一从<span class="jill"></span>0<span class="jill"></span>开始？</b></span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">ISN<span class="jill"></span>随机生成是为了尽可能的防止</span><span class="inline-wrap"><code>地址欺骗</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>会话劫持</code></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">假设<span class="jill"></span>A<span class="jill"></span>与<span class="jill"></span>B<span class="jill"></span>之间有一个<span class="jill"></span>TCP<span class="jill"></span>连接，C<span class="jill"></span>想搞破坏，伪造<span class="jill"></span>A<span class="jill"></span>的<span class="jill"></span>IP<span class="jill"></span>和端口给<span class="jill"></span>B<span class="jill"></span>发一个<span class="jill"></span>Reset。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>情景一：C<span class="jill"></span>处于<span class="jill"></span>A<span class="jill"></span>与<span class="jill"></span>B<span class="jill"></span>之间流量的路径上</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">C<span class="jill"></span>可以捕获到<span class="jill"></span>A、B<span class="jill"></span>的<span class="jill"></span>IP<span class="jill"></span>包，伪造是小菜一碟，比如防火墙<span class="jill"></span>reset<span class="jill"></span>用户连接</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>情景二：C<span class="jill"></span>不在<span class="jill"></span>A<span class="jill"></span>与<span class="jill"></span>B<span class="jill"></span>之间流量的路径上</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">C<span class="jill"></span>可以在世界的任何角落，伪造一个合法<span class="jill"></span>TCP<span class="jill"></span>报文，最关键是<span class="jill"></span>TCP<span class="jill"></span>字段里的<span class="jill"></span>sequence number 、acknowledged number，只要这两项位于接收者滑动窗口内，就是合法的，C<span class="jill"></span>可以接收并<span class="jill"></span>Reset A、B<span class="jill"></span>之间的<span class="jill"></span>TCP<span class="jill"></span>连接。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">随机的<span class="jill"></span>ISN<span class="jill"></span>让<span class="jill"></span>C<span class="jill"></span>不好猜测当前合法的<span class="jill"></span>seq<span class="jill"></span>和<span class="jill"></span>ack。</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://saucer-man.com/network/629.html">关于ip伪造的原理探究 - SAUCERMAN</a><div class="info-box"><div class="text-pane"><div data-title="关于ip伪造的原理探究 - SAUCERMAN"></div><div data-desc="昨天有个朋友问我ip伪造的可行性，以前没深入了解过，于是上网搜索了一番，发现syn flood普遍利用了伪造源ip的方式进行攻击。现在需求变成：伪造源ip对目标发包，不要求接收到返回包这个需求能..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://saucer-man.com/favicon.ico&quot;)"></div><div data-hostname="saucer-man.com"></div></div></div><div class="preview-pane" style="background-image: url(https://saucer-man.com/logo.gif)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://www.cloudflare.com/zh-cn/learning/ddos/syn-flood-ddos-attack/#:~:text=SYN%20%E6%B4%AA%E6%B0%B4%EF%BC%88%E5%8D%8A%E5%BC%80%E8%BF%9E%E6%8E%A5,%E8%BF%9F%E9%92%9D%E4%B9%83%E8%87%B3%E5%85%A8%E6%97%A0%E5%93%8D%E5%BA%94%E3%80%82">https://www.cloudflare.com/zh-cn/learning/ddos/syn-flood-ddos-attack/#:~:text=SYN 洪水（半开连接,迟钝乃至全无响应。</a><div class="info-box"><div class="text-pane"><div data-title="www.cloudflare.com"></div><div class="icon-host"><div data-hostname="www.cloudflare.com"></div></div></div><div class="preview-pane"></div></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap"><b>为什么需要四次挥手？</b></span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">因为要确保另一方真的收到释放连接的请求。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">客户端请求释放连接，服务器返回正确响应报文，客户端才能认为服务端收到它释放连接的请求了。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">同理，服务端请求释放连接，客户端也必须返回正确的响应报文，服务器才能认为客户端收到它释放连接的请求了。</span></div></div><blockquote class="bg-cultured wolai-block"><span class="inline-wrap">A    我完事了
       OK                 B
       我也完事了   B
A     OK</span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap">虽然<span class="jill"></span>A<span class="jill"></span>完事了，但是<span class="jill"></span>B<span class="jill"></span>可能还有事情要做，所以<span class="jill"></span>B<span class="jill"></span>的两条信息不能一起返回</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">TCP 挥手时出现大量 FINISH_WAIT_2<span class="jill"></span>或 CLOSE_WAIT 怎么解决？</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">大量<span class="jill"></span>FINISH_WAIT_2</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对方代码忘记调用或者无法调用<span class="jill"></span>close，导致对方没发出<span class="jill"></span>FIN<span class="jill"></span>数据报</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">大量 CLOSE_WAIT</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">先介绍两个系统调用<span class="jill"></span>close(socket)和<span class="jill"></span>shutdown(socket,HOW)。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">我们知道一个进程打开一个<span class="jill"></span>socket，然后此进程<span class="jill"></span>fork<span class="jill"></span>出子进程的时候，父进程已打开的<span class="jill"></span>socket<span class="jill"></span>是会被继承的，即子进程能够继续访问这个<span class="jill"></span>socket。其结果就是，一个<span class="jill"></span>socket<span class="jill"></span>被两个进程打开，一个父进程和一个子进程，此时<span class="jill"></span>socket<span class="jill"></span>的引用计数会变成<span class="jill"></span>2。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">调用<span class="jill"></span>close(socket)时，内核先检查<span class="jill"></span>socket<span class="jill"></span>上的引用计数器：如果引用计数大于<span class="jill"></span>1，那么将这个引用计数减<span class="jill"></span>1，然后直接返回。如果引用计数等于<span class="jill"></span>1，那么内核才会真正关闭此<span class="jill"></span>socket。(通过发送<span class="jill"></span>FIN<span class="jill"></span>到对端来关闭<span class="jill"></span>TCP<span class="jill"></span>连接)</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">调用<span class="jill"></span>shutdown(socket，HOW)时，内核不会检查此<span class="jill"></span>socket<span class="jill"></span>对应的引用计数器，直接向对端发送<span class="jill"></span>FIN<span class="jill"></span>来关闭<span class="jill"></span>TCP<span class="jill"></span>连接。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">据此分析</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">代码忘记调用<span class="jill"></span>close</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">这个是一个多进程的程序，父进程打开了<span class="jill"></span>socket，然后通过<span class="jill"></span>fork<span class="jill"></span>出子进程来处理业务，父进程继续对网络请求进行监听，永远不会终止；当客户端发<span class="jill"></span>FIN<span class="jill"></span>过来的时候，处理业务的子进程处理此<span class="jill"></span>FIN<span class="jill"></span>消息，调用<span class="jill"></span>close()对本端进行关闭，然而这个<span class="jill"></span>close()调用只是把<span class="jill"></span>socket<span class="jill"></span>的引用计数器减<span class="jill"></span>1，因为父进程还在运行，socket<span class="jill"></span>并没关闭，这样就导致系统中又多了一个<span class="jill"></span>CLOSE_WAIT<span class="jill"></span>的<span class="jill"></span>socket</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">为什么<span class="jill"></span>A<span class="jill"></span>在<span class="jill"></span>TIME-WAIT<span class="jill"></span>状态必须等待<span class="jill"></span>2MSL<span class="jill"></span>的时间呢?</span></summary><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">假设<span class="jill"></span>A<span class="jill"></span>发送的最后一个<span class="jill"></span>ACK<span class="jill"></span>报文就进入<span class="jill"></span>CLOSE<span class="jill"></span>状态，最后一个<span class="jill"></span>ACK<span class="jill"></span>报文是有丢失的可能，B<span class="jill"></span>没有确认报文，会超时重传连接释放报文，但是<span class="jill"></span>A<span class="jill"></span>已经<span class="jill"></span>CLOSE<span class="jill"></span>了，不会理会<span class="jill"></span>B<span class="jill"></span>的连接释放报文，导致<span class="jill"></span>B<span class="jill"></span>无法按照正常步骤进入<span class="jill"></span>CLOSE<span class="jill"></span>状态。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">等到<span class="jill"></span>2MSL，使本连接持续时间内所产生的所有报文段都从网络中消失，避免下一个新连接中出现旧连接的报文段。</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">TCP<span class="jill"></span>超时与重传</span></summary><div class="wolai-bookmark wolai-block"><a href="http://blog.qiusuo.im/blog/2014/03/19/tcp-timeout/">TCP协议的那些超时 - On the road</a><div class="info-box"><div class="text-pane"><div data-title="TCP协议的那些超时 - On the road"></div><div data-desc="众所周知，TCP协议是一个 **可靠的** 的协议。TCP的可靠性依赖于大量的 **Timer** 和 **Retransmission** 。现在咱们就来细说一下TCP协议的那些 **Timer** 。![TCP State …"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://blog.qiusuo.im/images/fav.png&quot;)"></div><div data-hostname="blog.qiusuo.im"></div></div></div><div class="preview-pane"></div></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">TCP<span class="jill"></span>拥塞控制</span></summary><div class="wolai-bookmark wolai-block"><a href="https://segmentfault.com/a/1190000019102072">https://segmentfault.com/a/1190000019102072</a><div class="info-box"><div class="text-pane"><div data-title="segmentfault.com"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://segmentfault.com/favicon.ico&quot;)"></div><div data-hostname="segmentfault.com"></div></div></div><div class="preview-pane"></div></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">TCP 重置报文</span></summary><div class="wolai-bookmark wolai-block"><a href="https://iponwire.com/tcp-reset-rst-reasons/">Causes of TCP Reset flag from Client or Server | IP ON WIRE</a><div class="info-box"><div class="text-pane"><div data-title="Causes of TCP Reset flag from Client or Server | IP ON WIRE"></div><div data-desc="The article explains various causes of TCP reset that caused the connection to get close immediately between client and server"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://iponwire.com/wp-content/uploads/2020/05/cropped-site-icon-iponwire-2-192x192.png&quot;)"></div><div data-hostname="iponwire.com"></div></div></div><div class="preview-pane" style="background-image: url(https://iponwire.com/wp-content/uploads/2020/04/TCP-reset-reason.jpg)"></div></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Text" class="marker"></div><pre>A:2333 跟 B:8080建立TCP连接后
A重启，同样也是2333端口，跟B的8080建立连接，也就是A:2333发送SYN给B:8080
这时候B会返回什么？
因为A是重启过的，所以它发送数据给B之前，需要先跟B建立连接，也就是会发送SYN请求给到B，B会返回RST，连接重置</pre></div></code-block></details><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">select、poll、epoll<span class="jill"></span>的区别，及其应用场景</span></summary><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">阻塞<span class="jill"></span>I/O：发起</span><span class="inline-wrap">I/O</span><span class="inline-wrap">操作后线程会被阻塞，直至</span><span class="inline-wrap">I/O</span><span class="inline-wrap">操作完毕</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">非阻塞<span class="jill"></span>I/O：发起</span><span class="inline-wrap">I/O</span><span class="inline-wrap">操作后立即返回操作完成与否，</span><span class="inline-wrap"><b>一个线程</b></span><span class="inline-wrap">轮询多个</span><span class="inline-wrap">I/O</span><span class="inline-wrap">操作</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">I/O<span class="jill"></span>多路复用：</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">非阻塞 I/O 的缺点是：每次发起系统调用，只能检查</span><span class="inline-wrap"><b>一个</b></span><span class="inline-wrap">文件描述符是否就绪。当文件描述符很多时，系统调用成本很高。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"> I/O 多路复用，可以</span><span class="inline-wrap"><b>通过一次系统调用，检查多个文件描述符的状态</b></span><span class="inline-wrap">。这是 I/O 多路复用的主要优点，相比于非阻塞 I/O，在文件描述符较多的场景下，避免了频繁的用户态和内核态的切换，减少了系统调用的开销。</span></div></div><blockquote class="wolai-block"><span class="inline-wrap">I/O 多路复用相当于将「遍历所有文件描述符、通过非阻塞 I/O 查看其是否就绪」的过程从用户线程移到了内核中，由内核来负责轮询。</span></blockquote></li></ul><div class="wolai-bookmark wolai-block"><a href="https://imageslr.com/2020/02/27/select-poll-epoll.html">📔【操作系统】I/O 多路复用，select / poll / epoll 详解</a><div class="info-box"><div class="text-pane"><div data-title="📔【操作系统】I/O 多路复用，select / poll / epoll 详解"></div><div data-desc="更多面试题总结请看：🗂【面试题】技术面试题汇总"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://imageslr.com/favicon.ico&quot;)"></div><div data-hostname="imageslr.com"></div></div></div><div class="preview-pane"></div></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">什么是 TCP 粘包和拆包？</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">粘包：应用层的多个数据报被<span class="jill"></span>TCP<span class="jill"></span>包装成一个报文发送出去</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">拆包：应用层要发送的数据报太大，被<span class="jill"></span>TCP<span class="jill"></span>拆成多个报文发送出去</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>常见的解决方案</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">对于粘包和拆包问题，常见的解决方案有四种：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">发送端将每个包都封装成固定的长度，比如<span class="jill"></span>100<span class="jill"></span>字节大小。如果不足<span class="jill"></span>100<span class="jill"></span>字节可通过补<span class="jill"></span>0<span class="jill"></span>或空等进行填充到指定长度；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">发送端在每个包的末尾使用固定的分隔符，例如\r\n。如果发生拆包需等待多个包发送过来之后再找到其中的\r\n<span class="jill"></span>进行合并；例如，FTP<span class="jill"></span>协议；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">通过自定义协议进行粘包和拆包的处理。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Netty<span class="jill"></span>对粘包和拆包问题的处理</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Netty<span class="jill"></span>对解决粘包和拆包的方案做了抽象，提供了一些解码器（</span><span class="inline-wrap"><code>Decoder</code></span><span class="inline-wrap">）来解决粘包和拆包的问题。如：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>LineBasedFrameDecoder</code></span><span class="inline-wrap">：以行为单位进行数据包的解码；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>DelimiterBasedFrameDecoder</code></span><span class="inline-wrap">：以特殊的符号作为分隔来进行数据包的解码；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>FixedLengthFrameDecoder</code></span><span class="inline-wrap">：以固定长度进行数据包的解码；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>LenghtFieldBasedFrameDecode</code></span><span class="inline-wrap">：适用于消息头包含消息长度的协议（最常用）；</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">基于<span class="jill"></span>Netty<span class="jill"></span>进行网络读写的程序，可以直接使用这些</span><span class="inline-wrap"><code>Decoder</code></span><span class="inline-wrap">来完成数据包的解码。对于高并发、大流量的系统来说，每个数据包都不应该传输多余的数据（所以补齐的方式不可取），</span><span class="inline-wrap"><code>LenghtFieldBasedFrameDecode</code></span><span class="inline-wrap">更适合这样的场景。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">TCP 长连接和短连接有那么不同的使用场景？</span></summary><div class="wolai-bookmark wolai-block"><a href="https://cloud.tencent.com/developer/article/1640430">面试中经常问到的 长连接&amp;短连接，你了解的多吗？ - 云+社区 - 腾讯云</a><div class="info-box"><div class="text-pane"><div data-title="面试中经常问到的 长连接&amp;短连接，你了解的多吗？ - 云+社区 - 腾讯云"></div><div data-desc="今天是周三（2020-04-29），分享一句谚语 “书读百遍，其义自见” 。分享给大家的是 「网络服务 模块」- 长连接&amp;短连接。"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cloud.tencent.com/favicon.ico&quot;)"></div><div data-hostname="cloud.tencent.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">HTTP<span class="jill"></span>的长链接是怎么实现的？</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">其实就是复用一条<span class="jill"></span>TCP<span class="jill"></span>连接，多个<span class="jill"></span>HTTP<span class="jill"></span>请求和响应报文通过同一条<span class="jill"></span>TCP<span class="jill"></span>连接进行传输。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">问题来了，怎么区分这个报文属于哪个<span class="jill"></span>HTTP<span class="jill"></span>对话呢？</span></div></div></details><details class="wolai-block"><summary><div class="marker placeholder"></div><span class="inline-wrap">UDP<span class="jill"></span>如何实现可靠传输</span></summary></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">QUIC<span class="jill"></span>是怎么实现的？</span></summary><div class="wolai-bookmark wolai-block"><a href="https://cloud.tencent.com/developer/article/1802343#:~:text=%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%8CQUIC%20%E6%98%AF%E5%9F%BA%E4%BA%8E,%E5%B0%B1%E4%B8%8D%E9%9C%80%E8%A6%81%E9%87%8D%E8%BF%9E%E3%80%82">QUIC协议原理浅解 - 云+社区 - 腾讯云</a><div class="info-box"><div class="text-pane"><div data-title="QUIC协议原理浅解 - 云+社区 - 腾讯云"></div><div data-desc="导语 | QUIC，HTTP3 的传输层实现，是近年来诞生的非常强悍的传输协议，它利用 UDP 解决了当前基于 TCP 协议的 HTTP 的许多问题，提升了在弱..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cloud.tencent.com/favicon.ico&quot;)"></div><div data-hostname="cloud.tencent.com"></div></div></div><div class="preview-pane"></div></div></div></details><div class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>
<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../css/wolai.css"/><title>分布式Id - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div data-symbol="❄️" class="icon"></div></div><div data-title="分布式Id" class="main-title"></div></div></header><article><div class="wolai-block wolai-text"><div><span class="inline-wrap">分布式<span class="jill"></span>Id<span class="jill"></span>的<span class="jill"></span>9<span class="jill"></span>种生成方式：</span></div></div><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">UUID</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Java<span class="jill"></span>的世界里，想要得到一个具有唯一性的<span class="jill"></span>ID，首先被想到可能就是</span><span class="inline-wrap"><code>UUID</code></span><span class="inline-wrap">，毕竟它有着全球唯一的特性。那么</span><span class="inline-wrap"><code>UUID</code></span><span class="inline-wrap">可以做</span><span class="inline-wrap"><code>分布式<span class="jill"></span>ID</code></span><span class="inline-wrap">吗？</span><span class="inline-wrap"><b>答案是可以的，但是并不推荐！</b></span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token class-name">String</span> uuid <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>uuid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>UUID</code></span><span class="inline-wrap">的生成简单到只有一行代码，输出结果 </span><span class="inline-wrap"><code>c2b8c2b9e46c47e3b30dca3b0d447718</code></span><span class="inline-wrap">，但<span class="jill"></span>UUID<span class="jill"></span>却并不适用于实际的业务需求。像用作订单号</span><span class="inline-wrap"><code>UUID</code></span><span class="inline-wrap">这样的字符串没有丝毫的意义，看不出和订单相关的有用信息；而对于数据库来说用作业务</span><span class="inline-wrap"><code>主键<span class="jill"></span>ID</code></span><span class="inline-wrap">，它不仅是太长还是字符串，存储性能差查询也很耗时，所以不推荐用作</span><span class="inline-wrap"><code>分布式<span class="jill"></span>ID</code></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">数据库自增<span class="jill"></span>ID</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">基于数据库的</span><span class="inline-wrap"><code>auto_increment</code></span><span class="inline-wrap">自增<span class="jill"></span>ID<span class="jill"></span>完全可以充当</span><span class="inline-wrap"><code>分布式<span class="jill"></span>ID</code></span><span class="inline-wrap">，具体实现：需要一个单独的<span class="jill"></span>MySQL<span class="jill"></span>实例用来生成<span class="jill"></span>ID，建表结构如下：</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token punctuation">`</span>SEQ_ID<span class="token punctuation">`</span><span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> SEQID<span class="token punctuation">.</span>SEQUENCE_ID <span class="token punctuation">(</span>
  id <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span> <span class="token keyword">value</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">default</span> <span class="token string">''</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span>MyISAM<span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> SEQUENCE_ID<span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span>  <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'values'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">当我们需要一个<span class="jill"></span>ID<span class="jill"></span>的时候，向表中插入一条记录返回</span><span class="inline-wrap"><code>主键<span class="jill"></span>ID</code></span><span class="inline-wrap">，但这种方式有一个比较致命的缺点，访问量激增时<span class="jill"></span>MySQL<span class="jill"></span>本身就是系统的瓶颈，用它来实现分布式服务风险比较大，不推荐！</span></div></div><aside class="bg-cultured wolai-block"><div data-symbol="❄️" class="icon"></div><span class="inline-wrap">单机数据库自增容易有单点问题，并且容易出现性能瓶颈，对此问题提供了两种解决方案:</span></aside><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">数据库多主模式</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用多个<span class="jill"></span>Mysql<span class="jill"></span>实例生产自增<span class="jill"></span>ID。通过设置初始值和自增步长避免<span class="jill"></span>Id<span class="jill"></span>重复。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">缺点：不利于扩展，扩展时需要修改之前数据库的初始值和自增步长。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">号段模式</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">号段模式是当下分布式<span class="jill"></span>ID<span class="jill"></span>生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增<span class="jill"></span>ID，每次从数据库取出一个号段范围，例如 [1,1000] 代表<span class="jill"></span>1000<span class="jill"></span>个<span class="jill"></span>ID。</span></div></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">Redis</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">利用</span><span class="inline-wrap"><code>redis</code></span><span class="inline-wrap">的 </span><span class="inline-wrap"><code>incr</code></span><span class="inline-wrap">命令实现<span class="jill"></span>ID<span class="jill"></span>的原子性自增。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">用</span><span class="inline-wrap"><code>redis</code></span><span class="inline-wrap">实现需要注意一点，要考虑到<span class="jill"></span>redis<span class="jill"></span>持久化的问题。</span><span class="inline-wrap"><code>redis</code></span><span class="inline-wrap">有两种持久化方式</span><span class="inline-wrap"><code>RDB</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>AOF</code></span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>RDB</code></span><span class="inline-wrap">会定时打一个快照进行持久化，假如连续自增但</span><span class="inline-wrap"><code>redis</code></span><span class="inline-wrap">没及时持久化，而这会<span class="jill"></span>Redis<span class="jill"></span>挂掉了，重启<span class="jill"></span>Redis<span class="jill"></span>后会出现<span class="jill"></span>ID<span class="jill"></span>重复的情况。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>AOF</code></span><span class="inline-wrap">会对每条写命令进行持久化，绝大多数情况下不会出现数据丢失，但由于<span class="jill"></span>incr<span class="jill"></span>命令的特殊性，会导致</span><span class="inline-wrap"><code>Redis</code></span><span class="inline-wrap">重启恢复的数据时间过长。</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">⭐️⭐️⭐️ 雪花算法(SnowFlake)⭐️⭐️⭐️</span></summary><h2 class="wolai-block"><span class="inline-wrap">雪花<span class="jill"></span>Id</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">雪花算法在 Java 中默认使用 Long，它是 64 位，各个位的含义如下：</span></div></div><div class="wolai-block wolai-center"><figure><img src="https://cdn.nlark.com/yuque/0/2020/png/203689/1609150636502-3a9e2cf2-2046-4158-9970-8181b6224850.png#align=left&amp;display=inline&amp;height=72&amp;margin=%5Bobject%20Object%5D&amp;name=&amp;originHeight=72&amp;originWidth=1438&amp;size=0&amp;status=done&amp;style=none&amp;width=1438" style="width: 719px"/></figure></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">第一位组：首位写死为<span class="jill"></span>0，表示只会生成正数</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">第二位组：41<span class="jill"></span>位，存储的时间戳单位为毫秒，实际存储量位：2^41/1000_60_60_24_365 = 69，即时间戳最多支持 69 年，一般都是使用 </span><span class="inline-wrap"><code>System.currentTimeMillis() - initDate</code></span><span class="inline-wrap"> 差值来实现</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">第三位组：10 位，机器数，用于分布式环境下每个机器生成的值都会不一样，默认支持 2^10 = 1024 个节点生成的值不同</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">第四位组：12 位，每节点每毫秒并发数，默认为 2^12 = 4096</span></li></ul><h2 class="wolai-block"><span class="inline-wrap">雪花<span class="jill"></span>Id<span class="jill"></span>与时钟回拨</span></h2><div class="wolai-bookmark wolai-block"><a href="https://mp.weixin.qq.com/s/SVokpTtlQDUYAo6oc_PGyA">计算机时间到底是怎么来的？程序员必看的时间知识！</a><div class="info-box"><div class="text-pane"><div data-title="计算机时间到底是怎么来的？程序员必看的时间知识！"></div><div data-desc="你有想过，一秒到底有多长吗？"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://res.wx.qq.com/a/wx_fed/assets/res/MjliNWVm.svg&quot;)"></div><div data-hostname="mp.weixin.qq.com"></div></div></div><div class="preview-pane" style="background-image: url(http://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OmA3elicibmPcGeFkNtAwz9nh3Flh550AzbjRgJpg8SHzGNiagZlSOibqWDaAIt7HEtcrHMyAqiaEicia6w/0?wx_fmt=jpeg)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://cloud.tencent.com/developer/news/678423">彻底解决雪花算法时间回拨问题新方案 - 云+社区 - 腾讯云</a><div class="info-box"><div class="text-pane"><div data-title="彻底解决雪花算法时间回拨问题新方案 - 云+社区 - 腾讯云"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cloud.tencent.com/favicon.ico&quot;)"></div><div data-hostname="cloud.tencent.com"></div></div></div><div class="preview-pane"></div></div></div><h2 class="wolai-block"><span class="inline-wrap">雪花算法与<span class="jill"></span>Hash<span class="jill"></span>分表键的坑</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">在并发量不高的情况下，雪花<span class="jill"></span>Id<span class="jill"></span>后<span class="jill"></span>12<span class="jill"></span>位重复率高，且不大，直接用雪花<span class="jill"></span>Id<span class="jill"></span>与表数量取模，容易出现数据倾斜，数据写在了头几张表里面。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">解决方案是<span class="jill"></span>Id<span class="jill"></span>与高<span class="jill"></span>46<span class="jill"></span>位做异或，然后再做取模。</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://blog.liwenguang.com/2020/12/20/tech/mysql/snowflake&amp;hash.html/">雪花算法与Hash分表键的坑</a><div class="info-box"><div class="text-pane"><div data-title="雪花算法与Hash分表键的坑"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://blog.liwenguang.com/images/favicon.ico&quot;)"></div><div data-hostname="blog.liwenguang.com"></div></div></div><div class="preview-pane" style="background-image: url(https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/share.jpg)"></div></div></div></details><hr class="wolai-block"/><details class="wolai-block"><summary><div class="marker placeholder"></div><span class="inline-wrap">滴滴出品（TinyID）</span></summary></details><details class="wolai-block"><summary><div class="marker placeholder"></div><span class="inline-wrap">百度 （Uidgenerator）</span></summary></details><details class="wolai-block"><summary><div class="marker placeholder"></div><span class="inline-wrap">美团（Leaf）</span></summary></details><hr class="wolai-block"/><div class="wolai-block wolai-text"><div><span class="inline-wrap">上面这三种其实都是基于号段和雪花算法实现</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">参考文献</span></h2><div class="wolai-bookmark wolai-block"><a href="https://zhuanlan.zhihu.com/p/107939861">一口气说出9种分布式ID生成方式，面试官有点懵了</a><div class="info-box"><div class="text-pane"><div data-title="一口气说出9种分布式ID生成方式，面试官有点懵了"></div><div data-desc="一、为什么要用分布式ID？在说分布式ID的具体实现之前，我们来简单分析一下为什么用分布式ID？分布式ID应该满足哪些特征？ 1、什么是分布式ID？拿MySQL数据库举个栗子： 在我们业务数据量不大的时候，单库单表完全…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.a53ae37b.png&quot;)"></div><div data-hostname="zhuanlan.zhihu.com"></div></div></div><div class="preview-pane" style="background-image: url(https://pic2.zhimg.com/v2-1dd5a10cb221745dc8b02fff9adc0629_720w.jpg?source=172ae18b)"></div></div></div></article><footer></footer></body></html>
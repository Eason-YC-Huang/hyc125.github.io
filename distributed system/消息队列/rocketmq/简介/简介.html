<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>简介 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body class="font-kai"><header><div class="image"></div><div class="title"><div class="banner"><div data-symbol="👓" class="icon"></div></div><div data-title="简介" class="main-title"></div></div></header><article><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://github.com/apache/rocketmq/tree/master/docs/cn"><span>官方文档</span></a></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">其实消息队列的基本原理都是类似，无非就是生产者、消费者、消息服务器。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">生产者如何推送消息给消息服务器</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">消费者如何从消息服务器获取消息</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="red inline-wrap">消息服务器如何存储和管理消息</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">消息服务器如何高可用</span></li></ul><div class="wolai-bookmark wolai-block"><a href="https://tech.meituan.com/2016/07/01/mq-design.html">消息队列设计精要</a><div class="info-box"><div class="text-pane"><div data-title="消息队列设计精要"></div><div data-desc="本文从实用主义的角度，分析了消息队列的设计目的、解决的问题以及实现方式。重点关注怎么用消息队列实现补偿/最终一致性等问题并对消息重复/丢失等难点问题做了重点剖析。对于想自己动手实现消息队列有一定的参考价值。"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/android-icon-192x192.png?v=Whistle&amp;t=20181017-1r&quot;)"></div><div data-hostname="tech.meituan.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://mp.weixin.qq.com/s/I1OOFIISblXr6a_hqXkftg">云栖发布｜阿里云消息队列 RocketMQ 5.0：消息、事件、流融合处理平台</a><div class="info-box"><div class="text-pane"><div data-title="云栖发布｜阿里云消息队列 RocketMQ 5.0：消息、事件、流融合处理平台"></div><div data-desc="RocketMQ5.0 的发布标志着阿里云消息正式从消息领域正式迈向了“消息、事件、流”场景大融合的新局面。"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://res.wx.qq.com/a/wx_fed/assets/res/MjliNWVm.svg&quot;)"></div><div data-hostname="mp.weixin.qq.com"></div></div></div><div class="preview-pane" style="background-image: url(http://mmbiz.qpic.cn/sz_mmbiz_jpg/qdzZBE73hWsW7vGlKDG1LmOxJg3Ja7shO4X0YnqJ5D4ZOMWia3NSDaK6upITS3iaTNibaJ3A3kVBYhtycYv5WKTmg/0?wx_fmt=jpeg)"></div></div></div><h2 class="wolai-block"><span class="inline-wrap">核心概念</span></h2><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">RocketMQ<span class="jill"></span>由以下<span class="jill"></span>4<span class="jill"></span>个核心组件组成，分别是<span class="jill"></span>Producer、Consumer、NameServer、Broker</span><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">Broker<span class="jill"></span>注册到<span class="jill"></span>NameServer</span></li><li><div class="marker"></div><span class="inline-wrap">Producer<span class="jill"></span>和<span class="jill"></span>Consumer<span class="jill"></span>从<span class="jill"></span>NameServer<span class="jill"></span>中获取<span class="jill"></span>Broker<span class="jill"></span>的信息</span></li><li><div class="marker"></div><span class="inline-wrap">Producer<span class="jill"></span>和<span class="jill"></span>Consumer<span class="jill"></span>直接和<span class="jill"></span>Broker<span class="jill"></span>通信</span></li></ol></li><li><div class="marker"></div><span class="inline-wrap">生产消费模型</span></li></ol><div class="wolai-block wolai-center"><figure><img src="media/image.png" style="width: 611px"/></figure></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">主题：表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是<span class="jill"></span>RocketMQ<span class="jill"></span>进行消息订阅的基本单位。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">标签：为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化<span class="jill"></span>RocketMQ<span class="jill"></span>提供的查询系统。消费者可以根据<span class="jill"></span>Tag<span class="jill"></span>实现对不同子主题的不同消费逻辑，实现更好的扩展性。</span></li></ul><hr class="wolai-block"/><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">生产者有多种方式发送消息，同步发送、异步发送、顺序发送、单向发送。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">生产者组：同一类<span class="jill"></span>Producer<span class="jill"></span>的集合，这类<span class="jill"></span>Producer<span class="jill"></span>发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则<span class="jill"></span>Broker<span class="jill"></span>服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">普通顺序消息：普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">严格顺序消息：严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</span></li></ul><hr class="wolai-block"/><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">消费者有两种方式获取消息，可以消费者主动拉取消息，也可以消息服务器推送消息给消费者。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">消费者组：同一类<span class="jill"></span>Consumer<span class="jill"></span>的集合，这类<span class="jill"></span>Consumer<span class="jill"></span>通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的<span class="jill"></span>Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">集群消费：集群消费模式下，相同<span class="jill"></span>Consumer Group<span class="jill"></span>的每个<span class="jill"></span>Consumer<span class="jill"></span>实例平均分摊消息。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">广播消费：广播消费模式下，相同<span class="jill"></span>Consumer Group<span class="jill"></span>的每个<span class="jill"></span>Consumer<span class="jill"></span>实例都接收全量的消息。</span></li></ul><hr class="wolai-block"/><h2 class="wolai-block"><span class="inline-wrap">特性</span></h2><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">消息</span><span class="inline-wrap">有序</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">消息</span><span class="inline-wrap">有序</span><span class="inline-wrap">指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了三条消息分别是订单创建、订单付款、订单完成。消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的。RocketMQ<span class="jill"></span>可以严格的保证消息有序。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">顺序消息分为</span><span class="inline-wrap"><code>全局顺序</code></span><span class="inline-wrap">消息与</span><span class="inline-wrap"><code>分区顺序</code></span><span class="inline-wrap">消息，全局顺序是指某个<span class="jill"></span>Topic<span class="jill"></span>下的所有消息都要保证顺序；部分顺序消息只要保证每一组消息被顺序消费即可。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">全局顺序 对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。 适用场景：性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">分区顺序 对于指定的一个 Topic，所有消息根据 sharding key 进行区块分区。 同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。 Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念。 适用场景：性能要求高，以 sharding key 作为分区字段，在同一个区块中严格的按照 FIFO 原则进行消息发布和消费的场景。</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">消息过滤</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">RocketMQ<span class="jill"></span>的消费者可以根据<span class="jill"></span>Tag<span class="jill"></span>进行消息过滤，也支持自定义属性过滤。消息过滤目前是在<span class="jill"></span>Broker<span class="jill"></span>端实现的，优点是减少了对于<span class="jill"></span>Consumer<span class="jill"></span>无用消息的网络传输，缺点是增加了<span class="jill"></span>Broker<span class="jill"></span>的负担、而且实现相对复杂。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">定时消息</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">定时消息（延迟队列）是指消息发送到<span class="jill"></span>broker<span class="jill"></span>后，不会立即被消费，等待特定时间投递给真正的<span class="jill"></span>topic。 broker<span class="jill"></span>有配置项<span class="jill"></span>messageDelayLevel，默认值为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，18<span class="jill"></span>个<span class="jill"></span>level。可以配置自定义<span class="jill"></span>messageDelayLevel。注意，messageDelayLevel<span class="jill"></span>是<span class="jill"></span>broker<span class="jill"></span>的属性，不属于某个<span class="jill"></span>topic。发消息时，设置<span class="jill"></span>delayLevel<span class="jill"></span>等级即可：msg.setDelayLevel(level)。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">level<span class="jill"></span>有以下三种情况：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">level == 0，消息为非延迟消息</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">1&lt;=level&lt;=maxLevel，消息延迟特定时间，例如<span class="jill"></span>level==1，延迟<span class="jill"></span>1s</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">level &gt; maxLevel，则<span class="jill"></span>level== maxLevel，例如<span class="jill"></span>level==20，延迟<span class="jill"></span>2h</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">定时消息会暂存在名为<span class="jill"></span>SCHEDULE_TOPIC_XXXX<span class="jill"></span>的<span class="jill"></span>topic<span class="jill"></span>中，并根据<span class="jill"></span>delayTimeLevel<span class="jill"></span>存入特定的<span class="jill"></span>queue，queueId = delayTimeLevel – 1，即一个<span class="jill"></span>queue<span class="jill"></span>只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker<span class="jill"></span>会调度地消费<span class="jill"></span>SCHEDULE_TOPIC_XXXX，将消息写入真实的<span class="jill"></span>topic。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">需要注意的是，定时消息会在第一次写入和调度写入真实<span class="jill"></span>topic<span class="jill"></span>时都会计数，因此发送数量、tps<span class="jill"></span>都会变高。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">事务消息</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">RocketMQ<span class="jill"></span>事务消息（Transactional Message）是指应用本地事务和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败。RocketMQ<span class="jill"></span>的事务消息提供类似 X/Open XA 的分布事务功能，通过事务消息能达到分布式事务的最终一致。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">消息服务器可靠性</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">RocketMQ<span class="jill"></span>支持消息的高可靠，影响消息可靠性的几种情况：</span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">Broker<span class="jill"></span>非正常关闭</span></li><li><div class="marker"></div><span class="inline-wrap">Broker<span class="jill"></span>异常<span class="jill"></span>Crash</span></li><li><div class="marker"></div><span class="inline-wrap">OS Crash</span></li><li><div class="marker"></div><span class="inline-wrap">机器掉电，但是能立即恢复供电情况</span></li><li><div class="marker"></div><span class="inline-wrap">机器无法开机（可能是<span class="jill"></span>cpu、主板、内存等关键设备损坏）</span></li><li><div class="marker"></div><span class="inline-wrap">磁盘设备损坏</span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap">1)、2)、3)、4) 四种情况都属于硬件资源可立即恢复情况，RocketMQ<span class="jill"></span>在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">5)、6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ<span class="jill"></span>在这两种情况下，通过异步复制，可保证<span class="jill"></span>99%<span class="jill"></span>的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与<span class="jill"></span>Money<span class="jill"></span>相关的应用。注：RocketMQ<span class="jill"></span>从<span class="jill"></span>3.0<span class="jill"></span>版本开始支持同步双写。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">至少一次</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">至少一次(At least Once)指每个消息必须投递一次。Consumer<span class="jill"></span>先<span class="jill"></span>Pull<span class="jill"></span>消息到本地，消费完成后，才向服务器返回<span class="jill"></span>ack，如果没有消费一定不会<span class="jill"></span>ack<span class="jill"></span>消息，所以<span class="jill"></span>RocketMQ<span class="jill"></span>可以很好的支持此特性。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">消息重试</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">Consumer<span class="jill"></span>消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer<span class="jill"></span>消费消息失败通常可以认为有以下几种情况：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%<span class="jill"></span>也不成功，所以最好提供一种定时重试机制，即过<span class="jill"></span>10<span class="jill"></span>秒后再重试。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">由于依赖的下游应用服务不可用，例如<span class="jill"></span>db<span class="jill"></span>连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用<span class="jill"></span>sleep 30s，再消费下一条消息，这样可以减轻<span class="jill"></span>Broker<span class="jill"></span>重试消息的压力。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">RocketMQ<span class="jill"></span>会为每个消费组都设置一个<span class="jill"></span>Topic<span class="jill"></span>名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个<span class="jill"></span>Topic<span class="jill"></span>的重试队列是针对消费组，而不是针对每个<span class="jill"></span>Topic<span class="jill"></span>设置的），用于暂时保存因为各种异常而导致<span class="jill"></span>Consumer<span class="jill"></span>端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ<span class="jill"></span>对于重试消息的处理是先保存至<span class="jill"></span>Topic<span class="jill"></span>名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行<span class="jill"></span>Delay<span class="jill"></span>后重新保存至“%RETRY%+consumerGroup”的重试队列中。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">死信队列</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，消息队列会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">RocketMQ<span class="jill"></span>将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。在<span class="jill"></span>RocketMQ<span class="jill"></span>中，可以通过使用<span class="jill"></span>console<span class="jill"></span>控制台对死信队列中的消息进行重发来使得消费者实例再次进行消费。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">消息重投</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">生产者在发送消息时，同步消息失败会重投，异步消息有重试，oneway<span class="jill"></span>没有任何保证。消息重投保证消息尽可能发送成功、不丢失，但可能会造成消息重复，消息重复在<span class="jill"></span>RocketMQ<span class="jill"></span>中是无法避免的问题。消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会是大概率事件。另外，生产者主动重发、consumer<span class="jill"></span>负载变化也会导致重复消息。如下方法可以设置消息重试策略：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>retryTimesWhenSendFailed</code></span><span class="inline-wrap">:同步发送失败重投次数，默认为<span class="jill"></span>2，因此生产者会最多尝试发送</span><span class="inline-wrap"><code>retryTimesWhenSendFailed</code></span><span class="inline-wrap"> + 1<span class="jill"></span>次。不会选择上次失败的<span class="jill"></span>broker，尝试向其他<span class="jill"></span>broker<span class="jill"></span>发送，最大程度保证消息不丢。超过重投次数，抛出异常，由客户端保证消息不丢。当出现<span class="jill"></span>RemotingException、MQClientException<span class="jill"></span>和部分<span class="jill"></span>MQBrokerException<span class="jill"></span>时会重投。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>retryTimesWhenSendAsyncFailed</code></span><span class="inline-wrap">:异步发送失败重试次数，异步重试不会选择其他<span class="jill"></span>broker，仅在同一个<span class="jill"></span>broker<span class="jill"></span>上做重试，不保证消息不丢。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>retryAnotherBrokerWhenNotStoreOK</code></span><span class="inline-wrap">:消息刷盘（主或备）超时或<span class="jill"></span>slave<span class="jill"></span>不可用（返回状态非<span class="jill"></span>SEND_OK），是否尝试发送到其他<span class="jill"></span>broker，默认<span class="jill"></span>false。十分重要消息可以开启。</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">回溯消费</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">回溯消费是指<span class="jill"></span>Consumer<span class="jill"></span>已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker<span class="jill"></span>在向<span class="jill"></span>Consumer<span class="jill"></span>投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于<span class="jill"></span>Consumer<span class="jill"></span>系统故障，恢复后需要重新消费<span class="jill"></span>1<span class="jill"></span>小时前的数据，那么<span class="jill"></span>Broker<span class="jill"></span>要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ<span class="jill"></span>支持按照时间回溯消费，时间维度精确到毫秒。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">流量控制</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">生产者流控，因为<span class="jill"></span>broker<span class="jill"></span>处理能力达到瓶颈；消费者流控，因为消费能力达到瓶颈。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">生产者流控：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">commitLog<span class="jill"></span>文件被锁时间超过<span class="jill"></span>osPageCacheBusyTimeOutMills<span class="jill"></span>时，参数默认为<span class="jill"></span>1000ms，返回流控。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果开启<span class="jill"></span>transientStorePoolEnable == true，且<span class="jill"></span>broker<span class="jill"></span>为异步刷盘的主机，且<span class="jill"></span>transientStorePool<span class="jill"></span>中资源不足，拒绝当前<span class="jill"></span>send<span class="jill"></span>请求，返回流控。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">broker<span class="jill"></span>每隔<span class="jill"></span>10ms<span class="jill"></span>检查<span class="jill"></span>send<span class="jill"></span>请求队列头部请求的等待时间，如果超过<span class="jill"></span>waitTimeMillsInSendQueue，默认<span class="jill"></span>200ms，拒绝当前<span class="jill"></span>send<span class="jill"></span>请求，返回流控。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">broker<span class="jill"></span>通过拒绝<span class="jill"></span>send 请求方式实现流量控制。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">注意，生产者流控，不会尝试消息重投。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">消费者流控：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">消费者本地缓存消息数超过<span class="jill"></span>pullThresholdForQueue<span class="jill"></span>时，默认<span class="jill"></span>1000。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">消费者本地缓存消息大小超过<span class="jill"></span>pullThresholdSizeForQueue<span class="jill"></span>时，默认<span class="jill"></span>100MB。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">消费者本地缓存消息跨度超过<span class="jill"></span>consumeConcurrentlyMaxSpan<span class="jill"></span>时，默认<span class="jill"></span>2000。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">消费者流控的结果是降低拉取频率。</span></div></div></details><div class="wolai-block wolai-text"><div></div></div><h2 class="wolai-block"><span class="inline-wrap">动手体验</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">搭建<span class="jill"></span>RocketMQ<span class="jill"></span>环境</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://rocketmq.apache.org/docs/quick-start/">Quick Start</a><div class="info-box"><div class="text-pane"><div data-title="Quick Start"></div><div data-desc="How to quickly install and setup Apache RocketMQ."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://rocketmq.apache.org/favicon.ico&quot;)"></div><div data-hostname="rocketmq.apache.org"></div></div></div><div class="preview-pane"></div></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token builtin class-name">export</span> <span class="token assign-left variable">rocket_mq_home</span><span class="token operator">=</span><span class="token string">'/home/hyc/Coding/java/demo/rocketmq-all-4.9.2/distribution/target/rocketmq-4.9.2/rocketmq-4.9.2'</span>

<span class="token function-name function">_startMQ</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">nohup</span> <span class="token variable">${rocket_mq_home}</span>/bin/mqnamesrv <span class="token operator">></span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">&amp;</span>
  <span class="token function">nohup</span> <span class="token variable">${rocket_mq_home}</span>/bin/mqbroker -n localhost:9876 <span class="token operator">></span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">&amp;</span>
<span class="token punctuation">}</span>

<span class="token function-name function">_closeMQ</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token variable">${rocket_mq_home}</span>/bin/mqshutdown broker
  <span class="token variable">${rocket_mq_home}</span>/bin/mqshutdown namesrv
<span class="token punctuation">}</span>

<span class="token builtin class-name">alias</span> <span class="token assign-left variable">startMQ</span><span class="token operator">=</span>_startMQ
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">closeMQ</span><span class="token operator">=</span>_closeMQ 
</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">样例</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md">https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md</a><div class="info-box"><div class="text-pane"><div data-title="github.com"></div><div class="icon-host"><div data-hostname="github.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">最佳实践</span></h2><div class="wolai-bookmark wolai-block"><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/best_practice.md">rocketmq/best_practice.md at master · apache/rocketmq</a><div class="info-box"><div class="text-pane"><div data-title="rocketmq/best_practice.md at master · apache/rocketmq"></div><div data-desc="Mirror of Apache RocketMQ. Contribute to apache/rocketmq development by creating an account on GitHub."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://github.com/fluidicon.png&quot;)"></div><div data-hostname="github.com"></div></div></div><div class="preview-pane" style="background-image: url(https://opengraph.githubassets.com/aea5be0b1ee8b3d46e19723fdf49bb5c81940b76deae291d2de84e9711dfed61/apache/rocketmq)"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">更多阅读</span></h2><div class="wolai-bookmark wolai-block"><a href="https://help.aliyun.com/product/29530.html">阿里云帮助中心-阿里云，领先的云计算服务提供商</a><div class="info-box"><div class="text-pane"><div data-title="阿里云帮助中心-阿里云，领先的云计算服务提供商"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://img.alicdn.com/tfs/TB1_ZXuNcfpK1RjSZFOXXa6nFXa-32-32.ico&quot;)"></div><div data-hostname="help.aliyun.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>
<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>2.NIO - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="2.NIO" class="main-title"></div></div></header><article><h2 class="wolai-block"><span class="inline-wrap">大纲</span></h2><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Buffer、Channel、Selector</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Charsets</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Improved File System Interface</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AIO</span></li></ul><h2 class="wolai-block"><span class="inline-wrap">数据读写的过程</span></h2><div class="wolai-block wolai-text"><div><span class="red inline-wrap"><b>内核态、用户态、内核空间、用户空间</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">内核态与用户态是指<span class="jill"></span>CPU<span class="jill"></span>的运行状态（即特权级别），每个进程的每种<span class="jill"></span>CPU<span class="jill"></span>状态都有其运行上下文，运行上下文就包括了当前状态所使用的空间，CPU<span class="jill"></span>访问的逻辑地址（即空间）通过地址映射表映射到相应的物理地址（即物理内存）。在<span class="jill"></span>Linux<span class="jill"></span>系统中，进程的用户空间是独立的，而内核空间是公用的，进程切换时，用户空间切换，内核空间不变。对于多数<span class="jill"></span>CPU<span class="jill"></span>而言，处于内核态时，可以访问所有地址空间，而处于用户态时，就只能访问用户空间了。</span></div></div><div class="wolai-block wolai-text"><div><span class="red inline-wrap"><b>DMA</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Direct memory access (直接内存访问)，操作系统允许某些硬件系统无需经过<span class="jill"></span>CPU<span class="jill"></span>处理，直接访问物理内存。如果没有<span class="jill"></span>DMA，把数据从存储设备拷贝到内核需要一直占用<span class="jill"></span>CPU。使用<span class="jill"></span>DMA，数据拷贝时<span class="jill"></span>CPU<span class="jill"></span>可以干别的事情，数据拷贝完毕后，DMA<span class="jill"></span>控制器发送中断信号给<span class="jill"></span>CPU，告诉它数据拷贝完毕，从而提高<span class="jill"></span>CPU<span class="jill"></span>的利用率。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">读取数据</span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">应用程序向内核发起 read()调用，CPU<span class="jill"></span>由用户态转变成内核态</span></li><li><div class="marker"></div><span class="inline-wrap">内核通知存储设备读取数据，存储设备读取到数据后，通过<span class="jill"></span>DMA<span class="jill"></span>把数据写入到内核的数据缓冲区</span></li><li><div class="marker"></div><span class="inline-wrap">内核把数据缓冲区的数据复制到应用程序的数据缓冲区，CPU<span class="jill"></span>由内核态转换为用户态</span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap">写入数据</span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">应用程序向内核发起<span class="jill"></span>wirte()调用，CPU<span class="jill"></span>由用户态转变成内核态</span></li><li><div class="marker"></div><span class="inline-wrap">应用程序数据缓冲区中的数据被复制到内核的数据缓冲区</span></li><li><div class="marker"></div><span class="inline-wrap">内核把数据缓冲区中的数据写入到存储设备，完成后<span class="jill"></span>CPU<span class="jill"></span>由内核态转换为用户态</span></li></ol><div class="wolai-block wolai-center"><figure><img src="media/syscall-read.png" style="width: 760px"/></figure></div><h2 class="wolai-block"><span class="inline-wrap">Linux<span class="jill"></span>五种<span class="jill"></span>IO<span class="jill"></span>模型</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="http://byteliu.com/2019/05/08/LINUX-–-IO-MULTIPLEXING-–-SELECT-VS-POLL-VS-EPOLL/"><span>LINUX – IO MULTIPLEXING – SELECT VS POLL VS EPOLL</span></a></span></div></div><blockquote class="wolai-block"><span class="inline-wrap">​Linux<span class="jill"></span>和<span class="jill"></span>Unix<span class="jill"></span>的一个基本理念就是，一切事物皆“文件”，我们通过文件描述符（file descriptor）来指向“文件”。</span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap">去水果店买苹果，苹果卖完了</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">阻塞<span class="jill"></span>IO：你一直在水果店等，直到有苹果了</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">非阻塞<span class="jill"></span>IO：你时不时去水果店看苹果到货了没，有苹果了就买</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">异步<span class="jill"></span>IO：你告诉店家，有苹果了，直接送到你家</span></div></div><blockquote class="wolai-block"><span class="inline-wrap">同步和异步，例如你要发起并处理<span class="jill"></span>100<span class="jill"></span>个请求，同步的话发起一个请求处理一个响应，异步的话尽可能发起请求，接收到响应就处理响应，从而缩短等待响应的时间</span></blockquote><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">阻塞<span class="jill"></span>I/O<span class="jill"></span>模型</span></summary><div class="wolai-block wolai-center"><figure><img src="media/blocking-io.png" style="width: 523px"/></figure></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">非阻塞<span class="jill"></span>I/O<span class="jill"></span>模型</span></summary><div class="wolai-block wolai-center"><figure><img src="media/no-blocking-io.png" style="width: 533px"/></figure></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">异步<span class="jill"></span>I/O<span class="jill"></span>模型</span></summary><div class="wolai-block wolai-center"><figure><img src="media/asynchronous-io.png" style="width: 523px"/></figure></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">I/O<span class="jill"></span>多路复用模型
</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">多路复用技术原本指的是，在通信方面，多种信号或数据（从宏观上看）交织在一起，使用同一条传输通道进行传输， 这里的重点就是处理好“混合”和“分离”，对于不同的信号或数据，有不同的处理方法。</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/io-multiplexing.png" style="width: 532px"/></figure></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">信号驱动<span class="jill"></span>I/O<span class="jill"></span>模型（很少用）</span></summary><div class="wolai-block wolai-center"><figure><img src="media/signal-driven-io.png" style="width: 531px"/></figure></div></details><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>同步<span class="jill"></span>IO<span class="jill"></span>与异步<span class="jill"></span>IO</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">按照《Unix<span class="jill"></span>网络编程》的划分，IO<span class="jill"></span>模型可以分为：阻塞<span class="jill"></span>IO、非阻塞<span class="jill"></span>IO、异步<span class="jill"></span>IO、IO<span class="jill"></span>复用、信号驱动<span class="jill"></span>IO<span class="jill"></span>和，按照<span class="jill"></span>POSIX<span class="jill"></span>标准来划分只分为两类：同步<span class="jill"></span>IO<span class="jill"></span>和异步<span class="jill"></span>IO。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如何区分呢？首先一个<span class="jill"></span>IO<span class="jill"></span>操作(read/write<span class="jill"></span>系统调用)其实分成了两个步骤：</span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">发起<span class="jill"></span>IO<span class="jill"></span>请求</span></li><li><div class="marker"></div><span class="inline-wrap">实际的<span class="jill"></span>IO<span class="jill"></span>读写(内核态与用户态的数据拷贝)</span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap">阻塞<span class="jill"></span>IO<span class="jill"></span>和非阻塞<span class="jill"></span>IO<span class="jill"></span>的区别在于第一步，发起<span class="jill"></span>IO<span class="jill"></span>请求的进程是否会被阻塞，如果阻塞直到<span class="jill"></span>IO<span class="jill"></span>操作完成才返回那么就是传统的阻塞<span class="jill"></span>IO，如果不阻塞，那么就是非阻塞<span class="jill"></span>IO。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">同步<span class="jill"></span>IO<span class="jill"></span>和异步<span class="jill"></span>IO<span class="jill"></span>的区别就在于第二步，实际的<span class="jill"></span>IO<span class="jill"></span>读写(内核态与用户态的数据拷贝)是否需要进程参与，如果需要进程参与则是同步<span class="jill"></span>IO，如果不需要进程参与就是异步<span class="jill"></span>IO。如果实际的<span class="jill"></span>IO<span class="jill"></span>读写需要请求进程参与，那么就是同步<span class="jill"></span>IO。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">因此阻塞<span class="jill"></span>IO、非阻塞<span class="jill"></span>IO、IO<span class="jill"></span>复用、信号驱动<span class="jill"></span>IO<span class="jill"></span>都是同步<span class="jill"></span>IO，在编程上，这种非阻塞<span class="jill"></span>IO<span class="jill"></span>一般都采用<span class="jill"></span>IO<span class="jill"></span>状态事件<span class="jill"></span>+<span class="jill"></span>回调方法的方式来处理<span class="jill"></span>IO<span class="jill"></span>操作。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果是同步<span class="jill"></span>IO，则状态事件为读写就绪。此时的数据仍在内核态中，但是已经准备就绪，可以进行<span class="jill"></span>IO<span class="jill"></span>读写操作。如果是异步<span class="jill"></span>IO，则状态事件为读写完成。此时的数据已经存在于应用进程的地址空间（用户态）中。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://zhuanlan.zhihu.com/p/63179839"><span>select poll epoll</span></a></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://medium.com/@copyconstruct/nonblocking-i-o-99948ad7c957"><span>no-blocking-io</span></a></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://medium.com/@copyconstruct/the-method-to-epolls-madness-d9d2d6378642"><span>The method to epoll’s madness</span></a></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;mid=2247484195&amp;idx=1&amp;sn=95c3acdaeb0f6a1d61f152550c3d2669&amp;chksm=fc3338d3cb44b1c55f6046f6280da863d3514cca3ce50ef29e2d53b0eafe2b7efef062c51c27&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1575453175479&amp;sharer_shareid=9a8d1439d544eab40271032dc409c9d3&amp;key=2b64422501ce845acaade67fda4325379d9377b321bfe1b28cc07b091f241a43f997456546e6a0d1b06362ce28252e1bf1eec87bd79ad02d2ae75677fbf74cbcfcb447c99d17457239f7215f57ea06db&amp;ascene=1&amp;uin=MjM0MTI1OTQwMA%3D%3D&amp;devicetype=Windows+10&amp;version=62070158&amp;lang=zh_CN&amp;exportkey=AXjcM4lpBTtitw2HJAQ76kw%3D&amp;pass_ticket=zyuINiO%2BU4JW3CFy2AuztTMx3s8xS0l8WkUqBCHEZAs8cmGMotPO7G54TIRIXVo5"><span>BIO NIO AIO</span></a></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;mid=2247484201&amp;idx=1&amp;sn=7cf45aff64eecdff58d2acea8fb7c9fa&amp;chksm=fc3338d9cb44b1cfc6b5c797a005c91ed19b0dd06587fdfb2e7b553e2b03104a145380a7a990&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1575453188434&amp;sharer_shareid=9a8d1439d544eab40271032dc409c9d3&amp;key=76fbcf3929fe6ccdc15634c166460c24ec92a443e8081a497a13ddbcc18189d411f2544add1ceaac08f0aa3aecbce41a38311cbc19a5695d0ae8cb70d54549ffe368f85a4a760d104ddbef0638f977a6&amp;ascene=1&amp;uin=MjM0MTI1OTQwMA%3D%3D&amp;devicetype=Windows+10&amp;version=62070158&amp;lang=zh_CN&amp;exportkey=AQoCy6s%2BX6YKNinm6DZMSIQ%3D&amp;pass_ticket=zyuINiO%2BU4JW3CFy2AuztTMx3s8xS0l8WkUqBCHEZAs8cmGMotPO7G54TIRIXVo5"><span>I/O<span class="jill"></span>多路复用</span></a></span></div></div><h2 class="wolai-block"><span class="inline-wrap">零拷贝、内存映射、Java NIO<span class="jill"></span>浅析</span></h2><h3 class="wolai-block"><span class="inline-wrap">零拷贝</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">有些时候，我们的程序需要把一个文件原封不动的从一个地方拷贝到另一个地方。在<span class="jill"></span>Java<span class="jill"></span>中，实现该需求的常用方法就是使用</span><span class="inline-wrap"><code>InputStream</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>OutputStream</code></span><span class="inline-wrap">。然后这种方法对性能不怎么友好，从上面数据读写过程我们知道，一次读写过程需要经历<span class="jill"></span>4<span class="jill"></span>次状态转换和<span class="jill"></span>4<span class="jill"></span>次数据复制</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">但是其实对于数据拷贝来说，有<span class="jill"></span>2<span class="jill"></span>次状态转换和<span class="jill"></span>2<span class="jill"></span>次数据复制是多余的，零拷贝技术可以让我们减少这不必要的<span class="jill"></span>2<span class="jill"></span>次状态转换和<span class="jill"></span>2<span class="jill"></span>次复制。</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/zero-copy.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Note: Java’s NIO offers this through </span><span class="inline-wrap"><code>transferTo</code></span><span class="inline-wrap"> (</span><span class="inline-wrap"><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/FileChannel.html#transferTo-long-long-java.nio.channels.WritableByteChannel-"><span>doc</span></a></span><span class="inline-wrap">).</span></div></div><h3 class="wolai-block"><span class="inline-wrap">内存映射</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">零拷贝也有它的缺点，就是应用程序无法对数据进行修改，那么我们就真的只能用原始方法，把数据拷贝到内核，再拷贝到用户空间，然后再对数据进行修改，然后原路返回吗？不不不，还有一种方法，那就是内存映射。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">Java NIO</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java NIO 主要由以下三个组件组成:</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Channel、Buffers、Selector</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">通过<span class="jill"></span>Channel<span class="jill"></span>往<span class="jill"></span>Buffers<span class="jill"></span>中读取或写入数据，通过</span><span class="inline-wrap"><code>Selector</code></span><span class="inline-wrap"> 我们可以使用一条线程处理多个</span><span class="inline-wrap"><code>Channel</code></span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div><div class="wolai-block wolai-center"><figure><img src="media/overview-channels-buffers.png" style="width: 376px"/></figure></div><div class="wolai-block wolai-center"><figure><img src="media/overview-selectors.png" style="width: 356px"/></figure></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java NIO<span class="jill"></span>对</span><span class="inline-wrap"><code>Channel</code></span><span class="inline-wrap">的核心实现</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>FileChannel</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>DatagramChannel</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SocketChannel</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>ServerSocketChannel</code></span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java NIO 对 </span><span class="inline-wrap"><code>Buffer</code></span><span class="inline-wrap"> 的核心实现:</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>ByteBuffer</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>CharBuffer</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>DoubleBuffer</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>FloatBuffer</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>IntBuffer</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>LongBuffer</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>ShortBuffer</code></span></li></ul><h3 class="wolai-block"><span class="inline-wrap">Buffer</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">Buffers<span class="jill"></span>是<span class="jill"></span>NIO<span class="jill"></span>的核心之一，I/O<span class="jill"></span>服务通过<span class="jill"></span>channels<span class="jill"></span>往<span class="jill"></span>Buffers<span class="jill"></span>中读取或写入数据</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>ByteBuffer</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java NIO introduces </span><span class="inline-wrap"><code>ByteBuffer</code></span><span class="inline-wrap"> which represents the buffer area used for channels. There are 3 main implementations of </span><span class="inline-wrap"><code>ByteBuffer</code></span><span class="inline-wrap">:</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>HeapByteBuffer</code></span><span class="inline-wrap">：This is used when </span><span class="inline-wrap"><code>ByteBuffer.allocate()</code></span><span class="inline-wrap"> is called. It’s called heap because it’s maintained in JVM’s heap space and hence you get all benefits like GC support and caching optimization. However, it’s not page aligned, which means if you need to talk to native code through JNI, JVM would have to make a copy to the aligned buffer space.</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>DirectByteBuffer</code></span><span class="inline-wrap">：Used when </span><span class="inline-wrap"><code>ByteBuffer.allocateDirect()</code></span><span class="inline-wrap"> is called. JVM will allocate memory space outside the heap space using </span><span class="inline-wrap"><code>malloc()</code></span><span class="inline-wrap">. Because it’s not managed by JVM, your memory space is page-aligned and not subject to GC, which makes it perfect candidate for working with native code (e.g. when writing OpenGL stuff). However, you are then “deteriorated” to C programmer as you’ll have to allocate and deallocate memory yourself to prevent memory leak.</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>MappedByteBuffer</code></span><span class="inline-wrap">：Used when </span><span class="inline-wrap"><code>FileChannel.map()</code></span><span class="inline-wrap"> is called. Similar to </span><span class="inline-wrap"><code>DirectByteBuffer</code></span><span class="inline-wrap"> this is also outside of JVM heap. It essentially functions as a wrapper around OS mmap() system call in order for code to directly manipulate mapped physical memory data.</span></li></ul></article><footer></footer></body></html>
<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>对象的生命周期 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="对象的生命周期" class="main-title"></div></div></header><article><div class="wolai-block wolai-text"><div><span class="inline-wrap">对象的生命周期指的是对象从创建到销毁这一过程。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">1.对象的创建方式与过程</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>1.1<span class="jill"></span>有<span class="jill"></span>4<span class="jill"></span>种显式地创建对象的方式：</b></span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">new</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">反射</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对象的<span class="jill"></span>clone<span class="jill"></span>方法</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">反序列化手段</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>1.2<span class="jill"></span>对象的创建过程</b></span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">给对象分配内存</span></li><li><div class="marker"></div><span class="inline-wrap">将对象的实例变量自动初始化为其变量类型的默认值</span></li><li><div class="marker"></div><span class="inline-wrap">初始化对象，主要负责给实例变量赋予正确的初始值</span></li></ol><blockquote class="wolai-block"><span class="inline-wrap">对于第<span class="jill"></span>3<span class="jill"></span>步，不同方法创建对象其初始化不一样
clone<span class="jill"></span>方法创建的，那就把被克隆对象的实例变量的值复制到新对象中
如果对象是通过反序列化方式创建了，那就从输入流中读入数据来初始化</span></blockquote><h2 class="wolai-block"><span class="inline-wrap">垃圾回收</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">当对象被创建后，就会在<span class="jill"></span>Java<span class="jill"></span>虚拟机的堆区中拥有一块内存，如果对象没用了，那么就<span class="jill"></span>Java<span class="jill"></span>虚拟机的垃圾回收器就会回收对象。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">无用对象的判定</span></h3><h4 class="wolai-block"><span class="inline-wrap">引用计数算法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">给对象添加一个引用计数器，每当有一个地方引用它，引用次数加<span class="jill"></span>1。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">缺点：难以解决循环引用问题。</span></div></div><h4 class="wolai-block"><span class="inline-wrap">可达性分析算法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">可达性分析算法通过一系列称为</span><span class="inline-wrap"><code>GC Roots</code></span><span class="inline-wrap">的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到</span><span class="inline-wrap"><code>GC Roots</code></span><span class="inline-wrap">之间没有那么的引用链，则说明该对象不可用。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在 Hotspot 中，</span><span class="inline-wrap"><code>GC Roots</code></span><span class="inline-wrap">集合中包含了 5 个元素:</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">虚拟机栈内的对象引用</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">本地方法栈内的对象引用</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">运行时常量池中的对象引用</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方法区中类静态属性的对象引用</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">一个类对应的唯一数据类型的 Class 对象</span></li></ul><div class="wolai-bookmark wolai-block"><a href="https://medium.com/swlh/https-medium-com-dredwardhyde-how-does-hotspot-jvm-scan-the-root-set-31c0bdbf3271">https://medium.com/swlh/https-medium-com-dredwardhyde-how-does-hotspot-jvm-scan-the-root-set-31c0bdbf3271</a><div class="info-box"><div class="text-pane"><div data-title="medium.com"></div><div class="icon-host"><div data-hostname="medium.com"></div></div></div><div class="preview-pane"></div></div></div><h4 class="wolai-block"><span class="inline-wrap">对象的触及状态</span></h4><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">可触及状态：对象被创建后，有引用变量引用它。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">可复活状态：对象没有被任何引用变量引用。如果该对象重写了</span><span class="inline-wrap"><code>finalize()</code></span><span class="inline-wrap">方法，并且这时候它的</span><span class="inline-wrap"><code>finalize()</code></span><span class="inline-wrap">还没被虚拟机调用过，那么这个对象将会被放置在一个名为 F-Queue 的队列之中,并在稍后由一条由虚拟机自动建立的、低优先级的</span><span class="inline-wrap"><code>Finalizer</code></span><span class="inline-wrap">线程去执行。对象可以在</span><span class="inline-wrap"><code>finalize()</code></span><span class="inline-wrap">方法中通过把自己重新添加到引用链上实现自我拯救（例如把自己</span><span class="inline-wrap"><code>this</code></span><span class="inline-wrap">赋值给某个类变量或对象的成员变量），稍后<span class="jill"></span>GC<span class="jill"></span>将对<span class="jill"></span>F-Queue<span class="jill"></span>中的对象进行第二次小规模的标记，如果对象这时候还是不在引用链上，那它就真的要被回收了</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">不可触及状态：对象执行了</span><span class="inline-wrap"><code>finalize</code></span><span class="inline-wrap">方法后没有恢复成可触及状态，就会变成不可触及状态，这时候垃圾回收器才会真正的收回它占用的内存。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">注意：虚拟机会执行</span><span class="inline-wrap"><code>finalize()</code></span><span class="inline-wrap">方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在</span><span class="inline-wrap"><code>finalize()</code></span><span class="inline-wrap">方法中执行缓慢，或者发生了死循环(更极端的情况)，很可能会导致 F-Queue 队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。</span></div></div><h4 class="wolai-block"><span class="inline-wrap">finalize<span class="jill"></span>方法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>finalize</code></span><span class="inline-wrap">方法定义在<span class="jill"></span>Object<span class="jill"></span>类</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://juejin.im/post/5b82c02df265da436152f5ad"><span>理解<span class="jill"></span>Java<span class="jill"></span>的强引用、软引用、弱引用和虚引用</span></a></span></div></div><h3 class="wolai-block"><span class="inline-wrap">3.2<span class="jill"></span>垃圾收集算法</span></h3><h4 class="wolai-block"><span class="inline-wrap">标记-清除算法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Mark and Sweep</b></span><span class="inline-wrap"> ：标记出需要回收的对象，然后统一回收所有被标记的对象。</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/gc-mark-sweep.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">缺点：对象清除后产生大量不连续的内存碎片，还需要额外记录空闲内存的位置和大小。</span></div></div><h4 class="wolai-block"><span class="inline-wrap">标记-清除-整理算法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Mark-Sweep-Compact</b></span></div></div><div class="wolai-block wolai-center"><figure><img src="media/gc-mark-sweep-compact.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">添加了一个压缩操作，把存活对象往一边移动，解决内存碎片问题。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">缺点：需要移动对象，并更新对这些对象的引用</span></div></div><h4 class="wolai-block"><span class="inline-wrap">标记-复制算法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Mark and Copy</b></span><span class="inline-wrap"> ：把内存分为两部分，当其中一块内存用完，就把该内存中存活的对象复制到另一块内存中。</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/gc-mark-and-copy-in-java.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">优点：移动和标记可以同时进行，同时还避免内存碎片问题</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">缺点： 每次只能使用一半的内存</span></div></div><h4 class="wolai-block"><span class="inline-wrap">分代收集算法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">根据对象存活周期的不同将内存划分为几块。一般分为新生代和老年代，然后根据各个年代的特点采用合适的收集算法。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">新生代朝生夕死，所以采用复制算法，老年代通常采用标记-清除-整理算法。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">关于新生代、老年代请看</span><span class="inline-wrap"><a href="https://www.cnblogs.com/snowwhite/p/9532311.html"><span>新生代、老年代</span></a></span><span class="inline-wrap">。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">3.3<span class="jill"></span>垃圾收集器</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。垃圾收集器有很多种，有的作用于新生代，有的作用于老年代，有的老少通吃。</span></div></div><div class="wolai-block wolai-text"><div><span class="red inline-wrap"><b>S</b></span><span class="red inline-wrap">TW、</span><span class="red inline-wrap"><b>并发</b></span><span class="red inline-wrap">、</span><span class="red inline-wrap"><b>并行</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在讲垃圾收集器之前，需要先了解三个术语，分别是</span><span class="inline-wrap"><b>stop the world</b></span><span class="inline-wrap">、</span><span class="inline-wrap"><b>并发</b></span><span class="inline-wrap">、</span><span class="inline-wrap"><b>并行</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>stop the world</b></span><span class="inline-wrap"> 指的就是垃圾回收时，应用线程会被暂停</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在垃圾收集器中，并发和并行的意思跟我们平时了解的有点不一样，在垃圾收集器中，</span><span class="inline-wrap"><b>并行</b></span><span class="inline-wrap">指的是，垃圾回收是通过多个线程来完成的，</span><span class="inline-wrap"><b>并发</b></span><span class="inline-wrap">指的是，垃圾回收线程与应用线程同时运行。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">一个垃圾收集器可以用以上<span class="jill"></span>3<span class="jill"></span>个术语进行组合描述，例如一个并行并发收集器，讲的就是一个收集器，利用多线程进行垃圾回收，在回收时不需要暂停应用线程。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Hotspot<span class="jill"></span>提供的垃圾收集器：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">不进行垃圾收集：</span><span class="inline-wrap">Incremental</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">作用于新生代垃圾收集器：</span><span class="inline-wrap"><b>Serial</b></span><span class="inline-wrap">、Parallel Scavenge</span><span class="inline-wrap"><b>、</b></span><span class="inline-wrap">Parallel New</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">作用于老年代的垃圾收集器：</span><span class="inline-wrap"><b>Serial Old、</b></span><span class="inline-wrap">Parallel Old、</span><span class="inline-wrap">CMS</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">作用于新生代和老年代的垃圾收集器：G1</span></div></div><div class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 246.66666666666666px"><span class="inline-wrap">新生代</span></th><th style="width: 246.66666666666666px"><span class="inline-wrap">老年代</span></th><th style="width: 246.66666666666666px"><span class="inline-wrap"><b></b></span><span class="inline-wrap"><b>JVM options</b></span></th></tr></thead><tbody><tr><td><span class="inline-wrap">Incremental</span></td><td><span class="inline-wrap">Incremental</span></td><td><span class="inline-wrap">-Xincgc</span></td></tr><tr><td><span class="inline-wrap"><b></b></span><span class="inline-wrap"><b>Serial</b></span></td><td><span class="inline-wrap"><b></b></span><span class="inline-wrap"><b>Serial Old</b></span></td><td><span class="inline-wrap"><b></b></span><span class="inline-wrap"><b>-XX:+UseSerialGC</b></span></td></tr><tr><td><span class="inline-wrap">Parallel Scavenge</span></td><td><span class="inline-wrap">Serial Old</span></td><td><span class="inline-wrap">-XX:+UseParallelOldGC</span></td></tr><tr><td><span class="inline-wrap">Parallel New</span></td><td><span class="inline-wrap">Serial Old</span></td><td><span class="inline-wrap">-XX:+UseParNewGC</span></td></tr><tr><td><span class="inline-wrap">Serial</span></td><td><span class="inline-wrap">Parallel Old</span></td><td><span class="inline-wrap">N/A</span></td></tr><tr><td><span class="inline-wrap"><b></b></span><span class="inline-wrap"><b>Parallel Scavenge</b></span></td><td><span class="inline-wrap"><b></b></span><span class="inline-wrap"><b>Parallel Old</b></span></td><td><span class="inline-wrap"><b>-XX:+UseParallelGC</b></span></td></tr><tr><td><span class="inline-wrap">Parallel New</span></td><td><span class="inline-wrap">Parallel Old</span></td><td><span class="inline-wrap">N/A</span></td></tr><tr><td><span class="inline-wrap">Serial</span></td><td><span class="inline-wrap">CMS</span></td><td><br/></td></tr><tr><td><span class="inline-wrap">Parallel Scavenge</span></td><td><span class="inline-wrap">CMS</span></td><td><span class="inline-wrap">N/A</span></td></tr><tr><td><span class="inline-wrap"><b></b></span><span class="inline-wrap"><b>Parallel New</b></span></td><td><span class="inline-wrap"><b></b></span><span class="inline-wrap"><b>CMS</b></span></td><td><span class="inline-wrap"><b>-XX:+UseParNewGC 
-XX:+UseConcMarkSweepGC</b></span></td></tr><tr><td><span class="inline-wrap"><b></b></span><span class="inline-wrap"><b>G1</b></span></td><td><span class="inline-wrap"><b></b></span><span class="inline-wrap"><b>G1</b></span></td><td><span class="inline-wrap"><b></b></span><span class="inline-wrap"><b>-XX:+UseG1GC</b></span></td></tr></tbody></table></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">看上去好像很多选择，但我们只需要记住加粗的就可以了，总结起来就是</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生代和老年代都是串行回收（GC<span class="jill"></span>时需要停止应用线程）</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生代和老年代都是并行回收</span><span class="inline-wrap">（GC<span class="jill"></span>时需要停止应用线程）</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生代并行回收，老年代使用<span class="jill"></span>CMS<span class="jill"></span>并发回收（新生代<span class="jill"></span>GC<span class="jill"></span>时需要停止应用线程，老年代<span class="jill"></span>GC<span class="jill"></span>时部分阶段需要停止应用线程）</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生代和老年代使用<span class="jill"></span>G1<span class="jill"></span>并发回收（GC<span class="jill"></span>时部分阶段需要停止应用线程）</span></li></ul><h4 class="wolai-block"><span class="inline-wrap">Minor GC、Major GC、Full GC</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">Minor GC：清理年轻代</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Major GC：清理老年代</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Full GC：清理年轻代和老年代</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">针对<span class="jill"></span>HotSpot VM<span class="jill"></span>的实现，它里面的<span class="jill"></span>GC<span class="jill"></span>其实准确分类只有两大种：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Partial GC(局部<span class="jill"></span>GC)：并不收集整个<span class="jill"></span>GC<span class="jill"></span>堆的模式</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Young GC：只收集<span class="jill"></span>young gen<span class="jill"></span>的<span class="jill"></span>GC</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Old GC：只收集<span class="jill"></span>old gen<span class="jill"></span>的<span class="jill"></span>GC</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Mixed GC：收集整个<span class="jill"></span>young gen<span class="jill"></span>以及部分<span class="jill"></span>old gen<span class="jill"></span>的<span class="jill"></span>GC</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Full GC(全局<span class="jill"></span>GC)：收集整个堆，包括<span class="jill"></span>young gen、old gen、perm gen（如果存在的话）等所有部分的模式。</span></li></ul><h4 class="wolai-block"><span class="inline-wrap">Serial GC</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">分代的单线程收集器，新生代使用</span><span class="inline-wrap"><b>标记－复制</b></span><span class="inline-wrap">，老年代使用</span><span class="inline-wrap"><b>标记－清除－整理</b></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集完成。</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/image.png" style="width: 760px"/></figure></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre>java <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UseSerialGC</span> <span class="token operator">-</span>jar <span class="token class-name">Application</span><span class="token punctuation">.</span>java</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">进阶 </span><span class="inline-wrap"><a href="https://www.infoq.com/presentations/JVM-Performance-Tuning-twitter-QCon-London-2012"><span>Serial Garbage Collector</span></a></span></div></div><h4 class="wolai-block"><span class="inline-wrap">Parallel GC</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">分代的多线程的垃圾收集器，新生代使用</span><span class="inline-wrap"><b>标记－复制</b></span><span class="inline-wrap">，老年代使用</span><span class="inline-wrap"><b>标记－清除－整理</b></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集完成。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">对于新生代，Hotspot<span class="jill"></span>提供两种并行垃圾收集器，分别是<span class="jill"></span>Parallel New 和 Parallel Scavenge</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/image_1.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">并行收集器有时候也被称为吞吐量收集器，所谓吞吐量就是<span class="jill"></span>CPU<span class="jill"></span>用于运行用户代码的时间与<span class="jill"></span>CPU<span class="jill"></span>总消耗时间的比值，即 吞吐量=运行用户代码时间/（运行用户代码时间<span class="jill"></span>+<span class="jill"></span>垃圾收集时间）。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>-XX:+PrintGCDateStamps  -XX:+PrintGCTimeStamps</pre></div></code-block><div class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 246.66666666666666px"><span class="inline-wrap">新生代</span></th><th style="width: 246.66666666666666px"><span class="inline-wrap">老年代</span></th><th style="width: 246.6640625px"><span class="inline-wrap"><b></b></span><span class="inline-wrap"><b>JVM options</b></span></th></tr></thead><tbody><tr><td><span class="inline-wrap">Parallel Scavenge</span></td><td><span class="inline-wrap">Serial Old</span></td><td><span class="inline-wrap">-XX:+UseParallelOldGC</span></td></tr><tr><td><span class="inline-wrap"><a href="https://www.cnblogs.com/codehaogg/p/13365572.html"><span>Parallel New</span></a></span></td><td><span class="inline-wrap">Serial Old</span></td><td><span class="inline-wrap">-XX:+UseParNewGC</span></td></tr><tr><td><span class="inline-wrap"><a href="https://blog.csdn.net/luzhensmart/article/details/87902385"><span><b>Parallel Scavenge</b></span></a></span></td><td><span class="inline-wrap"><b></b></span><span class="inline-wrap"><b>Parallel Old</b></span></td><td><span class="inline-wrap">-XX:+UseParallelGC</span></td></tr><tr><td><span class="inline-wrap"><b></b></span><span class="inline-wrap"><b>Parallel New</b></span></td><td><span class="inline-wrap"><b></b></span><span class="inline-wrap"><b>CMS</b></span></td><td><span class="inline-wrap"><b>-XX:+UseParNewGC 
-XX:+UseConcMarkSweepGC</b></span></td></tr></tbody></table></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在注重吞吐量以及<span class="jill"></span>CPU<span class="jill"></span>资源敏感的场合，都可以优先考虑<span class="jill"></span>Parallel Scavenger 加 Parallel Old<span class="jill"></span>收集器。</span></div></div><h4 class="wolai-block"><span class="inline-wrap">CMS</span></h4><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">简介</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">CMS (Concurrent Mark Sweep)是一款作用于老年代的使用标记清除算法的垃圾收集器。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">CMS<span class="jill"></span>只能搭配新生代</span><span class="inline-wrap"><b>Parallel New</b></span><span class="inline-wrap">垃圾回收器一起使用。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">CMS<span class="jill"></span>适合堆内存大、CPU<span class="jill"></span>核数多的服务器端应用，也是<span class="jill"></span>G1<span class="jill"></span>出现之前大型应用的首选收集器。CMS<span class="jill"></span>在<span class="jill"></span>JDK9<span class="jill"></span>以后被废弃了，JDK9<span class="jill"></span>默认使用<span class="jill"></span>G1<span class="jill"></span>收集器。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre>java <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UseConcMarkSweepGC</span> <span class="token operator">-</span>jar <span class="token class-name">Application</span><span class="token punctuation">.</span>java</pre></div></code-block></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">内存布局</span></summary><div class="wolai-block wolai-text"><div><span class="red inline-wrap">新生代(伊甸区、幸存区<span class="jill"></span>1、幸存区<span class="jill"></span>2)、老年代</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">内存分配策略</span></summary><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">对象优先在<span class="jill"></span>Eden<span class="jill"></span>分配</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">大多数情况下，对象在新生代<span class="jill"></span>Eden<span class="jill"></span>区中分配。当<span class="jill"></span>Eden<span class="jill"></span>区没有足够空间进行分配时，虚拟机将发起一次<span class="jill"></span>Minor GC。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">大对象直接进入老年代</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">大对象就是指需要大量连续内存空间的<span class="jill"></span>Java<span class="jill"></span>对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">HotSpot<span class="jill"></span>虚拟机提供了</span><span class="inline-wrap"><code>-XX:PretenureSizeThreshold</code></span><span class="inline-wrap">参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在</span><span class="inline-wrap"><code>Eden</code></span><span class="inline-wrap">区及两个</span><span class="inline-wrap"><code>Survivor</code></span><span class="inline-wrap">区之间来回复制，产生大量的内存复制操作。</span></div></div><blockquote class="bg-cultured wolai-block"><span class="inline-wrap"><code>-XX:PretenureSizeThreshold</code></span><span class="inline-wrap">参数只对<span class="jill"></span>Serial<span class="jill"></span>和<span class="jill"></span>ParNew<span class="jill"></span>两款新生代收集器有效，HotSpot<span class="jill"></span>的其他新生代收集器，如<span class="jill"></span>ParallelScavenge、G1<span class="jill"></span>并不支持这个参数。如果必须使用此参数进行调优，可考虑<span class="jill"></span>ParNew<span class="jill"></span>加<span class="jill"></span>CMS<span class="jill"></span>的收集器组合。</span></blockquote></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">长期存活的对象将进入老年代</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">HotSpot<span class="jill"></span>虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中。对象通常在<span class="jill"></span>Eden<span class="jill"></span>区里诞生，如果经过第一次<span class="jill"></span>Minor GC<span class="jill"></span>后仍然存活，并且能被<span class="jill"></span>Survivor<span class="jill"></span>容纳的话，该对象会被移动到<span class="jill"></span>Survivor<span class="jill"></span>空间中，并且将其对象年龄设为<span class="jill"></span>1<span class="jill"></span>岁。对象在<span class="jill"></span>Survivor<span class="jill"></span>区中每熬过一次<span class="jill"></span>Minor GC，年龄就增加<span class="jill"></span>1<span class="jill"></span>岁，当它的年龄增加到一定程度（默认为<span class="jill"></span>15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数</span><span class="inline-wrap"><code>-XX:MaxTenuringThreshold</code></span><span class="inline-wrap">设置。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">动态对象年龄判定</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">HotSpot<span class="jill"></span>虚拟机并不是永远要求对象的年龄必须达到</span><span class="inline-wrap"><code>-XX:MaxTenuringThreshold</code></span><span class="inline-wrap">才能晋升老年代，如果在<span class="jill"></span>Survivor<span class="jill"></span>空间中相同年龄所有对象大小的总和大于<span class="jill"></span>Survivor<span class="jill"></span>空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到</span><span class="inline-wrap"><code>-XX:MaxTenuringThreshold</code></span><span class="inline-wrap">中要求的年龄。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">空间分配担保</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">在发生<span class="jill"></span>Minor GC<span class="jill"></span>之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次<span class="jill"></span>Minor GC<span class="jill"></span>可以确保是安全的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果不成立，则虚拟机会先查看</span><span class="inline-wrap"><code>-XX:HandlePromotionFailure</code></span><span class="inline-wrap">参数的设置值是否允许担保失败；</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次<span class="jill"></span>Minor GC，尽管这次<span class="jill"></span>Minor GC<span class="jill"></span>是有风险的；</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果小于，或者</span><span class="inline-wrap"><code>-XX:HandlePromotionFailure</code></span><span class="inline-wrap">设置不允许冒险，那这时就要改为进行一次<span class="jill"></span>Full GC。</span></div></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">内存回收策略</span></summary><div class="wolai-block wolai-center"><figure><img src="media/image_2.png" style="width: 760px"/></figure></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">内存回收过程</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">CMS<span class="jill"></span>每个收集周期都要经历：初始标记、并发标记、重新标记、并发清除。</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations/concurrent-mark-and-sweep">Concurrent Mark and Sweep | Plumbr – User Experience &amp; Application Performance Monitoring</a><div class="info-box"><div class="text-pane"><div data-title="Concurrent Mark and Sweep | Plumbr – User Experience &amp; Application Performance Monitoring"></div><div data-desc="The official name for this collection of garbage collectors is “Mostly Concurrent Mark and Sweep Garbage Collector”. It uses the parallel stop-the-world mark-copy algorithm in the Young Generation and"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://plumbr.io/app/themes/plumbr/dist/images/favicon_9b72e733.png&quot;)"></div><div data-hostname="plumbr.io"></div></div></div><div class="preview-pane" style="background-image: url(https://plumbr.io/app/uploads/2015/10/plumbr-980.png)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://docs.oracle.com/javase/9/gctuning/concurrent-mark-sweep-cms-collector.htm#JSGCT-GUID-937A32AD-E2EA-4109-823D-A66D001A1807">Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide</a><div class="info-box"><div class="text-pane"><div data-title="Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide"></div><div data-desc="The Concurrent Mark Sweep (CMS) collector is designed for applications that prefer shorter garbage collection pauses and that can afford to share processor resources with the garbage collector while t"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://docs.oracle.com/favicon.ico&quot;)"></div><div data-hostname="docs.oracle.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-center"><figure><img src="media/image_3.png" style="width: 760px"/></figure></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">初始标记以<span class="jill"></span>STW<span class="jill"></span>的方式标记所有的<span class="jill"></span>GC Root<span class="jill"></span>对象；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">并发标记则标记出根对象的可达路径(这个阶段应用线程是可以运行，无需<span class="jill"></span>STW)；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">重新标记：在进行垃圾回收前，CMS<span class="jill"></span>再以一个<span class="jill"></span>STW<span class="jill"></span>进行</span><span class="inline-wrap">重新标记</span><span class="inline-wrap">，标记那些由<span class="jill"></span>mutator<span class="jill"></span>线程(指引起数据变化的线程，即应用线程)修改而可能错过的可达对象；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">最后得到的不可达对象将在并发清除阶段进行回收。值得注意的是，初始标记和重新标记都已优化为多线程执行；</span></li></ul></details><details class="wolai-block"><summary><div class="marker placeholder"></div><span class="inline-wrap">优点</span></summary></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">缺点</span></summary><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">CMS<span class="jill"></span>收集器对<span class="jill"></span>CPU<span class="jill"></span>资源非常敏感,在并发阶段虽然不会导致用户线程停顿，但是会因为占用了一部分<span class="jill"></span>CPU<span class="jill"></span>资源，如果在<span class="jill"></span>CPU<span class="jill"></span>资源不足的情况下应用会有明显的卡顿。</span></li><li><div class="marker"></div><span class="inline-wrap">无法处理浮动垃圾：在执行‘并发清理’步骤时，用户线程也会同时产生一部分可回收对象，但是这部分可回收对象只能在下次执行清理是才会被回收。如果在此清理过程中预留给用户线程的内存不足就会出现‘Concurrent Mode Failure’,一旦出现此错误时便会切换到<span class="jill"></span>SerialOld<span class="jill"></span>收集方式。</span></li><li><div class="marker"></div><span class="inline-wrap">标记清除算法会产生大量的内存碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS<span class="jill"></span>也提供了参数</span><span class="inline-wrap"><code>-XX:CMSFullGCsBeForeCompaction</code></span><span class="inline-wrap">(默认<span class="jill"></span>0，即每次都进行内存整理)来指定多少次<span class="jill"></span>CMS<span class="jill"></span>收集之后，进行一次压缩的<span class="jill"></span>Full GC。</span></li></ol></details><h3 class="wolai-block"><span class="inline-wrap">G1</span></h3><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">简介</span></summary><aside class="bg-cultured wolai-block"><div data-symbol="❄️" class="icon"></div><span class="inline-wrap">-XX:+UseG1GC</span></aside><div class="wolai-block wolai-text"><div><span class="inline-wrap">之前介绍的几组垃圾收集器组合，都有几个共同点：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">年轻代、老年代是独立且连续的内存块；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">年轻代收集使用单<span class="jill"></span>eden、双<span class="jill"></span>survivor<span class="jill"></span>进行复制算法；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">老年代收集必须扫描整个老年代区域；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">都是以尽可能少而块地执行<span class="jill"></span>GC<span class="jill"></span>为设计原则。</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">内存布局</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">G1<span class="jill"></span>把它所管理的堆平均分成多个堆区域(heap </span><span class="inline-wrap"><i>regions</i></span><span class="inline-wrap">)，默认分为</span><span class="inline-wrap"><code>2048</code></span><span class="inline-wrap">个区域，每个区域的内存大小可以在启动时可以通过参数</span><span class="inline-wrap"><code>-XX:G1HeapRegionSize=n</code></span><span class="inline-wrap">设置(</span><span class="inline-wrap"><code>1MB~32MB，且必须是<span class="jill"></span>2<span class="jill"></span>的幂</code></span><span class="inline-wrap">)。每个区域可单独作为伊甸区、幸存区、老年代。</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/image_4.png" style="width: 580px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">通过这种布局，我们可以每次只选择一部分区域进行垃圾回收，从而缩短<span class="jill"></span>GC<span class="jill"></span>的暂停时间。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">内存分配策略</span></summary><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">大对象直接进入老年代</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">大对象就是指需要大量连续内存空间的<span class="jill"></span>Java<span class="jill"></span>对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">HotSpot<span class="jill"></span>虚拟机提供了</span><span class="inline-wrap"><code>-XX:PretenureSizeThreshold</code></span><span class="inline-wrap">参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在<span class="jill"></span>Eden<span class="jill"></span>区及两个<span class="jill"></span>Survivor<span class="jill"></span>区之间来回复制，产生大量的内存复制操作。</span></div></div><blockquote class="bg-cultured wolai-block"><span class="inline-wrap"><code>-XX:PretenureSizeThreshold</code></span><span class="inline-wrap">参数只对<span class="jill"></span>Serial<span class="jill"></span>和<span class="jill"></span>ParNew<span class="jill"></span>两款新生代收集器有效，HotSpot<span class="jill"></span>的其他新生代收集器，如<span class="jill"></span>ParallelScavenge、G1<span class="jill"></span>并不支持这个参数。如果必须使用此参数进行调优，可考虑<span class="jill"></span>ParNew<span class="jill"></span>加<span class="jill"></span>CMS<span class="jill"></span>的收集器组合。</span></blockquote></details></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">内存回收策略</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">G1<span class="jill"></span>的收集周期可以看做两个阶段：年轻代回收阶段、混合回收阶段。</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/image_5.png" style="width: 555.5px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">老年代的内存占用率达到限制之前，G1<span class="jill"></span>只会对年轻代进行垃圾回收。也就是，把存活对象移动到幸存区和老年代。</span></div></div><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">年轻代垃圾回收日志</span></summary><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="纯文本" class="marker"></div><pre><span class="token comment">// GC暂停 (疏散年轻代) 暂停时间0.0075422秒</span>
<span class="token punctuation">[</span><span class="token constant">GC</span> <span class="token function">pause</span> <span class="token punctuation">(</span><span class="token constant">G1</span> <span class="token maybe-class-name">Evacuation</span> <span class="token maybe-class-name">Pause</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>young<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0075422</span> secs<span class="token punctuation">]</span>
   <span class="token comment">// 耗时4.6毫秒，10条线程并行做了下面的事情(activities)</span>
   <span class="token punctuation">[</span><span class="token maybe-class-name">Parallel</span> <span class="token maybe-class-name">Time</span><span class="token operator">:</span> <span class="token number">4.6</span> ms<span class="token punctuation">,</span> <span class="token constant">GC</span> <span class="token maybe-class-name">Workers</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">]</span>
      <span class="token comment">// 从GC暂停到线程真正开始工作距离多长时间</span>
      <span class="token punctuation">[</span><span class="token constant">GC</span> <span class="token maybe-class-name">Worker</span> <span class="token function"><span class="token maybe-class-name">Start</span></span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">1119.1</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">1119.2</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">1119.3</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0.3</span><span class="token punctuation">]</span>
      <span class="token comment">// 扫描非堆GC Root的耗时(such as classloaders, JNI references, JVM system roots, etc.)</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Ext</span> <span class="token maybe-class-name">Root</span> <span class="token function"><span class="token maybe-class-name">Scanning</span></span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">0.6</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">2.8</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">2.6</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">6.4</span><span class="token punctuation">]</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Update</span> <span class="token constant">RS</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">]</span>
         <span class="token punctuation">[</span><span class="token maybe-class-name">Processed</span> <span class="token maybe-class-name">Buffers</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">]</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Scan</span> <span class="token constant">RS</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">0.1</span><span class="token punctuation">]</span>
      <span class="token comment">// How long it took to scan the roots that came from the actual code: local vars, etc.      </span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Code</span> <span class="token maybe-class-name">Root</span> <span class="token function"><span class="token maybe-class-name">Scanning</span></span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">1.3</span><span class="token punctuation">]</span>
      <span class="token comment">// How long it took to copy the live objects away from the collected regions.      </span>
      <span class="token punctuation">[</span><span class="token known-class-name class-name">Object</span> <span class="token function"><span class="token maybe-class-name">Copy</span></span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">1.4</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">3.3</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">3.7</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">2.3</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">33.3</span><span class="token punctuation">]</span>
      <span class="token comment">// How long it took for the worker threads to ensure that they can safely stop and that there’s no more work to be done, and then actually terminate</span>
      <span class="token punctuation">[</span><span class="token function"><span class="token maybe-class-name">Termination</span></span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">1.9</span><span class="token punctuation">]</span>
         <span class="token comment">// How many attempts worker threads took to try and terminate.      </span>
         <span class="token punctuation">[</span><span class="token maybe-class-name">Termination</span> <span class="token maybe-class-name">Attempts</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">2.9</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">29</span><span class="token punctuation">]</span>               
      <span class="token comment">// Other miscellaneous small activities that do not deserve a separate section in the logs.         </span>
      <span class="token punctuation">[</span><span class="token constant">GC</span> <span class="token maybe-class-name">Worker</span> <span class="token function"><span class="token maybe-class-name">Other</span></span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">0.3</span><span class="token punctuation">]</span>
      <span class="token comment">// How long the worker threads have worked for in total</span>
      <span class="token punctuation">[</span><span class="token constant">GC</span> <span class="token maybe-class-name">Worker</span> <span class="token function"><span class="token maybe-class-name">Total</span></span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">4.2</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">4.3</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">4.5</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0.3</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">43.2</span><span class="token punctuation">]</span>
      <span class="token comment">// The timestamp at which the workers have finished their jobs. </span>
      <span class="token punctuation">[</span><span class="token constant">GC</span> <span class="token maybe-class-name">Worker</span> <span class="token function"><span class="token maybe-class-name">End</span></span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">1123.4</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">1123.5</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">1123.6</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0.1</span><span class="token punctuation">]</span>
   <span class="token comment">// 释放用于管理上面事情(activities)的数据结构</span>
   <span class="token punctuation">[</span><span class="token maybe-class-name">Code</span> <span class="token maybe-class-name">Root</span> <span class="token maybe-class-name">Fixup</span><span class="token operator">:</span> <span class="token number">0.0</span> ms<span class="token punctuation">]</span>
   <span class="token comment">// 清理更多数据结构</span>
   <span class="token punctuation">[</span><span class="token maybe-class-name">Code</span> <span class="token maybe-class-name">Root</span> <span class="token maybe-class-name">Purge</span><span class="token operator">:</span> <span class="token number">0.0</span> ms<span class="token punctuation">]</span>
   <span class="token punctuation">[</span><span class="token maybe-class-name">Clear</span> <span class="token constant">CT</span><span class="token operator">:</span> <span class="token number">0.2</span> ms<span class="token punctuation">]</span>
   <span class="token comment">// 耗时2,6毫秒，处理其它事情</span>
   <span class="token punctuation">[</span><span class="token maybe-class-name">Other</span><span class="token operator">:</span> <span class="token number">2.6</span> ms<span class="token punctuation">]</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Choose</span> <span class="token maybe-class-name">CSet</span><span class="token operator">:</span> <span class="token number">0.0</span> ms<span class="token punctuation">]</span>
      <span class="token comment">// 处理非强引用</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Ref</span> <span class="token maybe-class-name">Proc</span><span class="token operator">:</span> <span class="token number">2.0</span> ms<span class="token punctuation">]</span>
      <span class="token comment">// 把剩余的非强引用放入相应的引用队列(ReferenceQueue)</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Ref</span> <span class="token maybe-class-name">Enq</span><span class="token operator">:</span> <span class="token number">0.1</span> ms<span class="token punctuation">]</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Redirty</span> <span class="token maybe-class-name">Cards</span><span class="token operator">:</span> <span class="token number">0.2</span> ms<span class="token punctuation">]</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Humongous</span> <span class="token maybe-class-name">Register</span><span class="token operator">:</span> <span class="token number">0.1</span> ms<span class="token punctuation">]</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Humongous</span> <span class="token maybe-class-name">Reclaim</span><span class="token operator">:</span> <span class="token number">0.0</span> ms<span class="token punctuation">]</span>
      <span class="token comment">// The time it takes to return the freed regions in the collection set so that they are available for new allocations.</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Free</span> <span class="token maybe-class-name">CSet</span><span class="token operator">:</span> <span class="token number">0.1</span> ms<span class="token punctuation">]</span>
   <span class="token comment">// GC前后伊甸区、幸存区、整个堆的内存状况</span>
   <span class="token punctuation">[</span><span class="token maybe-class-name">Eden</span><span class="token operator">:</span> <span class="token number">25600.0</span><span class="token function"><span class="token maybe-class-name">K</span></span><span class="token punctuation">(</span><span class="token number">25600.0</span>K<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">0.0</span><span class="token function"><span class="token maybe-class-name">B</span></span><span class="token punctuation">(</span><span class="token number">33792.0</span>K<span class="token punctuation">)</span> <span class="token maybe-class-name">Survivors</span><span class="token operator">:</span> <span class="token number">0.0</span>B<span class="token operator">-</span><span class="token operator">></span><span class="token number">4096.0</span>K <span class="token maybe-class-name">Heap</span><span class="token operator">:</span> <span class="token number">25600.0</span><span class="token function"><span class="token maybe-class-name">K</span></span><span class="token punctuation">(</span><span class="token number">512.0</span>M<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3624.5</span><span class="token function"><span class="token maybe-class-name">K</span></span><span class="token punctuation">(</span><span class="token number">512.0</span>M<span class="token punctuation">)</span><span class="token punctuation">]</span>
 <span class="token comment">// 这个GC活动，CPU时间分配，user:GC线程 sys:系统调用/等待系统事件 real:应用暂停时间</span>
 <span class="token punctuation">[</span><span class="token maybe-class-name">Times</span><span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.02</span> sys<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span> real<span class="token operator">=</span><span class="token number">0.01</span> secs<span class="token punctuation">]</span> </pre></div></code-block></details><div class="wolai-block wolai-text"><div><span class="inline-wrap">当老年代的内存占用率超过限制， G1<span class="jill"></span>开始从年轻代回收阶段到混合回收阶段的转移。</span></div></div><blockquote class="wolai-block"><span class="inline-wrap">限制可以通过</span><span class="inline-wrap"><code>-XX:InitiatingHeapOccupancyPercent=n</code></span><span class="inline-wrap">进行设置。默认<span class="jill"></span>45。</span></blockquote><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">初始标记(</span><span class="inline-wrap"><code>STW</code></span><span class="inline-wrap">)：标记从<span class="jill"></span>GC Root<span class="jill"></span>开始直接可达的对象，并把它们的字段在压入扫描栈中等到后续扫描。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">根区域扫描：从<span class="jill"></span>Survior<span class="jill"></span>区的对象出发，标记被引用到老年代中的对象，并把它们的字段在压入扫描栈中等到后续扫描。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">并发标记：不断从扫描栈取出引用递归扫描整个堆里的对象。每扫描到一个对象就会对其标记，并将其字段压入扫描栈。重复扫描过程直到扫描栈清空。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">最终标记(</span><span class="inline-wrap"><code>STW</code></span><span class="inline-wrap">)：标记那些在并发标记阶段发生变化的对象，将被回收。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">清除垃圾：清理垃圾(</span><span class="inline-wrap">并把没有存活对象的区域，加入到<span class="jill"></span>free list</span><span class="inline-wrap">)。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-bookmark wolai-block"><a href="https://zhuanlan.zhihu.com/p/52841787">G1 收集器原理理解与分析</a><div class="info-box"><div class="text-pane"><div data-title="G1 收集器原理理解与分析"></div><div data-desc="前面几篇分别介绍了几种GC算法： 林林：GC算法之一 标记-清除算法林林：GC算法之二 复制-清除算法林林：GC算法之三 标记-压缩算法 现在我们就深入了解一下当前Java GC收集器中的最新流行的代表作：G1收集器( Garba…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.a53ae37b.png&quot;)"></div><div data-hostname="zhuanlan.zhihu.com"></div></div></div><div class="preview-pane" style="background-image: url(https://pic2.zhimg.com/v2-6c59cb6763702708e777cb83efc84069_720w.jpg?source=172ae18b)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://cloud.tencent.com/developer/article/1459638">详解 JVM Garbage First(G1) 垃圾收集器 - 云+社区 - 腾讯云</a><div class="info-box"><div class="text-pane"><div data-title="详解 JVM Garbage First(G1) 垃圾收集器 - 云+社区 - 腾讯云"></div><div data-desc="Garbage First(G1)是垃圾收集领域的最新成果，同时也是HotSpot在JVM上力推的垃圾收集器，并赋予取代CMS的使命。如果使用Java 8/9，..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cloud.tencent.com/favicon.ico&quot;)"></div><div data-hostname="cloud.tencent.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#g1">GC Algorithms: Implementations | Plumbr – User Experience &amp; Application Performance Monitoring</a><div class="info-box"><div class="text-pane"><div data-title="GC Algorithms: Implementations | Plumbr – User Experience &amp; Application Performance Monitoring"></div><div data-desc="Now that we have reviewed the core concepts behind GC algorithms, let us move to the specific implementations one can find inside the JVM. An important aspect to recognize first is the fact that…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://plumbr.io/app/themes/plumbr/dist/images/favicon_9b72e733.png&quot;)"></div><div data-hostname="plumbr.io"></div></div></div><div class="preview-pane" style="background-image: url(https://plumbr.io/app/uploads/2015/10/plumbr-980.png)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector.htm#JSGCT-GUID-1CDEB6B6-9463-4998-815D-05E095BFBD0F">Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide</a><div class="info-box"><div class="text-pane"><div data-title="Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://docs.oracle.com/favicon.ico&quot;)"></div><div data-hostname="docs.oracle.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.6386&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.6386&amp;rep=rep1&amp;type=pdf</a><div class="info-box"><div class="text-pane"><div data-title="citeseerx.ist.psu.edu"></div><div class="icon-host"><div data-hostname="citeseerx.ist.psu.edu"></div></div></div><div class="preview-pane"></div></div></div></details><h3 class="wolai-block"><span class="inline-wrap">ZGC</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.3.8<span class="jill"></span>垃圾收集器参数总结</span></h4><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token comment"># JDK8</span>
-XX:+PrintGC           <span class="token comment"># 打印GC信息 </span>
-XX:+PrintGCDetails    <span class="token comment"># 打印GC详情信息</span>
-XX:+PrintGCDateStamps <span class="token comment"># 打印GC触发时间</span>
-XX:+PrintGCTimeStamps <span class="token comment"># 打印GC触发时间距离应用启动的时间间隔</span>
-Xloggc:<span class="token operator">&lt;</span>file-path<span class="token operator">></span>    <span class="token comment"># 输出GC日志到指定文件</span>
<span class="token comment"># 推荐</span>
-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -Xloggc:<span class="token operator">&lt;</span>file-path<span class="token operator">></span>

<span class="token comment">#更多参数</span>
https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">并行收集器的常用参数</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>-XX:ParallelGCThreads=&lt;N&gt;</code></span><span class="inline-wrap"> 执行垃圾回收的线程数为<span class="jill"></span>N</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>-XX:MaxGCPauseMillis=&lt;N&gt;</code></span><span class="inline-wrap"> 通过牺牲吞吐量和降低新生代空间来控制最大垃圾收集停顿时间</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>-XX:GCTimeRatio=&lt;N&gt;</code></span><span class="inline-wrap"> 设置吞吐量大小，参数值应该是一个<span class="jill"></span>0<span class="jill"></span>到<span class="jill"></span>100<span class="jill"></span>的整数，代表垃圾回收时间占总时间的百分比</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>-Xmx&lt;N&gt;</code></span><span class="inline-wrap"> 最大堆内存为<span class="jill"></span>N</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>-Xms&lt;N&gt;</code></span><span class="inline-wrap"> 初始堆内存为<span class="jill"></span>N</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>-XX:+UseAdaptiveSizePolicy=</code></span><span class="inline-wrap"> 一个开关参数，当这个参数打开后，就不需要手工指定新生代的大小（</span><span class="inline-wrap"><code>-Xmn</code></span><span class="inline-wrap">）、Eden<span class="jill"></span>与<span class="jill"></span>Survivor<span class="jill"></span>区的比例（</span><span class="inline-wrap"><code>-XX:SurvivorRatio</code></span><span class="inline-wrap">）、晋升老年代对象年龄（</span><span class="inline-wrap"><code>-XX:PretenureSizeThreshold</code></span><span class="inline-wrap">）等细节参数，只需要把基本的内存数据设置好（如</span><span class="inline-wrap"><code>-Xmx</code></span><span class="inline-wrap">设置最大堆），然后使用</span><span class="inline-wrap"><code>MaxGVPauseMillis</code></span><span class="inline-wrap">参数或</span><span class="inline-wrap"><code>GCTimeRation</code></span><span class="inline-wrap">参数给虚拟机设立一个优化目标。</span></li></ul><blockquote class="wolai-block"><span class="inline-wrap">If more than 98% of the total time is spent in garbage collection and less than 2% of the heap is recovered, then an </span><span class="inline-wrap"><code>OutOfMemoryError</code></span><span class="inline-wrap">, is thrown. This feature is designed to prevent applications from running for an extended period of time while making little or no progress because the heap is too small. If necessary, this feature can be disabled by adding the option </span><span class="inline-wrap"><code>-XX:-UseGCOverheadLimit</code></span><span class="inline-wrap"> to the command line.</span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">常见<span class="jill"></span>GC<span class="jill"></span>日志分析工具：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagcaL</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://blog.csdn.net/luxiangxing/article/details/84884721">JVM 常见调优参数_xiangxingchina-CSDN博客</a><div class="info-box"><div class="text-pane"><div data-title="JVM 常见调优参数_xiangxingchina-CSDN博客"></div><div data-desc="@@内存调优@@#初始堆大小   最大堆大小-Xms(-XX:InitialHeapSize) #最大堆大小-Xmx (-XX:MaxHeapSize) #让JVM在发生内存溢出时自动的生成堆内存快照-XX:+HeapDumpOnOutOfMemoryError #内存溢出时 存放路径#默认情况下，保存在JVM的启动目录下名为java_pid&amp;amp;lt;pid..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://g.csdnimg.cn/static/logo/favicon32.ico&quot;)"></div><div data-hostname="blog.csdn.net"></div></div></div><div class="preview-pane"></div></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">初始标记（initial mark，STW）。它标记了从<span class="jill"></span>GC Root<span class="jill"></span>开始直接可达的对象。 * 并发标记（Concurrent Marking）。这个阶段从<span class="jill"></span>GC Root<span class="jill"></span>开始对<span class="jill"></span>heap<span class="jill"></span>中的对象标记，标记线程与应用程序线程并行执行，并且收集各个<span class="jill"></span>Region<span class="jill"></span>的存活对象信息。 * 最终标记（Remark，STW）。标记那些在并发标记阶段发生变化的对象，将被回收。 * 清除垃圾（Cleanup）。清除空<span class="jill"></span>Region（没有存活对象的），加入到<span class="jill"></span>free list。</span></li></ul></article><footer></footer></body></html>
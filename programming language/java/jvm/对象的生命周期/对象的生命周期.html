<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>对象的生命周期 - wolai 笔记</title><link rel="shortcut icon"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="对象的生命周期" class="main-title"></div></div></header><article><div class="wolai-block wolai-text"><div><span class="inline-wrap">对象的生命周期指的是对象从创建到销毁这一过程。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">对象的创建</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>有<span class="jill"></span>4<span class="jill"></span>种显式地创建对象的方式：</b></span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">new</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">反射</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对象的<span class="jill"></span>clone<span class="jill"></span>方法</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">反序列化</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>对象的创建过程</b></span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">给对象分配内存</span></li><li><div class="marker"></div><span class="inline-wrap">为对象的实例变量设置默认值</span></li><li><div class="marker"></div><span class="inline-wrap">初始化对象，实例变量赋予正确的初始值，执行构造函数</span></li></ol><div class="wolai-bookmark wolai-block"><a href="https://juejin.cn/post/6991736505077071879">Java 对象创建过程 - 掘金</a><div class="info-box"><div class="text-pane"><div data-title="Java 对象创建过程 - 掘金"></div><div data-desc="字节码分析创建过程 简单实现一个创建对象的代码 从字节码分析对象创建的过程 new new指令相当于去对应的内存空间申请一块内存大小 用于存放对象数据 对象的大小是可以确定的 比如int占用4个字节"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/apple-touch-icon.png&quot;)"></div><div data-hostname="juejin.cn"></div></div></div><div class="preview-pane"></div></div></div><h2 class="wolai-block"><span class="inline-wrap">垃圾回收</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">当对象被创建后，就会在<span class="jill"></span>Java<span class="jill"></span>虚拟机的堆区中拥有一块内存，如果对象没用了，那么就<span class="jill"></span>Java<span class="jill"></span>虚拟机的垃圾回收器就会回收对象。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">无用对象的判定</span></h3><h4 class="wolai-block"><span class="inline-wrap">引用计数算法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">给对象添加一个引用计数器，每当有一个地方引用它，引用次数加<span class="jill"></span>1。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">缺点：难以解决循环引用问题。</span></div></div><h4 class="wolai-block"><span class="inline-wrap">可达性分析算法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">可达性分析算法通过一系列称为</span><span class="inline-wrap"><code>GC Roots</code></span><span class="inline-wrap">的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到</span><span class="inline-wrap"><code>GC Roots</code></span><span class="inline-wrap">之间没有那么的引用链，则说明该对象不可用。</span></div></div><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">在 Hotspot 中，</span><span class="inline-wrap"><code>GC Roots</code></span><span class="pink inline-wrap">集合中包含了 5 个元素:</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">虚拟机栈内的对象引用</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">本地方法栈内的对象引用</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">运行时常量池中的对象引用</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方法区中类静态属性的对象引用</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">一个类对应的唯一数据类型的 Class 对象</span></li></ul><div class="wolai-bookmark wolai-block"><a href="https://medium.com/swlh/https-medium-com-dredwardhyde-how-does-hotspot-jvm-scan-the-root-set-31c0bdbf3271">https://medium.com/swlh/https-medium-com-dredwardhyde-how-does-hotspot-jvm-scan-the-root-set-31c0bdbf3271</a><div class="info-box"><div class="text-pane"><div data-title="medium.com"></div><div class="icon-host"><div data-hostname="medium.com"></div></div></div><div class="preview-pane"></div></div></div><h4 class="wolai-block"><span class="inline-wrap">对象的触及状态</span></h4><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">可触及状态：对象被创建后，有引用变量引用它。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">可复活状态：对象没有被任何引用变量引用。如果该对象重写了</span><span class="inline-wrap"><code>finalize()</code></span><span class="inline-wrap">方法，并且这时候它的</span><span class="inline-wrap"><code>finalize()</code></span><span class="inline-wrap">还没被虚拟机调用过，那么这个对象将会被放置在一个名为 F-Queue 的队列之中,并在稍后由一条由虚拟机自动建立的、低优先级的</span><span class="inline-wrap"><code>Finalizer</code></span><span class="inline-wrap">线程去执行。对象可以在</span><span class="inline-wrap"><code>finalize()</code></span><span class="inline-wrap">方法中通过把自己重新添加到引用链上实现自我拯救（例如把自己</span><span class="inline-wrap"><code>this</code></span><span class="inline-wrap">赋值给某个类变量或对象的成员变量），稍后<span class="jill"></span>GC<span class="jill"></span>将对<span class="jill"></span>F-Queue<span class="jill"></span>中的对象进行第二次小规模的标记，如果对象这时候还是不在引用链上，那它就真的要被回收了</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">不可触及状态：对象执行了</span><span class="inline-wrap"><code>finalize</code></span><span class="inline-wrap">方法后没有恢复成可触及状态，就会变成不可触及状态，这时候垃圾回收器才会真正的收回它占用的内存。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">注意：虚拟机会执行</span><span class="inline-wrap"><code>finalize()</code></span><span class="inline-wrap">方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在</span><span class="inline-wrap"><code>finalize()</code></span><span class="inline-wrap">方法中执行缓慢，或者发生了死循环(更极端的情况)，很可能会导致 F-Queue 队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。</span></div></div><h4 class="wolai-block"><span class="inline-wrap">finalize<span class="jill"></span>方法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>finalize</code></span><span class="inline-wrap">方法定义在<span class="jill"></span>Object<span class="jill"></span>类</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></pre></div></code-block><h3 class="wolai-block"><span class="inline-wrap">垃圾收集算法</span></h3><h4 class="wolai-block"><span class="inline-wrap">标记-清除算法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Mark and Sweep</b></span><span class="inline-wrap"> ：标记出需要回收的对象，然后统一回收所有被标记的对象。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/gc-mark-sweep.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">缺点：对象清除后产生大量不连续的内存碎片，还需要额外记录空闲内存的位置和大小。</span></div></div><h4 class="wolai-block"><span class="inline-wrap">标记-清除-整理算法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Mark-Sweep-Compact</b></span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/gc-mark-sweep-compact.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">添加了一个压缩操作，把存活对象往一边移动，解决内存碎片问题。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">缺点：需要移动对象，并更新对这些对象的引用</span></div></div><h4 class="wolai-block"><span class="inline-wrap">标记-复制算法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Mark and Copy</b></span><span class="inline-wrap"> ：把内存分为两部分，当其中一块内存用完，就把该内存中存活的对象复制到另一块内存中。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/gc-mark-and-copy-in-java.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">优点：移动和标记可以同时进行，同时还避免内存碎片问题</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">缺点： 每次只能使用一半的内存</span></div></div><h4 class="wolai-block"><span class="inline-wrap">分代收集算法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">根据对象存活周期的不同将内存划分为几块。一般分为新生代和老年代，然后根据各个年代的特点采用合适的收集算法。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">新生代朝生夕死，所以采用复制算法，老年代通常采用标记-清除-整理算法。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">关于新生代、老年代请看</span><span class="inline-wrap"><a href="https://www.cnblogs.com/snowwhite/p/9532311.html"><span>新生代、老年代</span></a></span><span class="inline-wrap">。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">垃圾收集器</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">垃圾收集器有很多种，有的作用于新生代，有的作用于老年代，有的老少通吃。</span></div></div><div class="wolai-block wolai-text"><div><span class="pink inline-wrap"><b>S</b></span><span class="pink inline-wrap">TW、</span><span class="pink inline-wrap"><b>并发</b></span><span class="pink inline-wrap">、</span><span class="pink inline-wrap"><b>并行</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在讲垃圾收集器之前，需要先了解三个术语，分别是</span><span class="inline-wrap"><b>stop the world</b></span><span class="inline-wrap">、</span><span class="inline-wrap"><b>并发</b></span><span class="inline-wrap">、</span><span class="inline-wrap"><b>并行</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>stop the world</b></span><span class="inline-wrap"> 指的就是垃圾回收时，应用线程会被暂停</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在垃圾收集器中，并发和并行的意思跟我们平时了解的有点不一样，在垃圾收集器中，</span><span class="inline-wrap"><b>并行</b></span><span class="inline-wrap">指的是，垃圾回收是通过多个线程来完成的，</span><span class="inline-wrap"><b>并发</b></span><span class="inline-wrap">指的是，垃圾回收线程与应用线程同时运行。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">一个垃圾收集器可以用以上<span class="jill"></span>3<span class="jill"></span>个术语进行组合描述，例如一个并行并发收集器，讲的就是一个收集器，利用多线程进行垃圾回收，在回收时不需要暂停应用线程。</span></div></div><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">Hotspot<span class="jill"></span>提供的垃圾收集器：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">不进行垃圾收集：</span><span class="inline-wrap">Incremental</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">作用于新生代垃圾收集器：Serial、Parallel Scavenge</span><span class="inline-wrap"><b>、</b></span><span class="inline-wrap">Parallel New</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">作用于老年代的垃圾收集器：Serial</span><span class="inline-wrap"><b> </b></span><span class="inline-wrap">Old</span><span class="inline-wrap"><b>、</b></span><span class="inline-wrap">Parallel Old、CMS</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">作用于新生代和老年代的垃圾收集器：G1</span></div></div><div class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 246.66666666666666px"><span class="inline-wrap">新生代</span></th><th style="width: 246.66666666666666px"><span class="inline-wrap">老年代</span></th><th style="width: 246.66666666666666px"><span class="inline-wrap"><b></b></span><span class="inline-wrap"><b>JVM options</b></span></th></tr></thead><tbody><tr><td><span class="inline-wrap">Incremental</span></td><td><span class="inline-wrap">Incremental</span></td><td><span class="inline-wrap">-Xincgc</span></td></tr><tr><td><span class="inline-wrap">Serial</span></td><td><span class="inline-wrap">Serial Old</span></td><td><span class="inline-wrap">-XX:+UseSerialGC</span></td></tr><tr><td><span class="inline-wrap">Parallel Scavenge</span></td><td><span class="inline-wrap">Serial Old</span></td><td><span class="inline-wrap">-XX:+UseParallelOldGC</span></td></tr><tr><td><span class="inline-wrap">Parallel New</span></td><td><span class="inline-wrap">Serial Old</span></td><td><span class="inline-wrap">-XX:+UseParNewGC</span></td></tr><tr><td><span class="inline-wrap">Serial</span></td><td><span class="inline-wrap">Parallel Old</span></td><td><span class="inline-wrap">N/A</span></td></tr><tr><td><span class="inline-wrap">Parallel Scavenge</span></td><td><span class="inline-wrap">Parallel Old</span></td><td><span class="inline-wrap">-XX:+UseParallelGC</span></td></tr><tr><td><span class="inline-wrap">Parallel New</span></td><td><span class="inline-wrap">Parallel Old</span></td><td><span class="inline-wrap">N/A</span></td></tr><tr><td><span class="inline-wrap">Serial</span></td><td><span class="inline-wrap">CMS</span></td><td><br/></td></tr><tr><td><span class="inline-wrap">Parallel Scavenge</span></td><td><span class="inline-wrap">CMS</span></td><td><span class="inline-wrap">N/A</span></td></tr><tr><td><span class="inline-wrap">Parallel New</span></td><td><span class="inline-wrap">CMS</span></td><td><span class="inline-wrap">-XX:+UseParNewGC 
-XX:+UseConcMarkSweepGC</span></td></tr><tr><td><span class="inline-wrap">G1</span></td><td><span class="inline-wrap">G1</span></td><td><span class="inline-wrap">-XX:+UseG1GC</span></td></tr></tbody></table></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生代和老年代都是串行回收（GC<span class="jill"></span>时需要停止应用线程）</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生代和老年代都是并行回收</span><span class="inline-wrap">（GC<span class="jill"></span>时需要停止应用线程）</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生代并行回收，老年代使用<span class="jill"></span>CMS<span class="jill"></span>并发回收（新生代<span class="jill"></span>GC<span class="jill"></span>时需要停止应用线程，老年代<span class="jill"></span>GC<span class="jill"></span>时部分阶段需要停止应用线程）</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生代和老年代使用<span class="jill"></span>G1<span class="jill"></span>并发回收（GC<span class="jill"></span>时部分阶段需要停止应用线程）</span></li></ul><h4 class="wolai-block"><span class="inline-wrap">Minor GC、Major GC、Full GC</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">Minor GC：清理年轻代</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Major GC：清理老年代</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Full GC：清理年轻代和老年代</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">针对<span class="jill"></span>HotSpot VM<span class="jill"></span>的实现，它里面的<span class="jill"></span>GC<span class="jill"></span>其实准确分类只有两大种：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Partial GC(局部<span class="jill"></span>GC)：并不收集整个<span class="jill"></span>GC<span class="jill"></span>堆的模式</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Young GC：只收集<span class="jill"></span>young gen<span class="jill"></span>的<span class="jill"></span>GC</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Old GC：只收集<span class="jill"></span>old gen<span class="jill"></span>的<span class="jill"></span>GC</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Mixed GC：收集整个<span class="jill"></span>young gen<span class="jill"></span>以及部分<span class="jill"></span>old gen<span class="jill"></span>的<span class="jill"></span>GC</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Full GC(全局<span class="jill"></span>GC)：收集整个堆</span></li></ul><h4 class="wolai-block"><span class="inline-wrap">Serial GC</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">分代的单线程收集器，新生代使用</span><span class="inline-wrap"><b>标记－复制</b></span><span class="inline-wrap">，老年代使用</span><span class="inline-wrap"><b>标记－清除－整理</b></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集完成。</span></div></div><h4 class="wolai-block"><span class="inline-wrap">Parallel GC</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">分代的多线程的垃圾收集器，新生代使用</span><span class="inline-wrap"><b>标记－复制</b></span><span class="inline-wrap">，老年代使用</span><span class="inline-wrap"><b>标记－清除－整理</b></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集完成。</span></div></div><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">对于新生代，Hotspot<span class="jill"></span>提供两种并行垃圾收集器，分别是<span class="jill"></span>Parallel New 和 Parallel Scavenge</span></div></div><blockquote class="wolai-block"><span class="inline-wrap">并行收集器有时候也被称为吞吐量收集器，所谓吞吐量就是<span class="jill"></span>CPU<span class="jill"></span>用于运行用户代码的时间与<span class="jill"></span>CPU<span class="jill"></span>总消耗时间的比值，即 吞吐量=运行用户代码时间/（运行用户代码时间<span class="jill"></span>+<span class="jill"></span>垃圾收集时间）。</span></blockquote><div class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 246.66666666666666px"><span class="inline-wrap">新生代</span></th><th style="width: 246.66666666666666px"><span class="inline-wrap">老年代</span></th><th style="width: 246.6640625px"><span class="inline-wrap"><b></b></span><span class="inline-wrap"><b>JVM options</b></span></th></tr></thead><tbody><tr><td><span class="inline-wrap">Parallel Scavenge</span></td><td><span class="inline-wrap">Serial Old</span></td><td><span class="inline-wrap">-XX:+UseParallelOldGC</span></td></tr><tr><td><span class="inline-wrap"><a href="https://www.cnblogs.com/codehaogg/p/13365572.html"><span>Parallel New</span></a></span></td><td><span class="inline-wrap">Serial Old</span></td><td><span class="inline-wrap">-XX:+UseParNewGC</span></td></tr><tr><td><span class="inline-wrap"><a href="https://blog.csdn.net/luzhensmart/article/details/87902385"><span>Parallel Scavenge</span></a></span></td><td><span class="inline-wrap">Parallel Old</span></td><td><span class="inline-wrap">-XX:+UseParallelGC</span></td></tr><tr><td><span class="inline-wrap">Parallel New</span></td><td><span class="inline-wrap">CMS</span></td><td><span class="inline-wrap">-XX:+UseParNewGC 
-XX:+UseConcMarkSweepGC</span></td></tr></tbody></table></div><h4 class="wolai-block"><span class="inline-wrap">CMS</span></h4><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">简介</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">CMS (Concurrent Mark Sweep)是一款作用于老年代的使用</span><span class="pink inline-wrap">标记清除算法</span><span class="inline-wrap">的垃圾收集器。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">CMS<span class="jill"></span>只能搭配新生代</span><span class="inline-wrap"><b>Parallel New</b></span><span class="inline-wrap">垃圾回收器一起使用。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">CMS<span class="jill"></span>适合堆内存大、CPU<span class="jill"></span>核数多的服务器端应用，也是<span class="jill"></span>G1<span class="jill"></span>出现之前大型应用的首选收集器。CMS<span class="jill"></span>在<span class="jill"></span>JDK9<span class="jill"></span>以后被废弃了，JDK9<span class="jill"></span>默认使用<span class="jill"></span>G1<span class="jill"></span>收集器。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">内存分配策略</span></summary><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">对象优先分配在伊甸区</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">大多数情况下，对象在新生代<span class="jill"></span>Eden<span class="jill"></span>区中分配。当<span class="jill"></span>Eden<span class="jill"></span>区没有足够空间进行分配时，虚拟机将发起一次<span class="jill"></span>Minor GC。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">大对象直接进入老年代</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">大对象就是指需要大量连续内存空间的<span class="jill"></span>Java<span class="jill"></span>对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">HotSpot<span class="jill"></span>虚拟机提供了</span><span class="inline-wrap"><code>-XX:PretenureSizeThreshold</code></span><span class="inline-wrap">参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在</span><span class="inline-wrap"><code>Eden</code></span><span class="inline-wrap">区及两个</span><span class="inline-wrap"><code>Survivor</code></span><span class="inline-wrap">区之间来回复制，产生大量的内存复制操作。</span></div></div><blockquote class="bg-cultured wolai-block"><span class="inline-wrap"><code>-XX:PretenureSizeThreshold</code></span><span class="inline-wrap">参数只对<span class="jill"></span>Serial<span class="jill"></span>和<span class="jill"></span>ParNew<span class="jill"></span>两款新生代收集器有效，HotSpot<span class="jill"></span>的其他新生代收集器，如<span class="jill"></span>ParallelScavenge、G1<span class="jill"></span>并不支持这个参数。如果必须使用此参数进行调优，可考虑<span class="jill"></span>ParNew<span class="jill"></span>加<span class="jill"></span>CMS<span class="jill"></span>的收集器组合。</span></blockquote></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">长期存活的对象将进入老年代</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">HotSpot<span class="jill"></span>虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中。对象通常在<span class="jill"></span>Eden<span class="jill"></span>区里诞生，如果经过第一次<span class="jill"></span>Minor GC<span class="jill"></span>后仍然存活，并且能被<span class="jill"></span>Survivor<span class="jill"></span>容纳的话，该对象会被移动到<span class="jill"></span>Survivor<span class="jill"></span>空间中，并且将其对象年龄设为<span class="jill"></span>1<span class="jill"></span>岁。对象在<span class="jill"></span>Survivor<span class="jill"></span>区中每熬过一次<span class="jill"></span>Minor GC，年龄就增加<span class="jill"></span>1<span class="jill"></span>岁，当它的年龄增加到一定程度（默认为<span class="jill"></span>15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数</span><span class="inline-wrap"><code>-XX:MaxTenuringThreshold</code></span><span class="inline-wrap">设置。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">动态对象年龄判定</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">HotSpot<span class="jill"></span>虚拟机并不是永远要求对象的年龄必须达到</span><span class="inline-wrap"><code>-XX:MaxTenuringThreshold</code></span><span class="inline-wrap">才能晋升老年代，如果在<span class="jill"></span>Survivor<span class="jill"></span>空间中相同年龄所有对象大小的总和大于<span class="jill"></span>Survivor<span class="jill"></span>空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到</span><span class="inline-wrap"><code>-XX:MaxTenuringThreshold</code></span><span class="inline-wrap">中要求的年龄。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">空间分配担保</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">在发生<span class="jill"></span>Minor GC<span class="jill"></span>之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次<span class="jill"></span>Minor GC<span class="jill"></span>可以确保是安全的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果不成立，则虚拟机会先查看</span><span class="inline-wrap"><code>-XX:HandlePromotionFailure</code></span><span class="inline-wrap">参数的设置值是否允许担保失败；</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次<span class="jill"></span>Minor GC，尽管这次<span class="jill"></span>Minor GC<span class="jill"></span>是有风险的；</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果小于，或者</span><span class="inline-wrap"><code>-XX:HandlePromotionFailure</code></span><span class="inline-wrap">设置不允许冒险，那这时就要改为进行一次<span class="jill"></span>Full GC。</span></div></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">内存回收策略</span></summary><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image.png" style="width: 760px"/></figure></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">内存回收过程</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">CMS<span class="jill"></span>每个收集周期都要经历：初始标记、并发标记、重新标记、并发清除。</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations/concurrent-mark-and-sweep">Concurrent Mark and Sweep | Plumbr – User Experience &amp; Application Performance Monitoring</a><div class="info-box"><div class="text-pane"><div data-title="Concurrent Mark and Sweep | Plumbr – User Experience &amp; Application Performance Monitoring"></div><div data-desc="The official name for this collection of garbage collectors is “Mostly Concurrent Mark and Sweep Garbage Collector”. It uses the parallel stop-the-world mark-copy algorithm in the Young Generation and"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://plumbr.io/app/themes/plumbr/dist/images/favicon_9b72e733.png&quot;)"></div><div data-hostname="plumbr.io"></div></div></div><div class="preview-pane" style="background-image: url(https://plumbr.io/app/uploads/2015/10/plumbr-980.png)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://docs.oracle.com/javase/9/gctuning/concurrent-mark-sweep-cms-collector.htm#JSGCT-GUID-937A32AD-E2EA-4109-823D-A66D001A1807">Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide</a><div class="info-box"><div class="text-pane"><div data-title="Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide"></div><div data-desc="The Concurrent Mark Sweep (CMS) collector is designed for applications that prefer shorter garbage collection pauses and that can afford to share processor resources with the garbage collector while t"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://docs.oracle.com/favicon.ico&quot;)"></div><div data-hostname="docs.oracle.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_1.png" style="width: 760px"/></figure></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">初始标记以<span class="jill"></span>STW<span class="jill"></span>的方式标记所有的<span class="jill"></span>GC Root<span class="jill"></span>对象；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">并发标记则标记出根对象的可达路径(这个阶段应用线程是可以运行，无需<span class="jill"></span>STW)；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">重新标记：在进行垃圾回收前，CMS<span class="jill"></span>再以一个<span class="jill"></span>STW<span class="jill"></span>进行</span><span class="inline-wrap">重新标记</span><span class="inline-wrap">，标记那些由<span class="jill"></span>mutator<span class="jill"></span>线程(指引起数据变化的线程，即应用线程)修改而可能错过的可达对象；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">最后得到的不可达对象将在并发清除阶段进行回收。值得注意的是，初始标记和重新标记都已优化为多线程执行；</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">缺点</span></summary><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">CMS<span class="jill"></span>收集器对<span class="jill"></span>CPU<span class="jill"></span>资源非常敏感,在并发阶段虽然不会导致用户线程停顿，但是会因为占用了一部分<span class="jill"></span>CPU<span class="jill"></span>资源，如果在<span class="jill"></span>CPU<span class="jill"></span>资源不足的情况下应用会有明显的卡顿。</span></li><li><div class="marker"></div><span class="inline-wrap">无法处理浮动垃圾：在执行‘并发清理’步骤时，用户线程也会同时产生一部分可回收对象，但是这部分可回收对象只能在下次执行清理是才会被回收。如果在此清理过程中预留给用户线程的内存不足就会出现‘Concurrent Mode Failure’,一旦出现此错误时便会切换到<span class="jill"></span>SerialOld<span class="jill"></span>收集方式。</span></li><li><div class="marker"></div><span class="inline-wrap">标记清除算法会产生大量的内存碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS<span class="jill"></span>也提供了参数</span><span class="inline-wrap"><code>-XX:CMSFullGCsBeForeCompaction</code></span><span class="inline-wrap">(默认<span class="jill"></span>0，即每次都进行内存整理)来指定多少次<span class="jill"></span>CMS<span class="jill"></span>收集之后，进行一次压缩的<span class="jill"></span>Full GC。</span></li></ol></details><div class="wolai-bookmark wolai-block"><a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">Java中9种常见的CMS GC问题分析与解决</a><div class="info-box"><div class="text-pane"><div data-title="Java中9种常见的CMS GC问题分析与解决"></div><div data-desc="目前，互联网上 Java 的 GC 资料要么是主要讲解理论，要么就是针对单一场景的 GC 问题进行了剖析，对整个体系总结的资料少之又少。前车之鉴，后事之师，美团的几位工程师搜集了内部各种 GC 问题的分析文章，并结合个人的理解做了一些总结，希望能起到“抛砖引玉”的作用。"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/android-icon-192x192.png?v=Whistle&amp;t=20181017-1r&quot;)"></div><div data-hostname="tech.meituan.com"></div></div></div><div class="preview-pane"></div></div></div><h4 class="wolai-block"><span class="inline-wrap">G1</span></h4><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">简介</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">跟以往的分代垃圾回收器不一样的是，G1<span class="jill"></span>把它所管理的堆内存划分成多个堆区域(heap </span><span class="inline-wrap"><i>regions</i></span><span class="inline-wrap">)，默认分为</span><span class="inline-wrap"><code>2048</code></span><span class="inline-wrap">个区域，每个区域的内存大小可以在启动时可以通过参数</span><span class="inline-wrap"><code>-XX:G1HeapRegionSize=n</code></span><span class="inline-wrap">设置(</span><span class="inline-wrap"><code>1MB~32MB，且必须是<span class="jill"></span>2<span class="jill"></span>的幂</code></span><span class="inline-wrap">)。每个区域可单独作为伊甸区、幸存区、老年代。通过这种方式，可以每次只选择一部分区域进行垃圾回收，从而实现<span class="jill"></span>GC<span class="jill"></span>暂停时间可控。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_2.png" style="width: 580px"/></figure></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">内存分配策略</span></summary><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">对象优先分配在伊甸区</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">大多数情况下，对象在新生代<span class="jill"></span>Eden<span class="jill"></span>区中分配。当<span class="jill"></span>Eden<span class="jill"></span>区没有足够空间进行分配时，虚拟机将发起一次<span class="jill"></span>Minor GC。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">大对象直接进入老年代</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果一个对象的内存占用超过堆区的一般，那么这个对象就会被判定为大对象(Humongous Object)，会直接分配在老年代。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">长期存活的对象将进入老年代</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">HotSpot<span class="jill"></span>虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中。对象通常在<span class="jill"></span>Eden<span class="jill"></span>区里诞生，如果经过第一次<span class="jill"></span>Minor GC<span class="jill"></span>后仍然存活，并且能被<span class="jill"></span>Survivor<span class="jill"></span>容纳的话，该对象会被移动到<span class="jill"></span>Survivor<span class="jill"></span>空间中，并且将其对象年龄设为<span class="jill"></span>1<span class="jill"></span>岁。对象在<span class="jill"></span>Survivor<span class="jill"></span>区中每熬过一次<span class="jill"></span>Minor GC，年龄就增加<span class="jill"></span>1<span class="jill"></span>岁，当它的年龄增加到一定程度（默认为<span class="jill"></span>15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数</span><span class="inline-wrap"><code>-XX:MaxTenuringThreshold</code></span><span class="inline-wrap">设置。</span></div></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">内存回收过程</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">G1<span class="jill"></span>的垃圾回收可以分成两个阶段：年轻代回收阶段、混合回收阶段。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">开始的时候<span class="jill"></span>G1<span class="jill"></span>只会对年轻代进行垃圾回收，也就是把存活对象移动到幸存区和老年代。然后当老年代的堆内存占用率超过限制， G1<span class="jill"></span>开始从年轻代回收阶段到混合回收阶段的转移。</span></div></div><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">G1<span class="jill"></span>的年轻代回收是并行且<span class="jill"></span>STW<span class="jill"></span>的。</span></div></div><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">在进入混合阶段之前，需要先执行一次标记的操作。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">整个标记操作分成五部分：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">初始标记(STW)：标记出所有<span class="jill"></span>GCRoot<span class="jill"></span>直接可达的老年代对象，虽然该阶段需要<span class="jill"></span>STW，但是它一般会利用年轻代回收时<span class="jill"></span>STW<span class="jill"></span>的时间做这件事，所以它的开销是很小的。</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token comment">// 可以看到在Evacuation Pause后面多了个initial-mark的标记</span>
<span class="token number">1.631</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token class-name">GC</span> pause <span class="token punctuation">(</span>G1 <span class="token class-name">Evacuation</span> <span class="token class-name">Pause</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>young<span class="token punctuation">)</span> <span class="token punctuation">(</span>initial<span class="token operator">-</span>mark<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0062656</span> secs<span class="token punctuation">]</span>
</pre></div></code-block></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">根区扫描：标记出幸存区直接可达的老年代对象。这个阶段跟应用线程是并发的，但是不允许跟年轻代回收并发。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">并发标记：根据上两步找出的可达对象找出整个堆中所有可达的对象。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">重新标记</span><span class="inline-wrap">(STW)</span><span class="inline-wrap">：存活对象的最终定稿，执行引用处理(弱、软、虚、最终引用)，执行类卸载。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">清理</span><span class="inline-wrap">(STW)</span><span class="inline-wrap">：回收没有存活对象的区域，以及决定是否要进入混合回收阶段。</span></li></ul><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">混合回收阶段会对所有年轻代进行回收，以及选取部分老年代进行回收。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">G1<span class="jill"></span>判断回收老年代收益不高时，会退出混合回收阶段，重新进入年轻代回收阶段。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">年轻代回收阶段日志</span></summary><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="纯文本" class="marker"></div><pre><span class="token comment">// GC暂停 (疏散年轻代) 暂停时间0.0075422秒</span>
<span class="token punctuation">[</span><span class="token constant">GC</span> <span class="token function">pause</span> <span class="token punctuation">(</span><span class="token constant">G1</span> <span class="token maybe-class-name">Evacuation</span> <span class="token maybe-class-name">Pause</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>young<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0075422</span> secs<span class="token punctuation">]</span>
   <span class="token comment">// 耗时4.6毫秒，10条线程并行做了下面的事情(activities)</span>
   <span class="token punctuation">[</span><span class="token maybe-class-name">Parallel</span> <span class="token maybe-class-name">Time</span><span class="token operator">:</span> <span class="token number">4.6</span> ms<span class="token punctuation">,</span> <span class="token constant">GC</span> <span class="token maybe-class-name">Workers</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">]</span>
      <span class="token comment">// 从GC暂停到线程真正开始工作距离多长时间</span>
      <span class="token punctuation">[</span><span class="token constant">GC</span> <span class="token maybe-class-name">Worker</span> <span class="token function"><span class="token maybe-class-name">Start</span></span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">1119.1</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">1119.2</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">1119.3</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0.3</span><span class="token punctuation">]</span>
      <span class="token comment">// 扫描非堆GC Root的耗时(such as classloaders, JNI references, JVM system roots, etc.)</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Ext</span> <span class="token maybe-class-name">Root</span> <span class="token function"><span class="token maybe-class-name">Scanning</span></span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">0.6</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">2.8</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">2.6</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">6.4</span><span class="token punctuation">]</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Update</span> <span class="token constant">RS</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">]</span>
         <span class="token punctuation">[</span><span class="token maybe-class-name">Processed</span> <span class="token maybe-class-name">Buffers</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">]</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Scan</span> <span class="token constant">RS</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">0.1</span><span class="token punctuation">]</span>
      <span class="token comment">// How long it took to scan the roots that came from the actual code: local vars, etc.      </span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Code</span> <span class="token maybe-class-name">Root</span> <span class="token function"><span class="token maybe-class-name">Scanning</span></span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">1.3</span><span class="token punctuation">]</span>
      <span class="token comment">// How long it took to copy the live objects away from the collected regions.      </span>
      <span class="token punctuation">[</span><span class="token known-class-name class-name">Object</span> <span class="token function"><span class="token maybe-class-name">Copy</span></span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">1.4</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">3.3</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">3.7</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">2.3</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">33.3</span><span class="token punctuation">]</span>
      <span class="token comment">// How long it took for the worker threads to ensure that they can safely stop and that there’s no more work to be done, and then actually terminate</span>
      <span class="token punctuation">[</span><span class="token function"><span class="token maybe-class-name">Termination</span></span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">1.9</span><span class="token punctuation">]</span>
         <span class="token comment">// How many attempts worker threads took to try and terminate.      </span>
         <span class="token punctuation">[</span><span class="token maybe-class-name">Termination</span> <span class="token maybe-class-name">Attempts</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">2.9</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">29</span><span class="token punctuation">]</span>               
      <span class="token comment">// Other miscellaneous small activities that do not deserve a separate section in the logs.         </span>
      <span class="token punctuation">[</span><span class="token constant">GC</span> <span class="token maybe-class-name">Worker</span> <span class="token function"><span class="token maybe-class-name">Other</span></span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">0.3</span><span class="token punctuation">]</span>
      <span class="token comment">// How long the worker threads have worked for in total</span>
      <span class="token punctuation">[</span><span class="token constant">GC</span> <span class="token maybe-class-name">Worker</span> <span class="token function"><span class="token maybe-class-name">Total</span></span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">4.2</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">4.3</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">4.5</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0.3</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Sum</span><span class="token operator">:</span> <span class="token number">43.2</span><span class="token punctuation">]</span>
      <span class="token comment">// The timestamp at which the workers have finished their jobs. </span>
      <span class="token punctuation">[</span><span class="token constant">GC</span> <span class="token maybe-class-name">Worker</span> <span class="token function"><span class="token maybe-class-name">End</span></span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token maybe-class-name">Min</span><span class="token operator">:</span> <span class="token number">1123.4</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Avg</span><span class="token operator">:</span> <span class="token number">1123.5</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Max</span><span class="token operator">:</span> <span class="token number">1123.6</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Diff</span><span class="token operator">:</span> <span class="token number">0.1</span><span class="token punctuation">]</span>
   <span class="token comment">// 释放用于管理上面事情(activities)的数据结构</span>
   <span class="token punctuation">[</span><span class="token maybe-class-name">Code</span> <span class="token maybe-class-name">Root</span> <span class="token maybe-class-name">Fixup</span><span class="token operator">:</span> <span class="token number">0.0</span> ms<span class="token punctuation">]</span>
   <span class="token comment">// 清理更多数据结构</span>
   <span class="token punctuation">[</span><span class="token maybe-class-name">Code</span> <span class="token maybe-class-name">Root</span> <span class="token maybe-class-name">Purge</span><span class="token operator">:</span> <span class="token number">0.0</span> ms<span class="token punctuation">]</span>
   <span class="token punctuation">[</span><span class="token maybe-class-name">Clear</span> <span class="token constant">CT</span><span class="token operator">:</span> <span class="token number">0.2</span> ms<span class="token punctuation">]</span>
   <span class="token comment">// 耗时2,6毫秒，处理其它事情</span>
   <span class="token punctuation">[</span><span class="token maybe-class-name">Other</span><span class="token operator">:</span> <span class="token number">2.6</span> ms<span class="token punctuation">]</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Choose</span> <span class="token maybe-class-name">CSet</span><span class="token operator">:</span> <span class="token number">0.0</span> ms<span class="token punctuation">]</span>
      <span class="token comment">// 处理非强引用</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Ref</span> <span class="token maybe-class-name">Proc</span><span class="token operator">:</span> <span class="token number">2.0</span> ms<span class="token punctuation">]</span>
      <span class="token comment">// 把剩余的非强引用放入相应的引用队列(ReferenceQueue)</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Ref</span> <span class="token maybe-class-name">Enq</span><span class="token operator">:</span> <span class="token number">0.1</span> ms<span class="token punctuation">]</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Redirty</span> <span class="token maybe-class-name">Cards</span><span class="token operator">:</span> <span class="token number">0.2</span> ms<span class="token punctuation">]</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Humongous</span> <span class="token maybe-class-name">Register</span><span class="token operator">:</span> <span class="token number">0.1</span> ms<span class="token punctuation">]</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Humongous</span> <span class="token maybe-class-name">Reclaim</span><span class="token operator">:</span> <span class="token number">0.0</span> ms<span class="token punctuation">]</span>
      <span class="token comment">// The time it takes to return the freed regions in the collection set so that they are available for new allocations.</span>
      <span class="token punctuation">[</span><span class="token maybe-class-name">Free</span> <span class="token maybe-class-name">CSet</span><span class="token operator">:</span> <span class="token number">0.1</span> ms<span class="token punctuation">]</span>
   <span class="token comment">// GC前后伊甸区、幸存区、整个堆的内存状况</span>
   <span class="token punctuation">[</span><span class="token maybe-class-name">Eden</span><span class="token operator">:</span> <span class="token number">25600.0</span><span class="token function"><span class="token maybe-class-name">K</span></span><span class="token punctuation">(</span><span class="token number">25600.0</span>K<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">0.0</span><span class="token function"><span class="token maybe-class-name">B</span></span><span class="token punctuation">(</span><span class="token number">33792.0</span>K<span class="token punctuation">)</span> <span class="token maybe-class-name">Survivors</span><span class="token operator">:</span> <span class="token number">0.0</span>B<span class="token operator">-</span><span class="token operator">></span><span class="token number">4096.0</span>K <span class="token maybe-class-name">Heap</span><span class="token operator">:</span> <span class="token number">25600.0</span><span class="token function"><span class="token maybe-class-name">K</span></span><span class="token punctuation">(</span><span class="token number">512.0</span>M<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3624.5</span><span class="token function"><span class="token maybe-class-name">K</span></span><span class="token punctuation">(</span><span class="token number">512.0</span>M<span class="token punctuation">)</span><span class="token punctuation">]</span>
 <span class="token comment">// 这个GC活动，CPU时间分配，user:GC线程 sys:系统调用/等待系统事件 real:应用暂停时间</span>
 <span class="token punctuation">[</span><span class="token maybe-class-name">Times</span><span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.02</span> sys<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span> real<span class="token operator">=</span><span class="token number">0.01</span> secs<span class="token punctuation">]</span> </pre></div></code-block></details><details class="wolai-block"><summary><div class="marker placeholder"></div><span class="inline-wrap">混合回收阶段日志</span></summary></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">调优与默认配置</span></summary><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">默认配置</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">建议使用默认配置即可，最多就设置下期望的<span class="jill"></span>GC<span class="jill"></span>暂停时间，以及堆内存大小。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">G1<span class="jill"></span>的默认配置是在吞吐量和延迟上找到平衡。如果你想提高吞吐量，可以适当增大期望的<span class="jill"></span>GC<span class="jill"></span>暂停时间。如果你想降低延期，可以适当减少期望的<span class="jill"></span>GC<span class="jill"></span>暂停时间。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">避免手动设置年轻代大小，由<span class="jill"></span>G1<span class="jill"></span>动态设置即可。</span></div></div><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">FULL GC</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">发生<span class="jill"></span>FULL GC<span class="jill"></span>有三个原因：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">垃圾的生产速度大于垃圾的回收速度</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">内存碎片导致老年代没有足够的内存存放大对象</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">调用了<span class="jill"></span>GC<span class="jill"></span>方法</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">解决方案：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">提高并发标记线程数，加快标记速度，加速进入清理阶段</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">降低进入混合回收阶段的门槛，更早的对老年代进行回收</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">减少大对象的使用，或者增大堆区的大小，避免大对象连续占用多个堆区</span></li></ul><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">具体还是要看<span class="jill"></span>GC<span class="jill"></span>日志，配合各种分析工具，以及<span class="jill"></span>JDK<span class="jill"></span>官网的<span class="jill"></span>G1<span class="jill"></span>调优指南</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://docs.oracle.com/en/java/javase/17/gctuning/garbage-first-g1-garbage-collector1.html">HotSpot Virtual Machine Garbage Collection Tuning Guide</a><div class="info-box"><div class="text-pane"><div data-title="HotSpot Virtual Machine Garbage Collection Tuning Guide"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://docs.oracle.com/sp_common/book-template/ohc-common/img/favicon.ico&quot;)"></div><div data-hostname="docs.oracle.com"></div></div></div><div class="preview-pane"></div></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">参考文献</span></summary><div class="wolai-bookmark wolai-block"><a href="https://docs.oracle.com/en/java/javase/17/gctuning/garbage-first-g1-garbage-collector1.html#GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573">HotSpot Virtual Machine Garbage Collection Tuning Guide</a><div class="info-box"><div class="text-pane"><div data-title="HotSpot Virtual Machine Garbage Collection Tuning Guide"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://docs.oracle.com/sp_common/book-template/ohc-common/img/favicon.ico&quot;)"></div><div data-hostname="docs.oracle.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://www.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All">G1: One Garbage Collector To Rule Them All</a><div class="info-box"><div class="text-pane"><div data-title="G1: One Garbage Collector To Rule Them All"></div><div data-desc="Many articles describe how a poorly tuned garbage collector can bring an application&apos;s SLA commitments to its knees.   Oracle&apos;s new G1 Collector in HotSpot moves away from the conventional GC model, w"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cdn.infoq.com/statics_s1_20220331101138/apple-touch-icon.png&quot;)"></div><div data-hostname="www.infoq.com"></div></div></div><div class="preview-pane" style="background-image: url(https://res.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All/en/smallimage/logo2.jpg)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#g1">GC Algorithms: Implementations | Plumbr – User Experience &amp; Application Performance Monitoring</a><div class="info-box"><div class="text-pane"><div data-title="GC Algorithms: Implementations | Plumbr – User Experience &amp; Application Performance Monitoring"></div><div data-desc="Now that we have reviewed the core concepts behind GC algorithms, let us move to the specific implementations one can find inside the JVM. An important aspect to recognize first is the fact that…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://plumbr.io/app/themes/plumbr/dist/images/favicon_9b72e733.png&quot;)"></div><div data-hostname="plumbr.io"></div></div></div><div class="preview-pane" style="background-image: url(https://plumbr.io/app/uploads/2015/10/plumbr-980.png)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://juejin.cn/post/6939489277936042021">这可能是最清晰易懂的 G1 GC 资料  - 掘金</a><div class="info-box"><div class="text-pane"><div data-title="这可能是最清晰易懂的 G1 GC 资料  - 掘金"></div><div data-desc="G1 是一款分代的 (generational)，增量的 (incremental)，并行的 (parallel)，移动式（evacuating）的，软实时的垃圾回收器。其最大特点是暂停时间可配置，我们可以配置一个最大暂停时间，G1 就会尽可能的在回收的同时保证程序的暂停时间在…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/apple-touch-icon.png&quot;)"></div><div data-hostname="juejin.cn"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://cloud.tencent.com/developer/article/1459638">详解 JVM Garbage First(G1) 垃圾收集器 - 云+社区 - 腾讯云</a><div class="info-box"><div class="text-pane"><div data-title="详解 JVM Garbage First(G1) 垃圾收集器 - 云+社区 - 腾讯云"></div><div data-desc="Garbage First(G1)是垃圾收集领域的最新成果，同时也是HotSpot在JVM上力推的垃圾收集器，并赋予取代CMS的使命。如果使用Java 8/9，..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cloud.tencent.com/favicon.ico&quot;)"></div><div data-hostname="cloud.tencent.com"></div></div></div><div class="preview-pane"></div></div></div></details><h4 class="wolai-block"><span class="inline-wrap">ZGC</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">优点：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">支持<span class="jill"></span>TB<span class="jill"></span>量级的堆；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">最大<span class="jill"></span>GC<span class="jill"></span>停顿时间不超<span class="jill"></span>10ms；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">最糟糕的情况下吞吐量会降低<span class="jill"></span>15%。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">缺点：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">吞吐降低意味着多花钱买机器，延迟降一点用户未必感知的到。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果是底层系统软件，对延迟很敏感，为什么不用<span class="jill"></span>c/cpp/rust<span class="jill"></span>呢？</span></li></ul><div class="wolai-bookmark wolai-block"><a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">新一代垃圾回收器ZGC的探索与实践</a><div class="info-box"><div class="text-pane"><div data-title="新一代垃圾回收器ZGC的探索与实践"></div><div data-desc="ZGC（The Z Garbage Collector）是JDK11中推出的一款低延迟垃圾回收器。ZGC适用于大内存低延迟服务的内存管理和回收，本文主要介绍ZGC在低延时场景中的应用和卓越表现。"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/android-icon-192x192.png?v=Whistle&amp;t=20181017-1r&quot;)"></div><div data-hostname="tech.meituan.com"></div></div></div><div class="preview-pane"></div></div></div><h4 class="wolai-block"><span class="inline-wrap">shenandoah</span></h4><h2 class="wolai-block"><span class="inline-wrap">内存溢出与内存泄露</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>内存溢出</b></span><span class="inline-wrap"> out of memory，是指程序在申请内存时，没有足够的内存空间供其使用；</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>内存泄露</b></span><span class="inline-wrap"> memory leak，是指程序在申请内存后，无法释放已申请的内存空间；</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>内存泄漏可以分为<span class="jill"></span>4<span class="jill"></span>类</b></span><span class="inline-wrap"> ：</span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。</span></li><li><div class="marker"></div><span class="inline-wrap">偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会执行。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。</span></li><li><div class="marker"></div><span class="inline-wrap">一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。</span></li><li><div class="marker"></div><span class="inline-wrap">隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。</span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Java<span class="jill"></span>中内存泄露的发生场景</b></span><span class="inline-wrap"> ：</span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">静态集合类引起内存泄露： 静态集合对象的生命周期和应用程序一致，他们所引用的所有的对象<span class="jill"></span>Object<span class="jill"></span>也不能被释放。</span></li><li><div class="marker"></div><span class="inline-wrap">对象属性被修改后，hash<span class="jill"></span>值发生了改变，导致<span class="jill"></span>remove<span class="jill"></span>方法失效。</span></li><li><div class="marker"></div><span class="inline-wrap">各种连接，例如数据库连接，网络连接和<span class="jill"></span>I/O<span class="jill"></span>连接，除非其显式的调用了其<span class="jill"></span>close<span class="jill"></span>方法将其连接关闭，否则是不会自动被<span class="jill"></span>GC 回收的。</span></li><li><div class="marker"></div><span class="inline-wrap">如果单例对象持有外部对象的引用，那么这个外部对象将不能被<span class="jill"></span>JVM<span class="jill"></span>正常回收，导致内存泄露。</span></li></ol><div class="wolai-bookmark wolai-block"><a href="https://www.zhihu.com/question/33194730/answer/2040441995?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=560497139592011776&amp;utm_content=group1_Answer&amp;utm_campaign=shareopn">JAVA发生OOM后还能运行么？ - 知乎</a><div class="info-box"><div class="text-pane"><div data-title="JAVA发生OOM后还能运行么？ - 知乎"></div><div data-desc="由于仅提到OOM，但 Java 的OOM又分很多类型的呀：堆溢出（“java.lang.OutOfMemoryError: Java heap spa…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.a53ae37b.png&quot;)"></div><div data-hostname="www.zhihu.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://dunwu.github.io/javacore/jvm/jvm-memory.html#_1-%E5%86%85%E5%AD%98%E7%AE%80%E4%BB%8B">Java 内存管理 | JAVACORE</a><div class="info-box"><div class="text-pane"><div data-title="Java 内存管理 | JAVACORE"></div><div data-desc="Java 教程"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://dunwu.github.io/javacore/favicon.ico&quot;)"></div><div data-hostname="dunwu.github.io"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">常用参数</span></h2><div class="wolai-block wolai-text"><div><span class="pink inline-wrap"><b>系统属性、环境变量、程序参数、Java<span class="jill"></span>启动参数</b></span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>System properties</b></span><span class="inline-wrap"> are set on the Java command line using the </span><span class="inline-wrap"><code>-Dpropertyname=value</code></span><span class="inline-wrap"> syntax. They can also be added at runtime using </span><span class="inline-wrap"><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#setProperty-java.lang.String-java.lang.String-"><span><code>System.setProperty(String key, String value)</code></span></a></span><span class="inline-wrap"> or via the various </span><span class="inline-wrap"><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.InputStream-"><span><code>System.getProperties().load()</code></span></a></span><span class="inline-wrap"> methods.To get a specific </span><span class="inline-wrap"><i>system property</i></span><span class="inline-wrap"> you can use </span><span class="inline-wrap"><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getProperty-java.lang.String-"><span><code>System.getProperty(String key)</code></span></a></span><span class="inline-wrap"> or </span><span class="inline-wrap"><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getProperty-java.lang.String-java.lang.String-"><span><code>System.getProperty(String key, String def)</code></span></a></span><span class="inline-wrap">.</span><blockquote class="wolai-block"><span class="inline-wrap">Why system properties needs </span><span class="inline-wrap"><code>-D</code></span><span class="inline-wrap"> flag?
</span><span class="inline-wrap"><code>-D</code></span><span class="inline-wrap"> flag is used to differentiate between </span><span class="inline-wrap"><code>system properties</code></span><span class="inline-wrap"> and </span><span class="inline-wrap"><code>program arguments</code></span><span class="inline-wrap">.</span></blockquote></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Environment variables</b></span><span class="inline-wrap"> are set in the OS, e.g. in Linux </span><span class="inline-wrap"><code>export HOME=/Users/myusername</code></span><span class="inline-wrap"> or on Windows </span><span class="inline-wrap"><code>SET WINDIR=C:\Windows</code></span><span class="inline-wrap"> etc, and, unlike properties, may </span><span class="inline-wrap"><i>not</i></span><span class="inline-wrap"> be set at runtime.
To get a specific </span><span class="inline-wrap"><i>environment variable</i></span><span class="inline-wrap"> you can use </span><span class="inline-wrap"><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getenv-java.lang.String-"><span><code>System.getenv(String name)</code></span></a></span><span class="inline-wrap">.</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Program arguments</b></span><span class="inline-wrap"> 会传递到<span class="jill"></span>main<span class="jill"></span>方法的<span class="jill"></span>args<span class="jill"></span>变量</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Java<span class="jill"></span>启用参数</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Java<span class="jill"></span>的官方文档中将启动参数分为如下三类：</b></span></div></div><div class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 185px"><span class="inline-wrap">配置 参数</span></th><th style="width: 185px"><span class="inline-wrap">类型</span></th><th style="width: 185px"><span class="inline-wrap">说明</span></th><th style="width: 185px"><span class="inline-wrap">举例</span></th></tr></thead><tbody><tr><td><span class="inline-wrap">-</span></td><td><span class="inline-wrap">standard</span></td><td><span class="inline-wrap">这些参数是标准参数，所有的虚拟机实现都需要支持这些参数</span></td><td><br/></td></tr><tr><td><span class="inline-wrap">-X</span></td><td><span class="inline-wrap">non-standard</span></td><td><span class="inline-wrap">这些参数不是虚拟机规范规定的。不是所有<span class="jill"></span>VM<span class="jill"></span>的实现都支持这些配置参数。</span></td><td><span class="inline-wrap">-Xmx、-Xms、-Xmn、-Xss</span></td></tr><tr><td><span class="inline-wrap">-XX</span></td><td><span class="inline-wrap">not-stable</span></td><td><span class="inline-wrap">这些参数被称为不稳定参数，是因为这类参数的设置会引起<span class="jill"></span>JVM<span class="jill"></span>运行时性能上的差异，配置得当可以提高<span class="jill"></span>JVM<span class="jill"></span>性能，配置不当则会使<span class="jill"></span>JVM<span class="jill"></span>出现各种问题, 甚至造成<span class="jill"></span>JVM<span class="jill"></span>崩溃。</span></td><td><span class="inline-wrap">-XX:SurvivorRatio、-XX:+UseParNewGc</span></td></tr></tbody></table></div><blockquote class="wolai-block"><span class="inline-wrap"> -X<span class="jill"></span>和-XX<span class="jill"></span>两种参数都可能随着<span class="jill"></span>JDK<span class="jill"></span>版本的变更而发生变化，有些参数可以能会被废弃掉，有些参数的功能会发生改变，但是<span class="jill"></span>JDK<span class="jill"></span>官方不会通知开发者这些变化，需要使用者注意。</span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap">对于-XX<span class="jill"></span>类型的配置选项，虚拟机规范有一些惯例，针对不同的平台虚拟机也会提供不同的默认值。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对于布尔(Boolean)类型的配置选项，通过</span><span class="inline-wrap"><code>-XX:+&lt;option&gt;</code></span><span class="inline-wrap">来开启，通过</span><span class="inline-wrap"><code>-XX:-&lt;option&gt;</code></span><span class="inline-wrap">来关闭。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对于数字(Numberic)类型的配置选项，通过</span><span class="inline-wrap"><code>-XX:&lt;option&gt;=&lt;number&gt;</code></span><span class="inline-wrap">来配置。</span><span class="inline-wrap"><code>&lt;number&gt;</code></span><span class="inline-wrap">后面可以携带单位字母，比如: &#39;k&#39;或者&#39;K&#39;代表千字节，&#39;m&#39;或者&#39;M&#39;代表兆字节，&#39;g&#39;或者&#39;G&#39;代表千兆字节。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对于字符串(String)类型的配置选项，通过</span><span class="inline-wrap"><code>-XX:&lt;option&gt;=&lt;string&gt;</code></span><span class="inline-wrap">来配置。这种配置通过用来指定文件，路径或者命令列表。</span></li></ul><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token comment"># JDK8</span>
-XX:+PrintGC           <span class="token comment"># 打印GC信息 </span>
-XX:+PrintGCDetails    <span class="token comment"># 打印GC详情信息</span>
-XX:+PrintGCDateStamps <span class="token comment"># 打印GC触发时间</span>
-XX:+PrintGCTimeStamps <span class="token comment"># 打印GC触发时间距离应用启动的时间间隔</span>
-Xloggc:<span class="token operator">&lt;</span>file-path<span class="token operator">></span>    <span class="token comment"># 输出GC日志到指定文件</span>
<span class="token comment"># 推荐</span>
-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -Xloggc:<span class="token operator">&lt;</span>file-path<span class="token operator">></span>

<span class="token comment">#更多参数</span>
https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">并行收集器的常用参数</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>-XX:ParallelGCThreads=&lt;N&gt;</code></span><span class="inline-wrap"> 执行垃圾回收的线程数为<span class="jill"></span>N</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>-XX:MaxGCPauseMillis=&lt;N&gt;</code></span><span class="inline-wrap"> 通过牺牲吞吐量和降低新生代空间来控制最大垃圾收集停顿时间</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>-XX:GCTimeRatio=&lt;N&gt;</code></span><span class="inline-wrap"> 设置吞吐量大小，参数值应该是一个</span><span class="inline-wrap"><code>0</code></span><span class="inline-wrap">到</span><span class="inline-wrap"><code>100</code></span><span class="inline-wrap">的整数，代表垃圾回收时间占总时间的百分比</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>-Xmx&lt;N&gt;</code></span><span class="inline-wrap"> 最大堆内存为<span class="jill"></span>N</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>-Xms&lt;N&gt;</code></span><span class="inline-wrap"> 初始堆内存为<span class="jill"></span>N</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>-XX:+UseAdaptiveSizePolicy=</code></span><span class="inline-wrap"> 一个开关参数，当这个参数打开后，就不需要手工指定新生代的大小（</span><span class="inline-wrap"><code>-Xmn</code></span><span class="inline-wrap">）、</span><span class="inline-wrap"><code>Eden</code></span><span class="inline-wrap">与</span><span class="inline-wrap"><code>Survivor</code></span><span class="inline-wrap">区的比例（</span><span class="inline-wrap"><code>-XX:SurvivorRatio</code></span><span class="inline-wrap">）、晋升老年代对象年龄（</span><span class="inline-wrap"><code>-XX:PretenureSizeThreshold</code></span><span class="inline-wrap">）等细节参数，只需要把基本的内存数据设置好（如</span><span class="inline-wrap"><code>-Xmx</code></span><span class="inline-wrap">设置最大堆），然后使用</span><span class="inline-wrap"><code>MaxGCPauseMillis</code></span><span class="inline-wrap">参数或</span><span class="inline-wrap"><code>GCTimeRation</code></span><span class="inline-wrap">参数给虚拟机设立一个优化目标。</span></li></ul><hr class="wolai-block"/><h2 class="wolai-block"><span class="inline-wrap">性能监控</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">常见<span class="jill"></span>GC<span class="jill"></span>日志分析工具：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagcaL</span></div></div><h3 class="wolai-block"><span class="inline-wrap">进程监控工具</span></h3><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">top</span></summary><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="PowerShell" class="marker"></div><pre><span class="token comment"># 查看所有进程</span>
top 
<span class="token comment"># 查看指定进程</span>
top <span class="token operator">-</span>p pid
<span class="token comment"># 查看指定进程及其线程（线程模式）</span>
top <span class="token operator">-</span>H <span class="token operator">-</span>p pid</pre></div></code-block></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">htop</span></summary><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/htop%E7%AE%80%E4%BB%8B.png" style="width: 760px"/></figure></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">最上面依次显示的是各<span class="jill"></span>CPU<span class="jill"></span>核心的使用情况，内存使用情况，交换区使用情况</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">PID：进程<span class="jill"></span>ID</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">USER：启动该程序的用户</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">PRI：进程的优先级</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">NI： </span><span class="inline-wrap"><a href="https://askubuntu.com/questions/656771/process-niceness-vs-priority"><span>Process &#39;niceness&#39; vs. &#39;priority&#39;</span></a></span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>NI</b></span><span class="inline-wrap"> is the nice value, which is a user-space concept.</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>PR</b></span><span class="inline-wrap"> is the process&#39;s actual priority, as viewed by the Linux kernel.</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">VIRT：虚拟内存使用情况</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">RES：常驻内存大小</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">SHR：共享内存大小</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">自从上次屏幕更新后的 CPU 使用率</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">自从上次屏幕更新后的 </span><span class="inline-wrap"><code>RES</code></span><span class="inline-wrap"> 常驻内存使用率</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">程序启动至今占用的<span class="jill"></span>CPU<span class="jill"></span>时间</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">确切知道 </span><span class="inline-wrap"><code>VIRT</code></span><span class="inline-wrap">，</span><span class="inline-wrap"><code>RES</code></span><span class="inline-wrap"> 和 </span><span class="inline-wrap"><code>SHR</code></span><span class="inline-wrap"> 值代表什么在日常操作中并不重要。重要的是要知道 </span><span class="inline-wrap"><code>VIRT</code></span><span class="inline-wrap"> 值最高的进程就是内存使用最多的进程。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">除了界面列出的快捷键以外，还有一些带有其它功能的快捷键，例如：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>u</code></span><span class="inline-wrap"> 可以选择显示某个用户的进程。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>Shift+m</code></span><span class="inline-wrap"> 可以按照内存使用量对进程列表排序。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>Shift+p</code></span><span class="inline-wrap"> 可以按照 CPU 使用量对进程列表排序。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>Shit+t</code></span><span class="inline-wrap"> 可以按照进程启动时间对进程列表排序。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>CTRL+l</code></span><span class="inline-wrap"> 刷新界面</span></li></ul></details><h3 class="wolai-block"><span class="inline-wrap">网络监控工具</span></h3><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">netstat</span></summary><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="PowerShell" class="marker"></div><pre><span class="token comment"># 列出正在监听的端口</span>
netstat <span class="token operator">-</span>l
<span class="token comment"># 列出正在监听的端口，对域名进行解析</span>
netstat <span class="token operator">-</span>ln
<span class="token comment"># 列出使用TCP协议的正在监听的端口，对域名进行解析</span>
netstat <span class="token operator">-</span>lnt
<span class="token comment"># 列出正在监听的端口，以及监听该端口的进程名称和Id (root用户可以显示所有，其它用户只能看到自己启动的进程名称和Id)</span>
netstat <span class="token operator">-</span><span class="token function">lp</span></pre></div></code-block></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">tcpdump</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://www.cnblogs.com/chyingp/p/linux-command-tcpdump.html"><span>https://www.cnblogs.com/chyingp/p/linux-command-tcpdump.html</span></a></span></div></div></details><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ifconfig</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">nslookup</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ping</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">traceroute</span></li></ul><hr class="wolai-block"/><h3 class="wolai-block"><span class="inline-wrap">Java<span class="jill"></span>性能监控</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">在图形化工具方面，感觉<span class="jill"></span>VisualVM<span class="jill"></span>比<span class="jill"></span>JMC<span class="jill"></span>好用且稳定，但是<span class="jill"></span>VisualVM<span class="jill"></span>在<span class="jill"></span>JFR<span class="jill"></span>方面有所欠缺，所以两者配合着用吧。在实际操作中，一般是不允许<span class="jill"></span>GUI<span class="jill"></span>工具连接线上虚拟机的，所以要掌握一些核心命令，通过命令导出分析数据，再配合图形化工具进行分析。</span></div></div><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">Java<span class="jill"></span>性能监控基础知识</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">Used、Committed、Max Memory</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://stackoverflow.com/questions/41468670/difference-in-used-committed-and-max-heap-memory">Difference in Used, Committed and Max Heap Memory</a><div class="info-box"><div class="text-pane"><div data-title="Difference in Used, Committed and Max Heap Memory"></div><div data-desc="I am monitoring a spark executor JVM of a OutOfMemoryException. I used Jconsole to connect to executor JVM. Following is the snapshot of Jconsole:
In the image used memory is shown as 3.8G and com..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon.png?v=c78bd457575a&quot;)"></div><div data-hostname="stackoverflow.com"></div></div></div><div class="preview-pane" style="background-image: url(https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon.png?v=c78bd457575a)"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Sampler &amp; Profiler</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://stackoverflow.com/questions/39655945/whats-the-difference-between-sampler-and-profiler-in-jvisualvm/39655977">what&#39;s the difference between sampler and profiler in JvisualVM?</a><div class="info-box"><div class="text-pane"><div data-title="what&apos;s the difference between sampler and profiler in JvisualVM?"></div><div data-desc="I found there are two plug-in in JvisualVM, one is  sampler  and another is profiler. 

I also found they have a similar UI, however the results have a big difference, so what&apos;s the difference mean..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon.png?v=c78bd457575a&quot;)"></div><div data-hostname="stackoverflow.com"></div></div></div><div class="preview-pane" style="background-image: url(https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon.png?v=c78bd457575a)"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">MBean</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://docs.oracle.com/javase/tutorial/jmx/mbeans/index.html">Lesson: Introducing MBeans (The Java™ Tutorials &gt; Java Management Extensions (JMX))</a><div class="info-box"><div class="text-pane"><div data-title="Lesson: Introducing MBeans (The Java™ Tutorials &gt; Java Management Extensions (JMX))"></div><div data-desc="This JMX Java tutorial describes the Java Management Extensions (JMX) technology - mbeans, notifications, and remote management"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://docs.oracle.com/favicon.ico&quot;)"></div><div data-hostname="docs.oracle.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Flame Graphis</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://www.brendangregg.com/flamegraphs.html">Flame Graphs</a><div class="info-box"><div class="text-pane"><div data-title="Flame Graphs"></div><div data-desc="Homepage for Flame Graphs: a visualization for stack traces."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://www.brendangregg.com/favicon.ico&quot;)"></div><div data-hostname="www.brendangregg.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">为什么<span class="jill"></span>heap dump<span class="jill"></span>大小看着有点奇怪？</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://stackoverflow.com/questions/32271731/why-is-my-java-heap-dump-size-much-smaller-than-used-memory">Why is my Java heap dump size much smaller than used memory?</a><div class="info-box"><div class="text-pane"><div data-title="Why is my Java heap dump size much smaller than used memory?"></div><div data-desc="Problem

We are trying to find the culprit of a big memory leak in our web application. We have pretty limited experience with finding a memory leak, but we found out how to make a java heap dump u..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon.png?v=c78bd457575a&quot;)"></div><div data-hostname="stackoverflow.com"></div></div></div><div class="preview-pane" style="background-image: url(https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon.png?v=c78bd457575a)"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></details><h3 class="wolai-block"><span class="inline-wrap">Java<span class="jill"></span>监控命令</span></h3><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">jcmd (重点) (用于发送诊断命令给<span class="jill"></span>JVM) </span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">查看本机运行中的<span class="jill"></span>Java<span class="jill"></span>程序</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>jcmd
</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">查看指定的<span class="jill"></span>Java<span class="jill"></span>程序可以执行哪些诊断命令</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>jcmd java_pid <span class="token builtin class-name">help</span> 
<span class="token comment"># 不同JDK版本的程序能使用的诊断命令有点区别</span>
<span class="token comment"># 总的来说，常用的诊断命令，主要有4类：</span>
<span class="token comment"># - 虚拟机相关的</span>
<span class="token comment"># - 垃圾回收相关的</span>
<span class="token comment"># - 线程相关的</span>
<span class="token comment"># - 飞行记录相关的(Java Flight Recorder)</span>
</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">查看具体命令的使用</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token comment"># 不同JDK版本的程序能使用的诊断命令有点区别</span>
<span class="token comment"># 使用的时候，要以该命令输出的使用方式为准</span>
jcmd java_pid <span class="token builtin class-name">help</span> command_name</pre></div></code-block><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap"><b>Java Flight Recorder</b></span></summary><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="PowerShell" class="marker"></div><pre><span class="token comment"># Java飞行记录(Java Flight Recorder)是一个低开销的用于收集Java程序运行时的诊断和侧写信息的框架。</span>
<span class="token comment"># 飞行记录功能是JDK内置的，可以在应用启动时开始记录，也可以在程序运行时开始记录。</span>
JFR<span class="token punctuation">.</span><span class="token function">start</span>
JFR<span class="token punctuation">.</span>stop
JFR<span class="token punctuation">.</span>dump
JFR<span class="token punctuation">.</span>check
JFR<span class="token punctuation">.</span>configure</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>启动应用时开启飞行记录</b></span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="PowerShell" class="marker"></div><pre><span class="token comment"># JVM启动时后开启飞行记录功能，记录120秒，信息记录在myrecording.jfr文件</span>
<span class="token comment"># 更多参数请看https://docs.oracle.com/en/java/javase/14/docs/specs/man/java.html#advanced-runtime-options-for-java</span>
<span class="token comment"># https://docs.oracle.com/javase/10/tools/java.htm#JSWOR624</span>
<span class="token comment">#-XX:+|-FlightRecorder: Enables Java Flight Recorder (not required for JDK 8u40 and later)</span>
<span class="token comment">#-XX:FlightRecorderOptions: Sets the parameters for Java Flight Recorder</span>
<span class="token comment">#-XX:StartFlightRecording: Starts a recording with the provided parameters, or with the default values</span>

java <span class="token operator">-</span>jar app<span class="token punctuation">.</span>jar <span class="token operator">-</span>XX:StartFlightRecording=duration=120s<span class="token punctuation">,</span>filename=myrecording<span class="token punctuation">.</span>jfr</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>启动中的应用开启飞行记录</b></span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="PowerShell" class="marker"></div><pre><span class="token comment"># 启动飞行记录</span>
jcmd java_process_id JFR<span class="token punctuation">.</span><span class="token function">start</span> <span class="token namespace">[options]</span>
<span class="token comment"># 选项</span>
name= <span class="token comment"># 本次飞行记录的名称</span>
delay=x <span class="token comment"># 等待x(s/m/h)后开始记录</span>
duration=x <span class="token comment"># 记录持续x(s/m/h) (0s表示一直记录)</span>
disk=true<span class="token operator">/</span>false <span class="token comment"># 是否把记录数据写到磁盘</span>
filename= <span class="token comment"># 停止记录时，把记录的数据写入到指定的文件中</span>
maxage= <span class="token comment">#</span>
maxsize= <span class="token comment">#</span>
settings= <span class="token comment"># 飞行记录配置文件的路径</span>
path<span class="token operator">-</span>to<span class="token operator">-</span><span class="token function">gc</span><span class="token operator">-</span>root=true<span class="token operator">/</span>false <span class="token comment"># </span>

<span class="token comment"># 停止飞行记录</span>
jcmd java_process_id JFR<span class="token punctuation">.</span>stop <span class="token namespace">[options]</span>
<span class="token comment"># 选项</span>
name= <span class="token comment"># 本次飞行记录的名称</span>
filename= <span class="token comment"># 停止记录时，把记录的数据写入到指定的文件中</span>

<span class="token comment"># 转储</span>
jcmd java_process_id JFR<span class="token punctuation">.</span>dump <span class="token namespace">[options]</span>
<span class="token comment"># 选项</span>
<span class="token comment"># 其它看https://docs.oracle.com/en/java/javase/14/docs/specs/man/jcmd.html吧，难得搬了</span></pre></div></code-block><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap"><b>Java Flight Recording<span class="jill"></span>实战</b></span></summary><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="PowerShell" class="marker"></div><pre>jcmd java_pid JFR<span class="token punctuation">.</span><span class="token function">start</span> name=jfr duration=1h disk=true filename=$<span class="token punctuation">(</span><span class="token function">pwd</span><span class="token punctuation">)</span><span class="token operator">/</span>$<span class="token punctuation">(</span>date <span class="token string">"+%Y-%m-%dT%H:%M:%S"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>jfr</pre></div></code-block><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="PowerShell" class="marker"></div><pre>jcmd java_pid JFR<span class="token punctuation">.</span>dump filename=$<span class="token punctuation">(</span><span class="token function">pwd</span><span class="token punctuation">)</span><span class="token operator">/</span>$<span class="token punctuation">(</span>date <span class="token string">"+%Y-%m-%dT%H:%M:%S"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>jfr</pre></div></code-block></details></details></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">arthas (重点)</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="http://hengyunabc.github.io/arthas-online-hotswap/"><span>Arthas<span class="jill"></span>实践--jad/mc/redefine<span class="jill"></span>线上热更新一条龙</span></a></span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">old-fashioned</span></summary><details class="wolai-block"><summary><div class="marker placeholder"></div><span class="inline-wrap">jps：查看<span class="jill"></span>java<span class="jill"></span>进程，直接用<span class="jill"></span>jcmd<span class="jill"></span>就可以了</span></summary></details><details class="wolai-block"><summary><div class="marker placeholder"></div><span class="inline-wrap">jstack：用来生成所有线程以及相应的堆栈跟踪。直接用<span class="jill"></span>jcmd<span class="jill"></span>就可以了</span></summary></details><details class="wolai-block"><summary><div class="marker placeholder"></div><span class="inline-wrap">jhat：(Java Heap Analysis Tool) 从<span class="jill"></span>JDK9<span class="jill"></span>开始移除。直接用<span class="jill"></span>jcmd<span class="jill"></span>就可以了</span></summary></details><details class="wolai-block"><summary><div class="marker placeholder"></div><span class="inline-wrap">jmap：用来生成堆转储文件(heap dump)。直接用<span class="jill"></span>jcmd<span class="jill"></span>就可以了</span></summary></details></details><h3 class="wolai-block"><span class="inline-wrap">Java<span class="jill"></span>监控图形化工具</span></h3><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">VisualVM</span></summary><div class="wolai-bookmark wolai-block"><a href="https://marknienaber.medium.com/how-to-monitor-your-java-applications-jvm-70d7bddea668">https://marknienaber.medium.com/how-to-monitor-your-java-applications-jvm-70d7bddea668</a><div class="info-box"><div class="text-pane"><div data-title="marknienaber.medium.com"></div><div class="icon-host"><div data-hostname="marknienaber.medium.com"></div></div></div><div class="preview-pane"></div></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">JMC</span></summary><div class="wolai-bookmark wolai-block"><a href="https://www.youtube.com/watch?v=n65XC0eceSM">https://www.youtube.com/watch?v=n65XC0eceSM</a><div class="info-box"><div class="text-pane"><div data-title="www.youtube.com"></div><div class="icon-host"><div data-hostname="www.youtube.com"></div></div></div><div class="preview-pane"></div></div></div></details><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">MAT</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><a href="https://heaphero.io/heap-index.jsp"><span>heap-hero 一个分析<span class="jill"></span>heap dump<span class="jill"></span>的网站</span></a></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><a href="https://fastthread.io/"><span>fastthread 一个分析<span class="jill"></span>thread dump<span class="jill"></span>的网站</span></a></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><a href="https://jstack.review/#tda_1_dump"><span>jstack 一个分析<span class="jill"></span>thread dump<span class="jill"></span>的网站</span></a></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><a href="https://gceasy.io/"><span>gceasy 一个分析<span class="jill"></span>GC<span class="jill"></span>日志的网站</span></a></span></li></ul><h3 class="wolai-block"><span class="inline-wrap">实战</span></h3><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">实战：排查<span class="jill"></span>CPU<span class="jill"></span>占用率高</span></summary><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">找出占用<span class="jill"></span>CPU<span class="jill"></span>高的线程，然后<span class="jill"></span>jcmd<span class="jill"></span>获取<span class="jill"></span>thread dump，找出对应线程当前代码</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">实战：死锁排查</span></summary><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">直接<span class="jill"></span>jcmd<span class="jill"></span>获取<span class="jill"></span>thread dump，扔去网站分析</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">怎么写一个死锁？</span></summary><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="纯文本" class="marker"></div><pre>o1<span class="token punctuation">,</span>o2<span class="token punctuation">;</span>

<span class="token constant">T1</span><span class="token operator">:</span>
<span class="token function">lock</span><span class="token punctuation">(</span><span class="token parameter">o1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// do something</span>
  <span class="token function">lock</span><span class="token punctuation">(</span><span class="token parameter">o2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// do something</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token constant">T2</span><span class="token operator">:</span>
<span class="token function">lock</span><span class="token punctuation">(</span><span class="token parameter">o2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// do something</span>
  <span class="token function">lock</span><span class="token punctuation">(</span><span class="token parameter">o1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// do something</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block></details></details><details class="wolai-block"><summary><div class="marker placeholder"></div><span class="inline-wrap">实战：OOM<span class="jill"></span>分析</span></summary></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">实战：内存泄露</span></summary><div class="wolai-bookmark wolai-block"><a href="https://www.zhihu.com/question/484689143/answer/2251908039?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=560497139592011776&amp;utm_content=group3_Answer&amp;utm_campaign=shareopn">如何排查 Java 应用内存泄漏问题？ - 知乎</a><div class="info-box"><div class="text-pane"><div data-title="如何排查 Java 应用内存泄漏问题？ - 知乎"></div><div data-desc="前言最近翻看以前写的 PPT， 发现了在2019年做的一次技术分享，关于 Java 问题排查，由于没什么公司机密…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.a53ae37b.png&quot;)"></div><div data-hostname="www.zhihu.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></details><div class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>
<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>JVM运行时数据区 - wolai 笔记</title><link rel="shortcut icon"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="JVM运行时数据区
" class="main-title"></div></div></header><article><div class="wolai-block wolai-text"><div><span class="inline-wrap">根据<span class="jill"></span>Java<span class="jill"></span>虚拟机规范，Java<span class="jill"></span>虚拟机的运行时数据区有<span class="jill"></span>5<span class="jill"></span>部分组成。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" style="width: 760px"/></figure></div><h2 class="wolai-block"><span class="inline-wrap">程序计数器</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">线程私有，记录当前正在执行的字节码指令的地址，如果执行的是本地方法则为</span><span class="inline-wrap"><code>undefined</code></span><span class="inline-wrap">。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">可以看作是当前线程所执行字节码的行号指示器</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">字节码解释器工作时就是通过改变这个计数器的值来获取下一条需要执行的字节码指令</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">我们学过多线程，有两个线程，其中一个线程可以暂停使用，让其他线程运行，然后等自己获得<span class="jill"></span>cpu<span class="jill"></span>资源时，又能从暂停的地方开始运行，那么为什么能够记住暂停的位置的，这就依靠了程序计数器。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">虚拟机栈</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">线程私有，用来存放栈帧。一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在某些情况下虚拟机栈会出现以下异常：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">线程请求的虚拟机栈大小超出了虚拟机的许可，出现</span><span class="inline-wrap"><code>StackOverflowError</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">虚拟机栈的大小可以动态扩展，但是已经没有内存可以给它使用了，出现</span><span class="inline-wrap"><code>OutOfMemoryError</code></span></li></ul><aside class="bg-cultured wolai-block"><div data-symbol="🔥" class="icon"></div><span class="inline-wrap">不显式设置-</span><span class="inline-wrap"><code>Xss</code></span><span class="inline-wrap">或</span><span class="inline-wrap"><code>-XX:ThreadStackSize</code></span><span class="inline-wrap">时，在<span class="jill"></span>Linux x64<span class="jill"></span>上</span><span class="inline-wrap"><code>ThreadStackSize</code></span><span class="inline-wrap">的默认值就是</span><span class="inline-wrap"><code>1MB</code></span><span class="inline-wrap">，给<span class="jill"></span>Java<span class="jill"></span>线程创建栈会用这个参数指定的大小。</span></aside><h2 class="wolai-block"><span class="inline-wrap">本地方法栈</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">本地方法栈与虚拟机栈所发挥的作用很相似，只不过前者是为本地方法服务，后者是为<span class="jill"></span>Java<span class="jill"></span>方法服务。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">Java<span class="jill"></span>堆</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>堆，所有线程共享的一块内存区域，在虚拟机启动时创建。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">它存储的对象(类实例和数组)由垃圾回收器进行回收。对象永远不会被显式释放。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">方法区</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">方法区是线程共享的内存区域，它存储了每一个类的结构信息，例如运行时常量池、字段、方法数据、方法、构造器、类和实例和接口初始化使用的特殊方法。</span></div></div><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">方法区、永久代、元空间之间是什么关系？</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">方法区是规范，永久代和元空间是方法区的实现。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">JDK1.8<span class="jill"></span>之前，Hotspot<span class="jill"></span>虚拟机用的是永久代，JDK1.8<span class="jill"></span>及之后，Hotspot<span class="jill"></span>虚拟机用的是元空间。</span></div></div><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">什么是运行时常量池？</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">运行时常量池是方法区的一部分。用于存放编译期生成的各种字面量和符号引用。</span></div></div><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">变量、常量、字面量</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">final</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//a为常量，10为字面量</span>
<span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span> <span class="token comment">// b 为变量，hello world！为字面量</span>
</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">什么是字符串常量池？</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">JVM<span class="jill"></span>维护了一个字符串常量池。你可以利用它存储和获取字符串。从而减少相同字符串的数量。
</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>提供了两种创建字符串的方式：字面量以及</span><span class="inline-wrap"><code>new</code></span><span class="inline-wrap"> 关键字。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">字面量字符串，会存放在运行时常量池，同时也会在字符串常量池存放该引用</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>new</code></span><span class="inline-wrap"> 关键字创建的字符串存放在堆中</span></li></ul><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre>  <span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span>
  <span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// str1和str2是运行时常量池中的同一个对象</span>
  
  <span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">String</span> str4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str3 <span class="token operator">==</span> str4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// str3和str4分别是堆中的两个不同对象</span>
</pre></div></code-block><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">通过</span><span class="inline-wrap"><code>intern</code></span><span class="inline-wrap">方法，可以在创建字符串对象时，先查看该字符串是否已存在字符串常量池中，如果是就直接返回池中对象的引用，否则，就在堆中创建该字符串，然后把该字符串的引用放入池中。</span></li></ul><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token comment">// "Hello World"已经存在字符串常量池中，所以不用在堆中创建字符串</span>
<span class="token class-name">String</span> str5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str5<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 因为"Java"不在字符串常量池中，所以需要先在堆中创建字符串，然后再放入字符串常量池</span>
<span class="token class-name">String</span> str6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Java"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 因为此时"Java"已在字符串常量池中，所以无需再在堆中创建该字符串了</span>
<span class="token class-name">String</span> str7 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Java"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str6 <span class="token operator">==</span> str7<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></div></code-block><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">下面三条语句有什么区别？分别会在内存中创建几个字符串？</span></li></ul><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token string">"Java"</span><span class="token punctuation">;</span> <span class="token comment">// 存储在运行时常量池，字符串常量池会有该引用</span>
<span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 运行时常量池和堆中分别存储一份</span>
<span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Java"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 直接通过字符串常量池获取"Java"在运行时常量池中的引用</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">为什么使用元空间代替永久代？</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://segmentfault.com/a/1190000041118595">https://segmentfault.com/a/1190000041118595</a><div class="info-box"><div class="text-pane"><div data-title="segmentfault.com"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://segmentfault.com/favicon.ico&quot;)"></div><div data-hostname="segmentfault.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://www.cnblogs.com/duanxz/p/3520829.html">Metaspace 之一：Metaspace整体介绍（永久代被替换原因、元空间特点、元空间内存查看分析方法） - duanxz - 博客园</a><div class="info-box"><div class="text-pane"><div data-title="Metaspace 之一：Metaspace整体介绍（永久代被替换原因、元空间特点、元空间内存查看分析方法） - duanxz - 博客园"></div><div data-desc="回顾 根据JVM内存区域的划分，简单的画了下方的这个示意图。区域主要分为两大块，一块是堆区（Heap），我们所New出的对象都会在堆区进行分配，在C语言中的malloc所分配的方法就是从Heap区获取"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://common.cnblogs.com/favicon.svg&quot;)"></div><div data-hostname="www.cnblogs.com"></div></div></div><div class="preview-pane"></div></div></div><h2 class="wolai-block"><span class="inline-wrap">栈帧</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">栈帧是用来存储数据和部分过程结果的数据结构，同时也用来处理动态链接、方法返回值、异常分发。</span></div></div><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">栈帧存放了本地变量表、操作数栈和指向当前方法所属的类的运行时常量池的引用。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>动态链接</b></span><span class="inline-wrap">：一个方法若要调用其他方法、或者访问成员变量，需要通过符号引用来表示，动态链接的作用就是将这些符号引用转换为实际方法或变量的直接引用。所谓的函数、方法、数据，其实都只是内存里的一段字节。对于运行中的程序来说，无论是调用方法，还是读写数据，它先要知道方法或数据在内存中的位置。
但是我们写代码，只会写方法的路径或变量名(</span><span class="pink inline-wrap">符号引用</span><span class="inline-wrap">)，而不会写方法或变量在内存中的地址，这中间就需要有一个转换的过程，这个过程叫作链接。</span></div></div><aside class="bg-cultured wolai-block"><div data-symbol="🚀" class="icon"></div><span class="inline-wrap">静态链接、动态链接</span></aside><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></article><footer></footer></body></html>
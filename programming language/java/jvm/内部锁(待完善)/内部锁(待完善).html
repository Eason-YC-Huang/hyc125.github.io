<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>内部锁(待完善) - wolai 笔记</title><link rel="shortcut icon"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="内部锁(待完善)" class="main-title"></div></div></header><article><div class="wolai-bookmark wolai-block"><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">Synchronization
 - 

    Synchronization
      - 
  
OpenJDK Wiki</a><div class="info-box"><div class="text-pane"><div data-title="Synchronization
 - 

    Synchronization
      - 
  
OpenJDK Wiki"></div><div data-desc="Synchronization and Object Locking Written by Thomas Kotzmann and Christian Wimmer One of the major strengths of the Java programming language is its built-in support for multi-threaded programs. An o"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://wiki.openjdk.java.net/plugins/servlet/theme/engine/resource/OPENJDKV1/nanoduke.ico&quot;)"></div><div data-hostname="wiki.openjdk.java.net"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://mp.weixin.qq.com/s/G4z08HfiqJ4qm3th0KtovA">再谈synchronized锁升级</a><div class="info-box"><div class="text-pane"><div data-title="再谈synchronized锁升级"></div><div data-desc="趁着小长假，快来学习一波~"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;http://res.wx.qq.com/a/wx_fed/assets/res/MjliNWVm.svg&quot;)"></div><div data-hostname="mp.weixin.qq.com"></div></div></div><div class="preview-pane" style="background-image: url(http://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jiaUdm5WGURS0WZvMcX92C1Gvib6H1T9NFaR2IQn4LNzUVg4rgqMyJLIw/0?wx_fmt=jpeg)"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在</span><span class="inline-wrap"><a href="https://www.wolai.com/5QZVATPqpRcVNMYdjHgcLV#5QZVATPqpRcVNMYdjHgcLV" class="wolai-bi-link"><span class="embed-page">对象内存布局</span></a></span><span class="inline-wrap">这篇文章中，我们知道了</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap"> 锁的信息是存放在标志字(</span><span class="inline-wrap"><code>MarkWord</code></span><span class="inline-wrap">)里面的，接下来我们详细研究一下锁升级的过程以及各个状态下锁的原理。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">本文结构如下：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">无锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">偏向锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">轻量级锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">重量级锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">总结</span></li></ul><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image.png" style="width: 756px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>jdk6 之前，通过</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">关键字加锁时使用无差别的的重量级锁，重量级锁会造成线程的串行执行，并且使<span class="jill"></span>cpu<span class="jill"></span>在用户态和核心态之间频繁切换。随着对</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">的不断优化，提出了锁升级的概念，并引入了偏向锁、轻量级锁、重量级锁。</span></div></div><div class="wolai-row"><div class="wolai-col" style="flex-grow: 0.8770949720670391"><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-bookmark wolai-block"><a href="https://stackoverflow.com/questions/68765997/regarding-the-usage-of-lock-records-in-the-implementation-of-thin-locks-in-hotsp">Regarding the usage of lock records in the implementation of thin-locks in HotSpot</a><div class="info-box"><div class="text-pane"><div data-title="Regarding the usage of lock records in the implementation of thin-locks in HotSpot"></div><div data-desc="I&apos;m having some trouble understanding what the lifecycle of lock records is when dealing with &amp;quot;thin-locks&amp;quot; on HotSpot.
My understanding is that:

When a thread T first attempts to acquire a
"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon.png?v=c78bd457575a&quot;)"></div><div data-hostname="stackoverflow.com"></div></div></div><div class="preview-pane" style="background-image: url(https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon.png?v=c78bd457575a)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://www.v2ex.com/t/671698">https://www.v2ex.com/t/671698</a><div class="info-box"><div class="text-pane"><div data-title="www.v2ex.com"></div><div class="icon-host"><div data-hostname="www.v2ex.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization#Synchronization-Agesen99">Synchronization
 - 

    Synchronization
      - 
  
OpenJDK Wiki</a><div class="info-box"><div class="text-pane"><div data-title="Synchronization
 - 

    Synchronization
      - 
  
OpenJDK Wiki"></div><div data-desc="Synchronization and Object Locking Written by Thomas Kotzmann and Christian Wimmer One of the major strengths of the Java programming language is its built-in support for multi-threaded programs. An o"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://wiki.openjdk.java.net/plugins/servlet/theme/engine/resource/OPENJDKV1/nanoduke.ico&quot;)"></div><div data-hostname="wiki.openjdk.java.net"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://quarkus.io/blog/biased-locking-help/">Biased locking removed from Java - does it affect you ?</a><div class="info-box"><div class="text-pane"><div data-title="Biased locking removed from Java - does it affect you ?"></div><div data-desc="Quarkus: Supersonic Subatomic Java"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://quarkus.io/favicon.ico&quot;)"></div><div data-hostname="quarkus.io"></div></div></div><div class="preview-pane" style="background-image: url(https://quarkus.io/assets/images/quarkus_card.png)"></div></div></div><div class="wolai-block wolai-text"><div></div></div></div><div class="wolai-col" style="flex-grow: 0.12290502793296089"><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></div></div><h2 class="wolai-block"><span class="inline-wrap">偏向锁</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">什么是偏向锁？</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">偏向锁原理</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">匿名偏向状态是偏向锁的初始状态，在这个状态下第一个试图获取该对象的锁的线程，会使用<span class="jill"></span>CAS<span class="jill"></span>操作（汇编命令</span><span class="inline-wrap"><code>CMPXCHG</code></span><span class="inline-wrap">）尝试将自己的</span><span class="inline-wrap"><code>threadID</code></span><span class="inline-wrap">写入对象头的</span><span class="inline-wrap"><code>mark word</code></span><span class="inline-wrap">中，使匿名偏向状态升级为</span><span class="inline-wrap"><b>已偏向</b></span><span class="inline-wrap">（Biased）的偏向锁状态。在已偏向状态下，线程指针</span><span class="inline-wrap"><code>threadID</code></span><span class="inline-wrap">非空，且偏向锁的时间戳</span><span class="inline-wrap"><code>epoch</code></span><span class="inline-wrap">为有效值。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果之后有线程再次尝试获取锁时，需要检查</span><span class="inline-wrap"><code>mark word</code></span><span class="inline-wrap">中存储的</span><span class="inline-wrap"><code>threadID</code></span><span class="inline-wrap">是否与自己相同即可，如果相同那么表示当前线程已经获得了对象的锁，不需要再使用<span class="jill"></span>CAS<span class="jill"></span>操作来进行加锁。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果</span><span class="inline-wrap"><code>mark word</code></span><span class="inline-wrap">中存储的</span><span class="inline-wrap"><code>threadID</code></span><span class="inline-wrap">与当前线程不同，那么将执行<span class="jill"></span>CAS<span class="jill"></span>操作，试图将当前线程的<span class="jill"></span>ID<span class="jill"></span>替换</span><span class="inline-wrap"><code>mark word</code></span><span class="inline-wrap">中的</span><span class="inline-wrap"><code>threadID</code></span><span class="inline-wrap">。只有当对象处于下面两种状态中时，才可以执行成功：</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对象处于匿名偏向状态</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对象处于</span><span class="inline-wrap"><b>可重偏向</b></span><span class="inline-wrap">（Rebiasable）状态，新线程可使用<span class="jill"></span>CAS<span class="jill"></span>将</span><span class="inline-wrap"><code>threadID</code></span><span class="inline-wrap">指向自己</span></li></ul></li></ul><h2 class="wolai-block"><span class="inline-wrap">总结</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>jdk6 之前，通过</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">关键字加锁时使用无差别的的重量级锁，重量级锁会造成线程的串行执行，并且使<span class="jill"></span>cpu<span class="jill"></span>在用户态和核心态之间频繁切换。随着对</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">的不断优化，提出了锁升级的概念，并引入了偏向锁、轻量级锁、重量级锁。在</span><span class="inline-wrap"><code>mark word</code></span><span class="inline-wrap">中，锁（</span><span class="inline-wrap"><code>lock</code></span><span class="inline-wrap">）标志位占用<span class="jill"></span>2<span class="jill"></span>个<span class="jill"></span>bit，结合<span class="jill"></span>1<span class="jill"></span>个<span class="jill"></span>bit<span class="jill"></span>偏向锁（</span><span class="inline-wrap"><code>biased_lock</code></span><span class="inline-wrap">）标志位，这样通过倒数的<span class="jill"></span>3<span class="jill"></span>位，就能用来标识当前对象持有的锁的状态，并判断出其余位存储的是什么信息。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">锁升级的流程如下：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">1、锁对象刚创建时，没有任何线程竞争，对象处于无锁状态。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_1.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在上面打印的空对象的内存布局中，根据大小端，得到最后<span class="jill"></span>8<span class="jill"></span>位是</span><span class="inline-wrap"><code>00000001</code></span><span class="inline-wrap">，表示处于无锁态，并且处于不可偏向状态。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">这是因为在<span class="jill"></span>jdk<span class="jill"></span>中偏向锁存在延迟<span class="jill"></span>4<span class="jill"></span>秒启动，也就是说在<span class="jill"></span>jvm<span class="jill"></span>启动后<span class="jill"></span>4<span class="jill"></span>秒后创建的对象才会开启偏向锁，我们通过<span class="jill"></span>jvm<span class="jill"></span>参数取消这个延迟时间：</span><span class="inline-wrap"><code>-XX:BiasedLockingStartupDelay=0</code></span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_2.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">此时</span><span class="inline-wrap"><code>mark word</code></span><span class="inline-wrap">中后三位已经是</span><span class="inline-wrap"><code>101</code></span><span class="inline-wrap">，但是</span><span class="inline-wrap"><code>threadId</code></span><span class="inline-wrap">指针部分仍然全部为<span class="jill"></span>0，它还没有偏向任何线程，这种情况叫做</span><span class="inline-wrap"><b>匿名偏向</b></span><span class="inline-wrap">(</span><span class="inline-wrap"><code>Anonymously biased</code></span><span class="inline-wrap">)状态</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">通过设置<span class="jill"></span>JVM<span class="jill"></span>参数</span><span class="inline-wrap"><code>-XX:-UseBiasedLocking</code></span><span class="inline-wrap">我们可以关闭偏向锁</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">延迟<span class="jill"></span>5s<span class="jill"></span>后打印对象内存布局：</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
      <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_3.png" style="width: 756px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以看到，即使经过一定的启动延时，对象一直处于</span><span class="inline-wrap"><code>001</code></span><span class="inline-wrap">无锁状态。大家可能会有疑问，为什么会有启动延时？通过查阅资料得到的解释是：</span></div></div><blockquote class="wolai-block"><span class="inline-wrap">JVM<span class="jill"></span>内部的代码有很多地方也用到了<span class="jill"></span>synchronized，明确在这些地方存在线程的竞争，如果还需要从偏向状态再逐步升级，会带来额外的性能损耗，所以<span class="jill"></span>JVM<span class="jill"></span>设置了一个偏向锁的启动延迟，来降低性能损耗</span></blockquote><blockquote class="wolai-block"><span class="inline-wrap">额外注意一点就是匿名偏向状态下，如果调用系统的</span><span class="inline-wrap"><code>hashCode()</code></span><span class="inline-wrap">方法，会使对象回到无锁态，并在</span><span class="inline-wrap"><code>markword</code></span><span class="inline-wrap">中写入</span><span class="inline-wrap"><code>hashCode</code></span><span class="inline-wrap">。并且在这个状态下，如果有线程尝试获取锁，会直接从无锁升级到轻量级锁，不会再升级为偏向锁。</span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap">2、处于匿名偏向状态，在没有线程竞争的条件下，第一个获取锁的线程通过</span><span class="inline-wrap"><code>CAS</code></span><span class="inline-wrap">将自己的</span><span class="inline-wrap"><code>threadId</code></span><span class="inline-wrap">写入到该对象的</span><span class="inline-wrap"><code>mark word</code></span><span class="inline-wrap">中，若后续该线程再次获取锁，需要比较当前线程</span><span class="inline-wrap"><code>threadId</code></span><span class="inline-wrap">和对象</span><span class="inline-wrap"><code>mark word</code></span><span class="inline-wrap">中的</span><span class="inline-wrap"><code>threadId</code></span><span class="inline-wrap">是否一致，如果一致那么可以直接获取，并且锁对象始终保持对该线程的偏向，也就是说偏向锁不会主动释放。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用代码进行测试同一个线程重复获取锁的过程：</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">User</span> user<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">执行结果：</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_4.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_5.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以看到一个线程首次获取可偏向状态的锁时，会将自己的</span><span class="inline-wrap"><code>threadId</code></span><span class="inline-wrap">写入到该对象的</span><span class="inline-wrap"><code>mark word</code></span><span class="inline-wrap">中，之后的解锁、重新获取对象的锁时，</span><span class="inline-wrap"><code>mark word</code></span><span class="inline-wrap">都没有发生变化，偏向锁中的当前线程指针始终指向同一个线程。</span></div></div><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">3、处于无锁状态的锁，在获取锁时，会直接升级为轻量级锁</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_6.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">同样是上面的代码，但是不使用</span><span class="inline-wrap"><code>-XX:BiasedLockingStartupDelay=0</code></span><span class="inline-wrap">，可以看到最初是无锁状态，加锁后，锁变成轻量级锁，释放锁后，锁又退回无锁状态</span></div></div><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">4、处于偏向状态时，当两个或以上线程交替获取锁，但并没有在对象上并发的获取锁时，偏向锁升级为轻量级锁。</span><span class="inline-wrap">在此阶段，线程采取</span><span class="inline-wrap"><code>CAS</code></span><span class="inline-wrap">的自旋方式尝试获取锁，避免阻塞线程造成的<span class="jill"></span>cpu<span class="jill"></span>在用户态和内核态间转换的消耗。测试代码如下：</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_7.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_8.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以看到，另一条线程获取锁时，锁升级成了轻量级锁，最后锁变成了无锁状态</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">4、处于可被偏向状态，当两个或以上线程并发的在同一个对象上进行同步时，偏向锁会升级成重量级锁。这时</span><span class="inline-wrap"><code>mark word</code></span><span class="inline-wrap">中的指针指向的是</span><span class="inline-wrap"><code>monitor</code></span><span class="inline-wrap">对象（也被称为管程或监视器锁）的起始地址。测试代码如下：</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--THREAD1--:"</span> <span class="token operator">+</span> <span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--THREAD2--:"</span> <span class="token operator">+</span> <span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_9.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">简单来说就是：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">先判断是无锁还是偏向锁，然后判断是多线程顺序获取锁，还是并发获取锁</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">无锁且多线程顺序：无锁→轻量级锁</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">无锁且多线程并发：无锁</span><span class="inline-wrap">→轻量级锁</span><span class="inline-wrap">→重量级锁</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">偏向锁且多线程顺序：偏向锁→轻量级锁</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">偏向锁且</span><span class="inline-wrap">多线程并发：</span><span class="inline-wrap">偏向锁</span><span class="inline-wrap">→轻量级锁</span><span class="inline-wrap">→重量级锁</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">重量级锁，在释放后，锁会变成无锁状态</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>
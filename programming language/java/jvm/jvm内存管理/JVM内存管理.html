<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>JVM内存管理 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="JVM内存管理" class="main-title"></div></div></header><article><h1 class="wolai-block"><span class="inline-wrap">JVM<span class="jill"></span>运行时数据区</span></h1><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>程序运行在<span class="jill"></span>JVM<span class="jill"></span>中，JVM<span class="jill"></span>也是一个程序，在它运行的时候操作系统会给它分配内存空间，JVM<span class="jill"></span>会把自己内存空间划分为多个区域，用来存放<span class="jill"></span>Java<span class="jill"></span>程序数据。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>虚拟机在执行<span class="jill"></span>Java<span class="jill"></span>程序的时候，会把它所管理的内存划分为若干个不同的区域。</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" style="width: 760px"/></figure></div><h2 class="wolai-block"><span class="inline-wrap">1.程序计数器（program counter）</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">程序计数器，线程私有，在执行非本地方法时，记录当前正在执行的字节码指令的地址，如果是本地方法（Native Method），值为</span><span class="inline-wrap"><code>undefined</code></span><span class="inline-wrap">。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">可以看作是当前线程所执行字节码的行号指示器</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">字节码解释器工作时就是通过改变这个计数器的值来获取下一条需要执行的字节码指令</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">我们学过多线程，有两个线程，其中一个线程可以暂停使用，让其他线程运行，然后等自己获得<span class="jill"></span>cpu<span class="jill"></span>资源时，又能从暂停的地方开始运行，那么为什么能够记住暂停的位置的，这就依靠了程序计数器。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">2.虚拟机栈</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">虚拟机栈，线程私有，用来存放栈帧。一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在某些情况下虚拟机栈会出现以下异常：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">线程请求的虚拟机栈大小超出了虚拟机的许可，出现栈溢出（</span><span class="inline-wrap"><code>StackOverflowError</code></span><span class="inline-wrap">）（每条线程的虚拟机栈多大？）</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">虚拟机栈的大小可以动态扩展，但是已经没有内容可以给它使用了，出现</span><span class="inline-wrap"><code>OutOfMemoryError</code></span></li></ul><h3 class="wolai-block"><span class="inline-wrap">2.1<span class="jill"></span>栈帧</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">栈帧是用来存储数据和部分过程结果的数据结构，同时也用来处理动态链接（dynamic linking）、方法返回值、异常分发（dispatch exception）。每个栈帧存放了本地变量表、操作数栈和指向当前方法所属的类的运行时常量池的引用。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>动态链接</b></span><span class="inline-wrap">：一个方法若要调用其他方法、或者访问成员变量，需要通过符号引用来表示，动态链接的作用就是将这些符号引用转换为实际方法或变量的直接引用。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">2.2<span class="jill"></span>内存模型</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">虚拟机栈描述的是<span class="jill"></span>Java<span class="jill"></span>方法执行的内存模型。什么是内存模型？ 有兴趣的可以看看着两篇文章</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><a href="https://www.cnblogs.com/adinosaur/p/6243605.html"><span>什么是内存模型？</span></a></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><a href="http://developer.51cto.com/art/201807/579744.htm"><span>终于有人把<span class="jill"></span>Java<span class="jill"></span>内存模型说清楚了</span></a></span></li></ul><h2 class="wolai-block"><span class="inline-wrap">3.本地方法栈</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">本地方法栈与虚拟机栈所发挥的作用是非常相似的，只不过一个是为<span class="jill"></span>Java<span class="jill"></span>方法服务，一个是为<span class="jill"></span>Native<span class="jill"></span>方法服务。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">4.Java<span class="jill"></span>堆</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>堆，所有线程共享的一块内存区域，在虚拟机启动时创建。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">它存储的对象(类实例和数组)由垃圾回收器进行回收。对象永远不会被显式释放。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">堆的大小可以是固定的，也可以动态扩展，具体看它的实现。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">5.方法区</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">方法区是线程共享的内存区域，它存储了每一个类的结构信息，例如运行时常量池、字段、方法数据、方法、构造器、类和实例和接口初始化使用的特殊方法（</span><span class="inline-wrap"><code>special methods</code></span><span class="inline-wrap">）</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">The method area is analogous to the storage area for compiled code of a conventional language or analogous to the &quot;text&quot; segment in an operating system process.</span></div></div><h3 class="wolai-block"><span class="inline-wrap">5.1.运行时常量池</span></h3><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">运行时常量池是方法区的一部分。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">运行时常量池用于存放编译期生成的各种字面量和符号引用。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">符号引用：用一组符号来描述所引用的目标，符号可以是任意形式的字面量，只要使用时能无歧义的定位到目标即可。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">运行时常量池包含几种常量，从编译时已知的数字文字到必须在运行时解析的方法和字段引用。</span></li></ul><h1 class="wolai-block"><span class="inline-wrap">内存溢出与内存泄露</span></h1><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>内存溢出</b></span><span class="inline-wrap"> out of memory，是指程序在申请内存时，没有足够的内存空间供其使用；</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>内存泄露</b></span><span class="inline-wrap"> memory leak，是指程序在申请内存后，无法释放已申请的内存空间；</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>内存泄漏可以分为<span class="jill"></span>4<span class="jill"></span>类</b></span><span class="inline-wrap"> ：</span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。</span></li><li><div class="marker"></div><span class="inline-wrap">偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会执行。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。</span></li><li><div class="marker"></div><span class="inline-wrap">一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。</span></li><li><div class="marker"></div><span class="inline-wrap">隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。</span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Java<span class="jill"></span>中内存泄露的发生场景</b></span><span class="inline-wrap"> ：</span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">静态集合类引起内存泄露： 静态集合对象的生命周期和应用程序一致，他们所引用的所有的对象<span class="jill"></span>Object<span class="jill"></span>也不能被释放。</span></li><li><div class="marker"></div><span class="inline-wrap">对象属性被修改后，hash<span class="jill"></span>值发生了改变，导致<span class="jill"></span>remove<span class="jill"></span>方法失效。</span></li><li><div class="marker"></div><span class="inline-wrap">各种连接，例如数据库连接，网络连接和<span class="jill"></span>I/O<span class="jill"></span>连接，除非其显式的调用了其<span class="jill"></span>close<span class="jill"></span>方法将其连接关闭，否则是不会自动被<span class="jill"></span>GC 回收的。</span></li><li><div class="marker"></div><span class="inline-wrap">如果单例对象持有外部对象的引用，那么这个外部对象将不能被<span class="jill"></span>JVM<span class="jill"></span>正常回收，导致内存泄露。</span></li></ol><div class="wolai-bookmark wolai-block"><a href="https://www.zhihu.com/question/33194730/answer/2040441995?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=560497139592011776&amp;utm_content=group1_Answer&amp;utm_campaign=shareopn">JAVA发生OOM后还能运行么？ - 知乎</a><div class="info-box"><div class="text-pane"><div data-title="JAVA发生OOM后还能运行么？ - 知乎"></div><div data-desc="由于仅提到OOM，但 Java 的OOM又分很多类型的呀：堆溢出（“java.lang.OutOfMemoryError: Java heap spa…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.a53ae37b.png&quot;)"></div><div data-hostname="www.zhihu.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></article><footer></footer></body></html>
<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>对象内存布局 - wolai 笔记</title><link rel="shortcut icon"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="对象内存布局" class="main-title"></div></div></header><article><div class="wolai-block wolai-text"><div><span class="inline-wrap">本文将基于代码进行实例测试，详细探讨对象在内存中的组成结构。全文目录结构如下：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">1、对象内存结构概述</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">2、JOL 工具简介</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">3、对象头</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">4、实例数据</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">5、对齐填充字节</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">6、总结</span></li></ul><blockquote class="wolai-block"><span class="inline-wrap">文中代码基于 JDK 1.8.0_261，64-Bit HotSpot 运行</span></blockquote><h2 class="wolai-block"><span class="inline-wrap">对象的内存结构概述</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">当对象在实例化完成之后，是被存放在堆内存中的，这里的对象由<span class="jill"></span>3<span class="jill"></span>部分组成，如下图所示：</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">对各个组成部分的功能简要进行说明：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对象头：对象头存储的是对象在运行时状态的相关信息、指向该对象所属类的元数据的指针，如果对象是数组对象那么还会额外存储对象的数组长度  </span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">实例数据：实例数据存储的是对象的真正有效数据，也就是各个属性字段的值，如果在拥有父类的情况下，还会包含父类的字段。字段的存储顺序会受到数据类型长度、以及虚拟机的分配策略的影响  </span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对齐填充字节：在<span class="jill"></span>java<span class="jill"></span>对象中，需要对齐填充字节的原因是，Jvm<span class="jill"></span>中对象的大小被要求向<span class="jill"></span>8<span class="jill"></span>字节对齐，因此当对象的长度不足<span class="jill"></span>8<span class="jill"></span>字节的整数倍时，需要在对象中进行填充操作。注意图中对齐填充部分使用了虚线，这是因为填充字节并不是固定存在的部分，这点在后面计算对象大小时具体进行说明</span></li></ul><h2 class="wolai-block"><span class="inline-wrap">JOL</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">在具体开始研究对象的内存结构之前，先介绍一下我们要用到的工具，</span><span class="inline-wrap"><code>openjdk</code></span><span class="inline-wrap">官网提供了查看对象内存布局的工具</span><span class="inline-wrap"><code>jol (java object layout)</code></span><span class="inline-wrap">，可在</span><span class="inline-wrap"><code>maven</code></span><span class="inline-wrap">中引入坐标：</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="XML" class="marker"></div><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.openjdk.jol<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jol-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.14<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">在代码中使用</span><span class="inline-wrap"><code>jol</code></span><span class="inline-wrap">提供的方法查看<span class="jill"></span>jvm<span class="jill"></span>信息：</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>VM<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">details</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></div></code-block><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="纯文本" class="marker"></div><pre># <span class="token maybe-class-name">Running</span> <span class="token number">64</span><span class="token operator">-</span>bit <span class="token maybe-class-name">HotSpot</span> <span class="token constant">VM</span><span class="token punctuation">.</span>
# <span class="token maybe-class-name">Using</span> compressed oop <span class="token keyword">with</span> <span class="token number">3</span><span class="token operator">-</span>bit shift<span class="token punctuation">.</span>
# <span class="token maybe-class-name">Using</span> compressed klass <span class="token keyword">with</span> <span class="token number">0x0000000800000000</span> base address and <span class="token number">3</span><span class="token operator">-</span>bit shift<span class="token punctuation">.</span>
# <span class="token maybe-class-name">Objects</span> are <span class="token number">8</span> bytes aligned<span class="token punctuation">.</span>
# <span class="token maybe-class-name">Field</span> sizes by type<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span> <span class="token punctuation">[</span>bytes<span class="token punctuation">]</span>
# <span class="token known-class-name class-name">Array</span> element sizes<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span> <span class="token punctuation">[</span>bytes<span class="token punctuation">]</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">通过打印出来的信息，可以看到我们使用的是<span class="jill"></span>64<span class="jill"></span>位 JVM，并开启了指针压缩，对象默认使用<span class="jill"></span>8<span class="jill"></span>字节对齐方式。通过</span><span class="inline-wrap"><code>jol</code></span><span class="inline-wrap">查看对象内存布局的方法，将在后面的例子中具体展示，下面开始对象内存布局的正式学习。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">对象头</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">在对象头中</span><span class="inline-wrap"><code>mark word</code></span><span class="inline-wrap"> 占<span class="jill"></span>8<span class="jill"></span>字节，默认开启指针压缩的情况下</span><span class="inline-wrap"><code>Klass pointer</code></span><span class="inline-wrap"> 占<span class="jill"></span>4<span class="jill"></span>字节，数组对象的数组长度占<span class="jill"></span>4<span class="jill"></span>字节。在了解了对象头的基础结构后，现在以一个不包含任何属性的空对象为例，查看一下它的内存布局，创建</span><span class="inline-wrap"><code>User</code></span><span class="inline-wrap">类：</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用</span><span class="inline-wrap"><code>jol</code></span><span class="inline-wrap">查看对象头的内存布局：</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">User</span> user<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//查看对象的内存布局</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">执行代码，查看打印信息：</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image.png" style="width: 760px"/></figure></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>OFFSET</code></span><span class="inline-wrap">：偏移地址，单位为字节</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SIZE</code></span><span class="inline-wrap">：占用内存大小，单位为字节</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>TYPE</code></span><span class="inline-wrap">：</span><span class="inline-wrap"><code>Class</code></span><span class="inline-wrap">中定义的类型</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>DESCRIPTION</code></span><span class="inline-wrap">：类型描述，</span><span class="inline-wrap"><code>Obejct header</code></span><span class="inline-wrap"> 表示对象头，</span><span class="inline-wrap"><code>alignment</code></span><span class="inline-wrap">表示对齐填充</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>VALUE</code></span><span class="inline-wrap">：对应内存中存储的值</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">当前对象共占用<span class="jill"></span>16<span class="jill"></span>字节，因为<span class="jill"></span>8<span class="jill"></span>字节标记字加<span class="jill"></span>4<span class="jill"></span>字节的类型指针，不满足向<span class="jill"></span>8<span class="jill"></span>字节对齐，因此需要填充<span class="jill"></span>4<span class="jill"></span>个字节：</span><span class="inline-wrap"><code>8B (mark word) + 4B (klass pointer) + 0B (instance data) + 4B (padding)</code></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">这样我们就通过直观的方式，了解了一个不包含属性的最简单的空对象，在内存中的基本组成是怎样的。在此基础上，我们来深入学习对象头中各个组成部分。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">Mark Word 标记字</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">在对象头中，</span><span class="inline-wrap"><code>mark word</code></span><span class="inline-wrap"> 一共有<span class="jill"></span>64<span class="jill"></span>个<span class="jill"></span>bit，用于存储对象自身的运行时数据，标记对象处于以下<span class="jill"></span>5<span class="jill"></span>种状态中的某一种：</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_1.png" style="width: 760px"/></figure></div><aside class="bg-cultured wolai-block"><div data-symbol="📌" class="icon"></div><span class="inline-wrap">你可能会发现这图跟上面的截图有点出入，因为截图的程序是运行在<span class="jill"></span>x86<span class="jill"></span>系统下的，x86<span class="jill"></span>使用的小端，而<span class="jill"></span>Java<span class="jill"></span>规范里面用的都是大端</span></aside><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>hashcode</code></span><span class="inline-wrap">：无锁态下的</span><span class="inline-wrap"><code>hashcode</code></span><span class="inline-wrap">采用了延迟加载技术，在第一次调用</span><span class="inline-wrap"><code>hashCode()</code></span><span class="inline-wrap">方法时才会计算写入。对这一过程进行验证：</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">User</span> user<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//打印内存布局</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//计算hashCode</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//再次打印内存布局</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_2.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以看到，在没有调用</span><span class="inline-wrap"><code>hashCode()</code></span><span class="inline-wrap">方法前，31<span class="jill"></span>位的哈希值不存在，全部填充为<span class="jill"></span>0。在调用方法后，根据大小端，被填充的数据为：</span><span class="inline-wrap"><code>01101111_01110101_11100111_00100001</code></span></div></div><aside class="bg-cultured wolai-block"><div data-symbol="🚀" class="icon"></div><span class="inline-wrap">只有调用</span><span class="inline-wrap"><code>Object.hashCode()</code></span><span class="inline-wrap">方法或</span><span class="inline-wrap"><code>System.identityHashCode(Object)</code></span><span class="inline-wrap">方法生成的</span><span class="inline-wrap"><code>hashcode</code></span><span class="inline-wrap">才会写入到</span><span class="inline-wrap"><code>mark word</code></span><span class="inline-wrap">。</span></aside><div class="wolai-block wolai-text"><div><span class="inline-wrap">大家可能会注意到，当对象被加锁后，</span><span class="inline-wrap"><code>mark word</code></span><span class="inline-wrap">中就没有足够空间来保存</span><span class="inline-wrap"><code>hashCode</code></span><span class="inline-wrap">了，这时</span><span class="inline-wrap"><code>hashcode</code></span><span class="inline-wrap">会被移动到重量级锁的</span><span class="inline-wrap"><code>Object Monitor</code></span><span class="inline-wrap">中。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>epoch</code></span><span class="inline-wrap">：偏向锁的时间戳  </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>age</code></span><span class="inline-wrap">(分代年龄)：在</span><span class="inline-wrap"><code>jvm</code></span><span class="inline-wrap">的垃圾回收过程中，每当对象经过一次</span><span class="inline-wrap"><code>Young GC</code></span><span class="inline-wrap">，年龄都会加<span class="jill"></span>1，这里<span class="jill"></span>4<span class="jill"></span>位来表示分代年龄最大值为<span class="jill"></span>15，这也就是为什么对象的年龄超过<span class="jill"></span>15<span class="jill"></span>后会被移到老年代的原因。在启动时可以通过添加参数来改变年龄阈值：</span><span class="inline-wrap"><code>-XX:MaxTenuringThreshold=16</code></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">当设置的阈值超过<span class="jill"></span>15<span class="jill"></span>时，启动时会报错：</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_3.png" style="width: 756px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><aside class="bg-cultured wolai-block"><div data-symbol="💣" class="icon"></div><span class="inline-wrap">关于锁相关信息的解读，请看</span><span class="inline-wrap"><a href="https://www.wolai.com/a44tNhdvBivrPjXMomeARf#a44tNhdvBivrPjXMomeARf" class="wolai-bi-link"><span class="embed-page">内部锁(待完善)</span></a></span></aside><h3 class="wolai-block"><span class="inline-wrap">Klass Pointer 类型指针</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>Klass Pointer</code></span><span class="inline-wrap">是一个指向方法区中</span><span class="inline-wrap"><code>Class</code></span><span class="inline-wrap">信息的指针，虚拟机通过这个指针确定该对象属于哪个类的实例。在<span class="jill"></span>64<span class="jill"></span>位的<span class="jill"></span>JVM<span class="jill"></span>中，支持指针压缩功能，根据是否开启指针压缩，</span><span class="inline-wrap"><code>Klass Pointer</code></span><span class="inline-wrap">占用的大小将会不同：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">未开启指针压缩时，类型指针占用<span class="jill"></span>8B (64bit)</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">开启指针压缩且堆内存小于</span><span class="inline-wrap"><code>32G</code></span><span class="inline-wrap">情况下，类型指针占用<span class="jill"></span>4B (32bit)</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">在</span><span class="inline-wrap"><code>jdk6</code></span><span class="inline-wrap">之后的版本中，指针压缩是被默认开启的，可通过启动参数开启或关闭该功能：</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre>#开启指针压缩：
<span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UseCompressedOops</span>
#关闭指针压缩：
<span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">-</span><span class="token class-name">UseCompressedOops</span></pre></div></code-block><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_4.png" style="width: 619px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">对象大小虽然还是<span class="jill"></span>16<span class="jill"></span>字节，但是组成发生了改变，8<span class="jill"></span>字节标记字加<span class="jill"></span>8<span class="jill"></span>字节类型指针，已经能满足对齐条件，因此不需要填充。</span></div></div><aside class="bg-cultured wolai-block"><div data-symbol="🔥" class="icon"></div><span class="inline-wrap">8B (mark word) + 8B (klass pointer) + 0B (instance data) + 0B (padding)</span></aside><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>指针压缩原理</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在了解了指针压缩的作用后，我们来看一下指针压缩是如何实现的。首先在不开启指针压缩的情况下，一个对象的内存地址使用<span class="jill"></span>64<span class="jill"></span>位表示，这时能描述的内存地址范围是：</span></div><aside class="bg-cultured wolai-block"><div data-symbol="🔥" class="icon"></div><span class="inline-wrap">0 ~ 2^64-1</span></aside></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在开启指针压缩后，使用<span class="jill"></span>4<span class="jill"></span>个字节也就是<span class="jill"></span>32<span class="jill"></span>位，可以表示</span><span class="inline-wrap"><code>2^32</code></span><span class="inline-wrap"> 个内存地址，如果这个地址是真实地址的话，由于<span class="jill"></span>CPU<span class="jill"></span>寻址的最小单位是</span><span class="inline-wrap"><code>Byte</code></span><span class="inline-wrap">，那么就是<span class="jill"></span>4GB<span class="jill"></span>内存。这对于我们来说是远远不够的，但是之前我们说过，java<span class="jill"></span>中对象默认使用了<span class="jill"></span>8<span class="jill"></span>字节对齐，也就是说<span class="jill"></span>1<span class="jill"></span>个对象占用的空间必须是<span class="jill"></span>8<span class="jill"></span>字节的整数倍，这样就创造了一个条件，使<span class="jill"></span>jvm<span class="jill"></span>在定位一个对象时不需要使用真正的内存地址，而是定位到由<span class="jill"></span>java<span class="jill"></span>进行了<span class="jill"></span>8<span class="jill"></span>字节映射后的地址（可以说是一个映射地址的编号）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">完成压缩后，现在指针的<span class="jill"></span>32<span class="jill"></span>位中的每一个</span><span class="inline-wrap"><code>bit</code></span><span class="inline-wrap">，都可以代表<span class="jill"></span>8<span class="jill"></span>个字节，这样就相当于使原有的内存地址得到了<span class="jill"></span>8<span class="jill"></span>倍的扩容。所以在<span class="jill"></span>8<span class="jill"></span>字节对齐的情况下，32<span class="jill"></span>位最大能表示</span><span class="inline-wrap"><code>2^32*8=32GB</code></span><span class="inline-wrap">内存，内存地址范围是：</span></div><aside class="bg-cultured wolai-block"><div data-symbol="🔥" class="icon"></div><span class="inline-wrap">0 ~ (2^32-1)*8</span></aside></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">由于能够表示的最大内存是<span class="jill"></span>32GB，所以如果配置的最大的堆内存大于这个数值时，那么指针压缩将会失效。配置<span class="jill"></span>jvm<span class="jill"></span>启动参数：</span><span class="inline-wrap"><code>-Xmx32g</code></span></div></div><aside class="bg-cultured wolai-block"><div data-symbol="🔥" class="icon"></div><span class="inline-wrap">32G<span class="jill"></span>是个理论值，实际跟<span class="jill"></span>JVM<span class="jill"></span>和平台有关，如何直接设置 -Xmx=32GB<span class="jill"></span>极可能致使 CompressedOop 失效，可以通过<span class="jill"></span>JVM<span class="jill"></span>参数 -XX:+PrintFlagsFinal，验证<span class="jill"></span>UseCompressedOops<span class="jill"></span>的值，从而得知，是否真的开启了压缩指针</span></aside><div class="wolai-block wolai-text"><div><span class="inline-wrap">查看对象内存布局：</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_5.png" style="width: 619px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">此时，指针压缩失效，指针长度恢复到<span class="jill"></span>8<span class="jill"></span>字节。那么如果业务场景内存超过<span class="jill"></span>32GB<span class="jill"></span>怎么办呢，可以通过修改默认对齐长度进行再次扩展，我们将对齐长度修改为<span class="jill"></span>16<span class="jill"></span>字节：</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="纯文本" class="marker"></div><pre><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token maybe-class-name">ObjectAlignmentInBytes</span><span class="token operator">=</span><span class="token number">16</span> <span class="token operator">-</span><span class="token maybe-class-name">Xmx32g</span>
</pre></div></code-block><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_6.png" style="width: 619px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以看到指针压缩后占<span class="jill"></span>4<span class="jill"></span>字节，同时对象向<span class="jill"></span>16<span class="jill"></span>字节进行了填充对齐，按照上面的计算，这时配置最大堆内存为<span class="jill"></span>64GB<span class="jill"></span>时指针压缩才会失效。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">对指针压缩做一下简单总结：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">通过指针压缩，利用对齐填充的特性，通过映射方式达到了内存地址扩展的效果</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">指针压缩能够节省内存空间，同时提高了程序的寻址效率</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">堆内存设置时最好不要大于<span class="jill"></span>32GB，这时指针压缩将会失效，造成空间的浪费</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">此外，指针压缩不仅可以作用于对象头的类型指针，还可以作用于引用类型的字段指针，以及引用类型数组指针</span></li></ul><h3 class="wolai-block"><span class="inline-wrap">数组长度</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果当对象是一个数组对象时，那么在对象头中有一个保存数组长度的空间，占用<span class="jill"></span>4<span class="jill"></span>字节（32bit）空间。通过下面代码进行测试：</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">User</span><span class="token punctuation">[</span><span class="token punctuation">]</span> users <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">运行代码，结果如下：</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_7.png" style="width: 619px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">内存结构从上到下分别为：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">8<span class="jill"></span>字节</span><span class="inline-wrap"><code>mark word</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">4<span class="jill"></span>字节</span><span class="inline-wrap"><code>klass pointer</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">4<span class="jill"></span>字节数组长度，值为<span class="jill"></span>2，表示数组中有两个元素</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">8<span class="jill"></span>字节数组元素指针，数组中有两个元素，也就有两个指针</span></li></ul><h2 class="wolai-block"><span class="inline-wrap">实例数据</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">实例数据（</span><span class="inline-wrap"><code>Instance Data</code></span><span class="inline-wrap">）保存的是对象真正存储的有效信息，保存了代码中定义的各种数据类型的字段内容，并且如果有继承关系存在，子类还会包含从父类继承过来的字段。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">基本数据类型：</span></li></ul><div class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 257px"><span class="inline-wrap">Type</span></th><th style="width: 288px"><span class="inline-wrap">Bytes</span></th></tr></thead><tbody><tr><td><span class="inline-wrap">byte，boolean</span></td><td><span class="inline-wrap">1</span></td></tr><tr><td><span class="inline-wrap">char，short</span></td><td><span class="inline-wrap">2</span></td></tr><tr><td><span class="inline-wrap">int，float</span></td><td><span class="inline-wrap">4</span></td></tr><tr><td><span class="inline-wrap">long，double</span></td><td><span class="inline-wrap">8</span></td></tr></tbody></table></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">引用数据类型：</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">开启指针压缩情况下占<span class="jill"></span>8<span class="jill"></span>字节，开启指针压缩后占<span class="jill"></span>4<span class="jill"></span>字节。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">字段重排序</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">给<span class="jill"></span>User<span class="jill"></span>类添加基本数据类型的属性字段：</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>weight<span class="token punctuation">;</span>
    <span class="token keyword">byte</span> sex<span class="token punctuation">;</span>
    <span class="token keyword">long</span> phone<span class="token punctuation">;</span>
    <span class="token keyword">char</span> local<span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">查看内存布局：</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_8.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以看到，在内存中，属性的排列顺序与在类中定义的顺序不同，这是因为<span class="jill"></span>jvm<span class="jill"></span>会采用</span><span class="inline-wrap"><b>字段重排序</b></span><span class="inline-wrap">技术，对原始类型进行重新排序，以达到内存对齐的目的。具体规则遵循如下：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">按照数据类型的长度大小，从大到小排列</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">具有相同长度的字段，会被分配在相邻位置</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果一个字段的长度是<span class="jill"></span>L<span class="jill"></span>个字节，那么这个字段的偏移量（</span><span class="inline-wrap"><code>OFFSET</code></span><span class="inline-wrap">）需要对齐至</span><span class="inline-wrap"><code>nL</code></span><span class="inline-wrap">（n<span class="jill"></span>为整数）</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">上面的前两条规则相对容易理解，这里通过举例对第<span class="jill"></span>3<span class="jill"></span>条进行解释：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">因为</span><span class="inline-wrap"><code>long</code></span><span class="inline-wrap">类型占<span class="jill"></span>8<span class="jill"></span>字节，所以它的偏移量必定是<span class="jill"></span>8n，再加上前面对象头占<span class="jill"></span>12<span class="jill"></span>字节，所以</span><span class="inline-wrap"><code>long</code></span><span class="inline-wrap">类型变量的最小偏移量是<span class="jill"></span>16。通过打印对象内存布局可以发现，当对象头不是<span class="jill"></span>8<span class="jill"></span>字节的整数倍时（只存在</span><span class="inline-wrap"><code>8n+4</code></span><span class="inline-wrap">字节情况），会按从大到小的顺序，使用<span class="jill"></span>4、2、1<span class="jill"></span>字节长度的属性进行补位。为了和对齐填充进行区分，可以称其为前置补位，如果在补位后仍然不满足<span class="jill"></span>8<span class="jill"></span>字节整数倍，会进行对齐填充。在存在前置补位的情况下，字段的排序会打破上面的第一、第二条规则。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">因此在上面的内存布局中，先使用<span class="jill"></span>4<span class="jill"></span>字节的</span><span class="inline-wrap"><code>int</code></span><span class="inline-wrap">进行前置补位，再按第一条规则从大到小顺序进行排列。如果我们删除<span class="jill"></span>3<span class="jill"></span>个</span><span class="inline-wrap"><code>int</code></span><span class="inline-wrap">类型的字段，再查看内存布局：</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_9.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>char</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>byte</code></span><span class="inline-wrap">类型的变量被提到前面进行前置补位，并在</span><span class="inline-wrap"><code>long</code></span><span class="inline-wrap">类型前进行了<span class="jill"></span>1<span class="jill"></span>字节的对齐填充。</span></div></div><h3 class="wolai-block"><span class="inline-wrap"><b>拥有父类情况</b></span></h3><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">当一个类拥有父类时，整体遵循在父类中定义的变量出现在子类中定义的变量之前的原则</span></li></ul><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i1<span class="token punctuation">,</span>i2<span class="token punctuation">;</span>
    <span class="token keyword">long</span> l1<span class="token punctuation">,</span>l2<span class="token punctuation">;</span>
    <span class="token keyword">char</span> c1<span class="token punctuation">,</span>c2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> b1<span class="token punctuation">;</span>
    <span class="token keyword">double</span> d1<span class="token punctuation">,</span>d2<span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">查看内存布局：</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_10.png" style="width: 760px"/></figure></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果父类需要后置补位的情况，可能会将子类中类型长度较短的变量提前，但是整体还是遵循子类在父类之后的原则</span></li></ul><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i1<span class="token punctuation">,</span>i2<span class="token punctuation">;</span>
    <span class="token keyword">long</span> l1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i1<span class="token punctuation">,</span>i2<span class="token punctuation">;</span>
    <span class="token keyword">long</span> l1<span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">查看内存布局：</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_11.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以看到，子类中较短长度的变量被提前到父类后进行了后置补位。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">父类的前置对齐填充会被子类继承</span></li></ul><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> l<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
    <span class="token keyword">long</span> l2<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i1<span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">查看内存布局：</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_12.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">当<span class="jill"></span>B<span class="jill"></span>类没有继承<span class="jill"></span>A<span class="jill"></span>类时，正好满足<span class="jill"></span>8<span class="jill"></span>字节对齐，不需要进行对齐填充。当<span class="jill"></span>B<span class="jill"></span>类继承<span class="jill"></span>A<span class="jill"></span>类后，会继承<span class="jill"></span>A<span class="jill"></span>类的前置补位填充，因此在<span class="jill"></span>B<span class="jill"></span>类的末尾也需要对齐填充。</span></div></div><h3 class="wolai-block"><span class="inline-wrap"><b>引用数据类型</b></span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">在上面的例子中，仅探讨了基本数据类型的排序情况，那么如果存在引用数据类型时，排序情况是怎样的呢？在</span><span class="inline-wrap"><code>User</code></span><span class="inline-wrap">类中添加引用类型：</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
     <span class="token keyword">int</span> id<span class="token punctuation">;</span>
     <span class="token class-name">String</span> firstName<span class="token punctuation">;</span>
     <span class="token class-name">String</span> lastName<span class="token punctuation">;</span>
     <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">查看内存布局：</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_13.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以看到默认情况下，基本数据类型的变量排在引用数据类型前。这个顺序可以在</span><span class="inline-wrap"><code>jvm</code></span><span class="inline-wrap">启动参数中进行修改：</span><span class="inline-wrap"><code>-XX:FieldsAllocationStyle=0</code></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">重新运行，可以看到引用数据类型的排列顺序被放在了前面：</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_14.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">对</span><span class="inline-wrap"><code>FieldsAllocationStyle</code></span><span class="inline-wrap">的不同取值简要说明：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">0：先放入普通对象的引用指针，再放入基本数据类型变量  </span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">1：默认情况，表示先放入基本数据类型变量，再放入普通对象的引用指针</span></li></ul><h3 class="wolai-block"><span class="inline-wrap"><b>静态变量</b></span></h3><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
     <span class="token keyword">int</span> id<span class="token punctuation">;</span>
     <span class="token keyword">static</span> <span class="token keyword">byte</span> local<span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">查看内存布局：</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/image_15.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">通过结果可以看到，静态变量并不在对象的内存布局中，它的大小是不计算在对象中的，因为静态变量属于类而不是属于某一个对象的。</span></div></div><h3 class="wolai-block"><span class="inline-wrap"><b>对齐填充字节</b></span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">在</span><span class="inline-wrap"><code>Hotspot</code></span><span class="inline-wrap">的自动内存管理系统中，要求对象的起始地址必须是<span class="jill"></span>8<span class="jill"></span>字节的整数倍，也就是说对象的大小必须满足<span class="jill"></span>8<span class="jill"></span>字节的整数倍。因此如果实例数据没有对齐，那么需要进行对齐补全空缺，补全的</span><span class="inline-wrap"><code>bit</code></span><span class="inline-wrap">位仅起占位符作用，不具有特殊含义。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在前面的例子中，我们已经对对齐填充有了充分的认识，下面再做一些补充：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在开启指针压缩的情况下，如果类中有</span><span class="inline-wrap"><code>long/double</code></span><span class="inline-wrap">类型的变量时，会在对象头和实例数据间形成间隙（</span><span class="inline-wrap"><code>gap</code></span><span class="inline-wrap">），为了节省空间，会默认把较短长度的变量放在前边，这一功能可以通过<span class="jill"></span>jvm<span class="jill"></span>参数进行开启或关闭：</span></li></ul><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre># 开启
<span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">CompactFields</span>
# 关闭
<span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">-</span><span class="token class-name">CompactFields</span></pre></div></code-block><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在前面指针压缩中，我们提到了可以改变对齐宽度，这也是通过修改下面的<span class="jill"></span>jvm<span class="jill"></span>参数配置实现的：</span><span class="inline-wrap"><code>-XX:ObjectAlignmentInBytes</code></span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">默认情况下对齐宽度为<span class="jill"></span>8，这个值可以修改为<span class="jill"></span>2~256<span class="jill"></span>以内<span class="jill"></span>2<span class="jill"></span>的整数幂，一般情况下都以<span class="jill"></span>8<span class="jill"></span>字节对齐或<span class="jill"></span>16<span class="jill"></span>字节对齐。当然普通情况下不建议修改对齐长度参数，如果对齐宽度过长，可能会导致内存空间的浪费。</span></div></div><h2 class="wolai-block"><span class="inline-wrap"><b>总结</b></span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">本文通过使用</span><span class="inline-wrap"><code>jol</code></span><span class="inline-wrap"> 对<span class="jill"></span>java<span class="jill"></span>对象进行测试，学习了对象内存布局的基本知识。通过学习，能够帮助我们：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">掌握对象内存布局，基于此基础进行<span class="jill"></span>jvm<span class="jill"></span>参数调优</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">通过计算对象大小，可以在评估业务量的基础上在项目上线前预估需要使用多少内存，防止服务器频繁<span class="jill"></span>gc</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">参考文献</span></h2><div class="wolai-bookmark wolai-block"><a href="https://zhuanlan.zhihu.com/p/362023210">图文详解Java对象内存布局</a><div class="info-box"><div class="text-pane"><div data-title="图文详解Java对象内存布局"></div><div data-desc="作为一名Java程序员，我们在日常工作中使用这款面向对象的编程语言时，做的最频繁的操作大概就是去创建一个个的对象了。对象的创建方式虽然有很多，可以通过 new、反射、clone、反序列化等不同方式来创建，但最终…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.a53ae37b.png&quot;)"></div><div data-hostname="zhuanlan.zhihu.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://zhuanlan.zhihu.com/p/67609763">一个Java对象到底有多大？</a><div class="info-box"><div class="text-pane"><div data-title="一个Java对象到底有多大？"></div><div data-desc="编写Java代码的时候，大多数情况下，我们很少关注一个Java对象究竟有多大(占据多少内存)，更多的是关注业务与逻辑。但是殊不知，在我们不经意间，大量的内存被无形地浪费了。一个Java对象到底有多大？想要精确计算…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.a53ae37b.png&quot;)"></div><div data-hostname="zhuanlan.zhihu.com"></div></div></div><div class="preview-pane" style="background-image: url(https://pic1.zhimg.com/v2-136651d226afbd32e0256bf35a874e3e_720w.jpg?source=172ae18b)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://dzone.com/articles/java-object-size-estimation-measuring-verifying">Java Object Size: Estimating, Measuring, and Verifying via Profiling - DZone Java</a><div class="info-box"><div class="text-pane"><div data-title="Java Object Size: Estimating, Measuring, and Verifying via Profiling - DZone Java"></div><div data-desc="Estimating Java Object Size. How to Measure Objects and Primitives in Java. Verifying Calculated Size by Profiling JVM How to calculate Java Objects, Arrays ..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://dz2cdn3.dzone.com/themes/dz20/images/favicon.png&quot;)"></div><div data-hostname="dzone.com"></div></div></div><div class="preview-pane" style="background-image: url(https://dz2cdn3.dzone.com/storage/article-thumb/14903190-thumb.jpg)"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://www.baeldung.com/jvm-measuring-object-sizes">https://www.baeldung.com/jvm-measuring-object-sizes</a><div class="info-box"><div class="text-pane"><div data-title="www.baeldung.com"></div><div class="icon-host"><div data-hostname="www.baeldung.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://www.cnblogs.com/rickiyang/p/11368932.html">javaagent使用指南 - rickiyang - 博客园</a><div class="info-box"><div class="text-pane"><div data-title="javaagent使用指南 - rickiyang - 博客园"></div><div data-desc="今天打算写一下 Javaagent，一开始我对它的概念也比较陌生，后来在别人口中听到 ，`bTrace Arthas`后面才逐渐了解到Java还提供了这么个工具。 JVM启动前静态Instrument"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://common.cnblogs.com/favicon.svg&quot;)"></div><div data-hostname="www.cnblogs.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-bookmark wolai-block"><a href="https://openjdk.java.net/groups/hotspot/docs/Serviceability.html">Serviceability in HotSpot</a><div class="info-box"><div class="text-pane"><div data-title="Serviceability in HotSpot"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://openjdk.java.net/images/nanoduke.ico&quot;)"></div><div data-hostname="openjdk.java.net"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>
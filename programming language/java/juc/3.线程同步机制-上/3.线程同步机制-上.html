<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>3.线程同步机制-上 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="3.线程同步机制-上" class="main-title"></div></div></header><article><div class="wolai-block wolai-text"><div><span class="inline-wrap">多个线程同时对同一共享资源进行操作时，操作的结果是不确定的，这就是线程安全问题，线程安全问题的产生原因是线程之间缺乏同步机制。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>什么是线程同步机制</b></span></div></div><div class="wolai-block wolai-text"><div><span class="red inline-wrap">线程同步机制是一套用于协调线程间访问和操作共享数据的机制。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>平台提供的线程同步机制包括，锁、volatile<span class="jill"></span>关键字、final<span class="jill"></span>关键字以及一些相关的<span class="jill"></span>API，例如</span><span class="inline-wrap"><code>Object.wait()和<span class="jill"></span>Object.notify()</code></span><span class="inline-wrap">等等。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">锁</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>锁的思想</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">线程安全问题产生的前提是多个线程同时对某个资源进行操作，导致操作的结果不可控，那么我们限定某一时刻只有一个线程能对该资源进行操作，那么也就不会有线程安全问题了，这也就是锁的思路。线程对资源进行操作时，需要先获得锁，操作完毕后，释放锁。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Java<span class="jill"></span>中锁的分类</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">按照<span class="jill"></span>Java<span class="jill"></span>虚拟机对锁的实现方式划分，Java<span class="jill"></span>平台中的锁分为内部锁和显式锁.</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">内部锁通过</span><span class="inline-wrap"><code>synchronize</code></span><span class="inline-wrap">关键字实现</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">显式锁通过</span><span class="inline-wrap"><code>java.concurrent.locks.Lock</code></span><span class="inline-wrap">接口的实现类实现.</span></li></ul><h2 class="wolai-block"><span class="inline-wrap">内部锁</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Java<span class="jill"></span>中，使用锁的其中一种方式就是使用</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">关键字。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">关键字即可用于方法(无论是实例还是静态方法)，也可用于代码块。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token comment">// synchronized修饰的代码块称为同步代码块</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在Java中，所有对象都具有一个内部锁（）</span>
    <span class="token comment">// mutex，作为内部锁的句柄，是一个对象或者能够返回对象的表达式   </span>
    <span class="token comment">// 多个同步代码块使用同一个对象的内部锁，则同一时刻只有一条线程拥有锁</span>
    <span class="token comment">// 对于锁对象，应该声明为final</span>
    <span class="token comment">// 因为如果一旦锁对象发生了变化，那么很可能使用的将不是同一个锁对象</span>
    <span class="token comment">// 也就失去了同步的意义了，更甚一步，通常声明为private final</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 同步实例方法可以理解为使用该实例作为锁句柄</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 同步静态方法可以理解为使用当前类对象作为锁句柄</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token class-name">Collection</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">线程在执行临界区代码之前需要获取内部锁，获取成功后才能执行临界区中的代码，代码执行后释放内部锁，线程对内部锁的申请和释放都是由<span class="jill"></span>Java<span class="jill"></span>虚拟机实施。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>虚拟机会为每个内部锁分配一个入口集（Entry Set），用于记录等待获取内部锁的线程，入口集中的线程处于阻塞状态。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">显式锁</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">我们知道，synchronized 是<span class="jill"></span>Java<span class="jill"></span>的关键字，是<span class="jill"></span>Java<span class="jill"></span>的内置特性，在<span class="jill"></span>JVM<span class="jill"></span>层面实现了对临界资源的同步互斥访问，但 synchronized 在处理实际问题时存在诸多局限性，比如无法响应中断等。自<span class="jill"></span>JDK1.5<span class="jill"></span>开始引入了显式锁，作为一种线程同步机制，其作用与内部锁相同。它提供了一些内部锁不具备的特性，但并不是内部锁的替代品。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Lock</span> <span class="token punctuation">{</span>
    <span class="token comment">// 用来获取锁。如果锁已被其他线程获取，则一直等待。</span>
    <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 尝试获取锁，如果成功，则返回true，否则返回false</span>
    <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取锁，unless the current thread is interrupted.</span>
    <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
    <span class="token comment">// 释放锁</span>
    <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><h3 class="wolai-block"><span class="inline-wrap">ReentrantLock</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>ReentrantLock</code></span><span class="inline-wrap">是目前<span class="jill"></span>JUC<span class="jill"></span>中唯一实现了<span class="jill"></span>Lock<span class="jill"></span>接口的类，并且</span><span class="inline-wrap"><code>ReentrantLock</code></span><span class="inline-wrap">提供了更多的方法。下面通过一些实例看具体看一下如何使用</span><span class="inline-wrap"><code>ReentrantLock</code></span><span class="inline-wrap">。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">Lock<span class="jill"></span>和<span class="jill"></span>synchronized<span class="jill"></span>的选择</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">总结来说，Lock<span class="jill"></span>和<span class="jill"></span>synchronized<span class="jill"></span>有以下几点不同：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">　　1）Lock<span class="jill"></span>是一个接口，而<span class="jill"></span>synchronized<span class="jill"></span>是<span class="jill"></span>Java<span class="jill"></span>中的关键字，synchronized<span class="jill"></span>是内置的语言实现；</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">　　2）synchronized<span class="jill"></span>在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而<span class="jill"></span>Lock<span class="jill"></span>在发生异常时，如果没有主动通过</span><span class="inline-wrap"><code>unLock()</code></span><span class="inline-wrap">去释放锁，则很可能造成死锁现象，因此使用<span class="jill"></span>Lock<span class="jill"></span>时需要在<span class="jill"></span>finally<span class="jill"></span>块中释放锁；</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">　　3）Lock<span class="jill"></span>可以让等待锁的线程响应中断，而<span class="jill"></span>synchronized<span class="jill"></span>却不行，使用<span class="jill"></span>synchronized<span class="jill"></span>时，等待的线程会一直等待下去，不能够响应中断；</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">　　4）通过<span class="jill"></span>Lock<span class="jill"></span>可以知道有没有成功获取锁，而<span class="jill"></span>synchronized<span class="jill"></span>却无法办到。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">　　5）Lock<span class="jill"></span>可以提高多个线程进行读操作的效率。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">​	   6）Lock<span class="jill"></span>可以在另一个方法里释放锁</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">JDK1.5<span class="jill"></span>中，synchronized<span class="jill"></span>是性能低效，到了<span class="jill"></span>JDK1.6，发生了变化，对<span class="jill"></span>synchronize<span class="jill"></span>加入了很多优化措施，有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在<span class="jill"></span>JDK1.6<span class="jill"></span>上<span class="jill"></span>synchronize<span class="jill"></span>的性能并不比<span class="jill"></span>Lock<span class="jill"></span>差。官方也表示，他们也更支持<span class="jill"></span>synchronize，在未来的版本中还有优化余地，所以还是提倡在<span class="jill"></span>synchronized<span class="jill"></span>能实现需求的情况下，优先考虑使用<span class="jill"></span>synchronized<span class="jill"></span>来进行同步。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">轻量级同步机制：volatile</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用</span><span class="inline-wrap"><code>volatile</code></span><span class="inline-wrap">关键字修饰的变量，对它的读操作都是从主内存中读取，写操作的结果会立即写回主内存。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">自从<span class="jill"></span>JDK5<span class="jill"></span>以来，</span><span class="inline-wrap"><code>volatile</code></span><span class="inline-wrap">关键字不仅解决可见性问题，还提供了别的特性，在讲解这些特性之前，我们先来看一下<span class="jill"></span>happens-before</span></div></div><h3 class="wolai-block"><span class="inline-wrap">happens-before</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">JVM<span class="jill"></span>规范中定义了一些动作，这些动作包括变量的读/写、锁的申请与释放，以及线程的<span class="jill"></span>start<span class="jill"></span>和<span class="jill"></span>join<span class="jill"></span>等等。假设动作<span class="jill"></span>A<span class="jill"></span>和动作<span class="jill"></span>B<span class="jill"></span>之间存在<span class="jill"></span>happens-before<span class="jill"></span>关系，称之为 A happens-before B。那么<span class="jill"></span>JVM<span class="jill"></span>保证<span class="jill"></span>A<span class="jill"></span>的操作结果对<span class="jill"></span>B<span class="jill"></span>可见。happens-before<span class="jill"></span>关系具有传递性，如果<span class="jill"></span>A happens-before B，B happens-before C 则<span class="jill"></span>A HB C。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">JVM<span class="jill"></span>定义了一些关于<span class="jill"></span>happens-before<span class="jill"></span>关系的规则，这些规则规定了两个动作，在身情况下具有<span class="jill"></span>happens-before<span class="jill"></span>关系。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">程序顺序规则：一个线程中的每一个动作都<span class="jill"></span>happens-before<span class="jill"></span>该线程中程序顺序上排在该动作之后的每一个动作</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">内部锁规则：内部锁的释放 happens-before<span class="jill"></span>后续每一个对该锁的申请</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">线程启动规则：调用一个线程的<span class="jill"></span>start<span class="jill"></span>方法<span class="jill"></span>happens-before<span class="jill"></span>被启动的这个线程中的任何一个动作</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">线程终止规则：被调用<span class="jill"></span>join<span class="jill"></span>方法的线程，它的任何一个动作都<span class="jill"></span>happens-before<span class="jill"></span>调用改方法的线程，在<span class="jill"></span>join<span class="jill"></span>方法后面的动作</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">volatile<span class="jill"></span>变量规则：对一个<span class="jill"></span>volatile<span class="jill"></span>变量的写操作，happens-before<span class="jill"></span>后续每一个针对该变量的读操作</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token comment">// Thread 1</span>
<span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token keyword">boolean</span> <span class="token keyword">volatile</span> b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//  2 对一个volatile变量的写操作</span>

<span class="token comment">// Thread 2:</span>
<span class="token keyword">boolean</span> flag <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token keyword">int</span> newS <span class="token operator">=</span> s<span class="token punctuation">;</span>     <span class="token comment">// 4</span>

<span class="token comment">// 根据程序顺序规则，1 happens-before 2  3 happens-before 4</span>
<span class="token comment">// 根据volatile变量规则, 2 happens-before 3</span>
<span class="token comment">// 也就是 1 happens-before 4</span></pre></div></code-block></li></ul><h3 class="wolai-block"><span class="inline-wrap">为什么双检测锁机制需要使用<span class="jill"></span>volatile<span class="jill"></span>变量</span></h3><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">class</span> <span class="token class-name">Single</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Single</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span>  <span class="token class-name">Single</span> single<span class="token punctuation">;</span>

    <span class="token keyword">public</span>  <span class="token keyword">static</span>  <span class="token class-name">Single</span> getInstance <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> single<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Single</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> single<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    single <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span>  single<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">上面是常见的双检测锁单例模式，为什么<span class="jill"></span>single<span class="jill"></span>要用<span class="jill"></span>volatile<span class="jill"></span>修饰呢？答案就是</span><span class="inline-wrap"><code>single = new Single();</code></span><span class="inline-wrap">并不是一个原子操作。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token comment">// 创建 Cache 对象实例，分配内存</span>
<span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">5</span>                  <span class="token comment">// class com/query/Cache</span>
<span class="token comment">// 复制栈顶地址，并再将其压入栈顶</span>
<span class="token number">3</span><span class="token operator">:</span> dup
<span class="token comment">// 调用构造器方法，初始化 Cache 对象</span>
<span class="token number">4</span><span class="token operator">:</span> invokespecial #<span class="token number">6</span>                  <span class="token comment">// Method "&lt;init>":()V</span>
<span class="token comment">// 存入局部方法变量表</span>
<span class="token number">7</span><span class="token operator">:</span> astore_1</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">从字节码可以看到创建一个对象实例，可以分为三步：</span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">分配对象内存</span></li><li><div class="marker"></div><span class="inline-wrap">调用构造器方法，执行初始化</span></li><li><div class="marker"></div><span class="inline-wrap">将对象引用赋值给变量。</span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap">第二步和第三步有可能会发生指令重排，然后就有可能导致别的线程在执行</span><span class="inline-wrap"><code>null == single</code></span><span class="inline-wrap">时，得到错误的结果，当<span class="jill"></span>single<span class="jill"></span>被<span class="jill"></span>volatile<span class="jill"></span>修饰时，根据<span class="jill"></span>volatile<span class="jill"></span>变量规则，当别的线程执行</span><span class="inline-wrap"><code>null == single</code></span><span class="inline-wrap">得到<span class="jill"></span>false<span class="jill"></span>时，single<span class="jill"></span>必定已初始化完毕。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://www.cnblogs.com/goodAndyxublog/p/11356402.html"><span>为什么双重检测锁机制需要使用<span class="jill"></span>volatile<span class="jill"></span>关键字</span></a></span></div></div><h2 class="wolai-block"><span class="inline-wrap">final<span class="jill"></span>关键字</span></h2><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果一个构造函数在运行过程中初始化一个<span class="jill"></span>final<span class="jill"></span>变量，那么该构造函数必须等待该变量初始化完毕才能退出</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">todo final<span class="jill"></span>关键的含义</span></li></ul></article><footer></footer></body></html>
<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>3.线程同步机制-上 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="3.线程同步机制-上" class="main-title"></div></div></header><article><div class="wolai-block wolai-text"><div><span class="inline-wrap">多个线程同时对同一共享资源进行操作时，操作的结果是不确定的，这就是线程安全问题，线程安全问题的产生原因是线程之间缺乏同步机制。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>什么是线程同步机制</b></span></div></div><div class="wolai-block wolai-text"><div><span class="red inline-wrap">线程同步机制是一套用于协调线程间访问和操作共享数据的机制。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>平台提供的线程同步机制包括，锁、</span><span class="inline-wrap"><code>volatile</code></span><span class="inline-wrap">关键字、</span><span class="inline-wrap"><code>final</code></span><span class="inline-wrap">关键字以及一些相关的<span class="jill"></span>API，例如</span><span class="inline-wrap"><code>Object.wait()和<span class="jill"></span>Object.notify()</code></span><span class="inline-wrap">等等。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">锁</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>锁的思想</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">线程安全问题产生的前提是多个线程同时对某个资源进行操作，导致操作的结果不可控，那么我们限定某一时刻只有一个线程能对该资源进行操作，那么也就不会有线程安全问题了，这也就是锁的思路。线程对资源进行操作时，需要先获得锁，操作完毕后，释放锁。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Java<span class="jill"></span>中锁的分类</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">按照<span class="jill"></span>Java<span class="jill"></span>虚拟机对锁的实现方式划分，Java<span class="jill"></span>平台中的锁分为内部锁和显式锁.</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">内部锁通过</span><span class="inline-wrap"><code>synchronize</code></span><span class="inline-wrap">关键字实现</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">显式锁通过</span><span class="inline-wrap"><code>java.concurrent.locks.Lock</code></span><span class="inline-wrap">接口的实现类实现.</span></li></ul><h2 class="wolai-block"><span class="inline-wrap">内部锁</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Java<span class="jill"></span>中，使用锁的其中一种方式就是使用</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">关键字。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">关键字即可用于方法(无论是实例还是静态方法)，也可用于代码块。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token comment">// synchronized修饰的代码块称为同步代码块</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在java中，所有对象都具有一个内部锁</span>
    <span class="token comment">// mutex，作为内部锁的句柄，是一个对象或者能够返回对象的表达式   </span>
    <span class="token comment">// 多个同步代码块使用同一个对象的内部锁，则同一时刻只有一条线程拥有锁</span>
    <span class="token comment">// 对于锁对象，应该声明为final</span>
    <span class="token comment">// 因为如果一旦锁对象发生了变化，那么很可能使用的将不是同一个锁对象</span>
    <span class="token comment">// 也就失去了同步的意义了，更甚一步，通常声明为private final</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 同步实例方法可以理解为使用该实例作为锁句柄</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 同步静态方法可以理解为使用当前类对象作为锁句柄</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token class-name">Collection</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">线程在执行临界区代码之前需要获取内部锁，获取成功后才能执行临界区中的代码，代码执行后释放内部锁，线程对内部锁的申请和释放都是由<span class="jill"></span>Java<span class="jill"></span>虚拟机实施。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>虚拟机会为每个内部锁分配一个入口集（Entry Set），用于记录等待获取内部锁的线程，入口集中的线程处于阻塞状态。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">显式锁</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">我们知道，synchronized 是<span class="jill"></span>Java<span class="jill"></span>的关键字，是<span class="jill"></span>Java<span class="jill"></span>的内置特性，在<span class="jill"></span>JVM<span class="jill"></span>层面实现了对临界资源的同步互斥访问，但 synchronized 在处理实际问题时存在诸多局限性，比如无法响应中断等。自<span class="jill"></span>JDK1.5<span class="jill"></span>开始引入了显式锁，作为一种线程同步机制，其作用与内部锁相同。它提供了一些内部锁不具备的特性，但并不是内部锁的替代品。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Lock</span> <span class="token punctuation">{</span>
    <span class="token comment">// 用来获取锁。如果锁已被其他线程获取，则一直等待。</span>
    <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 尝试获取锁，如果成功，则返回true，否则返回false</span>
    <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取锁，知道成功获取到锁，或者当前线程被中断</span>
    <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
    <span class="token comment">// 释放锁</span>
    <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><h2 class="wolai-block"><span class="inline-wrap">Lock<span class="jill"></span>和<span class="jill"></span>synchronized<span class="jill"></span>的选择</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">总结来说，</span><span class="inline-wrap"><code>Lock</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">有以下几点不同：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>Lock</code></span><span class="inline-wrap">是一个接口，而</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">是<span class="jill"></span>Java<span class="jill"></span>中的关键字，</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">是内置的语言实现；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而</span><span class="inline-wrap"><code>Lock</code></span><span class="inline-wrap">在发生异常时，如果没有主动通过</span><span class="inline-wrap"><code>unLock()</code></span><span class="inline-wrap">去释放锁，则很可能造成死锁现象，因此使用</span><span class="inline-wrap"><code>Lock</code></span><span class="inline-wrap">时需要在</span><span class="inline-wrap"><code>finally</code></span><span class="inline-wrap">块中释放锁；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>Lock</code></span><span class="inline-wrap">可以让等待锁的线程响应中断，而</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">却不行，使用</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">时，等待的线程会一直等待下去，不能够响应中断；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">通过</span><span class="inline-wrap"><code>Lock</code></span><span class="inline-wrap">可以知道有没有成功获取锁，而</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">却无法办到；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>Lock</code></span><span class="inline-wrap">可以提高多个线程进行读操作的效率，因为它支持读写锁；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>Lock</code></span><span class="inline-wrap">可以在另一个方法里释放锁；</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">JDK1.5<span class="jill"></span>中，</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">是性能低效，到了<span class="jill"></span>JDK1.6，发生了变化，对</span><span class="inline-wrap"><code>synchronize</code></span><span class="inline-wrap">加入了很多优化措施，有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。在<span class="jill"></span>JDK1.6<span class="jill"></span>上</span><span class="inline-wrap"><code>synchronize</code></span><span class="inline-wrap">的性能并不比</span><span class="inline-wrap"><code>Lock</code></span><span class="inline-wrap">差。官方也表示，他们也更支持</span><span class="inline-wrap"><code>synchronize</code></span><span class="inline-wrap">，在未来的版本中还有优化余地，所以还是提倡在</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">能实现需求的情况下，优先考虑使用</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">来进行同步。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><aside class="bg-cultured wolai-block"><div data-symbol="🚀" class="icon"></div><span class="inline-wrap">关于</span><span class="inline-wrap"><code>volatile</code></span><span class="inline-wrap">关键字和</span><span class="inline-wrap"><code>final</code></span><span class="inline-wrap">关键字，请看</span><span class="inline-wrap"><a href="https://www.wolai.com/ggEE5pyE6HHC2ra9uURri6#ggEE5pyE6HHC2ra9uURri6" class="wolai-bi-link"><span class="embed-page">9.深入理解并发问题(待完善)</span></a></span></aside><div class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>
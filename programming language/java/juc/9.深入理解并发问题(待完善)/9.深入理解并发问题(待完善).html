<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>9.深入理解并发问题(待完善) - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="9.深入理解并发问题(待完善)" class="main-title"></div></div></header><article><h3 class="wolai-block"><span class="inline-wrap">并发、并行、高并发</span></h3><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>并发</b></span><span class="inline-wrap">：如果某个系统支持两个或以上个动作</span><span class="inline-wrap"><b>同时存在</b></span><span class="inline-wrap">，那么这个系统就是一个</span><span class="inline-wrap"><b>并发系统</b></span><span class="inline-wrap">。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>并行</b></span><span class="inline-wrap">：如果某个系统支持两个或以上个动作</span><span class="inline-wrap"><b>同时执行</b></span><span class="inline-wrap">，那么这个系统就是一个</span><span class="inline-wrap"><b>并行系统</b></span><span class="inline-wrap">。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>高并发</b></span><span class="inline-wrap">：通常是指，通过设计保证系统能够</span><span class="inline-wrap"><b>同时并发处理</b></span><span class="inline-wrap">很多请求。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">1.并发问题</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>中的多线程编程属于并发编程的一种。并发编程能有效提高程序运行的效率，但同时也容易出现一些问题，下面我们来了解这些问题，只有把这些问题了解了，才能写出好的并发程序。</span></div></div><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">并发问题主要有三种：可见性问题、原子性问题、有序性问题。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">可见性问题</span></h3><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>可见性</b></span><span class="inline-wrap">：一个线程对共享变量值的修改，能够及时的被其它线程看到。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>共享变量</b></span><span class="inline-wrap">：一个变量在多个线程的工作内存中存在副本，那这个变量就是这几个线程的共享变量。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>可见性问题</b></span><span class="inline-wrap">：一个线程对共享变量值的修改，没有及时的被其它线程看到。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>为什么会出现这个问题？</b></span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">线程的交叉执行</span></li><li><div class="marker"></div><span class="inline-wrap">共享变量更新后的值没有及时在工作内存和主内存中更新</span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>解决方案</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">要实现共享变量的可见性，必须保证两点：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">线程修改后的共享变量能够及时从工作内存刷新到主内存中</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">其他线程能及时把共享变量的最新值从主内存中更新到自己的工作内存中</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>解决可见性问题的方式包括：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">synchronized</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">volatile</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Lock</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>synchronized</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">JMM<span class="jill"></span>关于<span class="jill"></span>synchronized<span class="jill"></span>的两条规定</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">线程释放锁前，必须把共享变量的最新值刷新到主内存中</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">线程加锁时，将清空工作内存中共享变量的值，从而在使用共享变量时，需要从主内存中重新读取最新的值</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>volatile</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">通过内存屏障和禁止重排序优化来保证可见性</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">要在多线程中安全的使用<span class="jill"></span>volatile<span class="jill"></span>变量，必须同时满足</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对变量的写入操作不依赖其当前值</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">该变量没有包含在具有其他变量的不变式中</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Lock</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在前面讲<span class="jill"></span>AQS<span class="jill"></span>的时候我们知道，Lock<span class="jill"></span>接口的底层是通过<span class="jill"></span>AQS<span class="jill"></span>实现的。AQS<span class="jill"></span>的加锁和释放锁主要就是修改<span class="jill"></span>volatile 变量 state<span class="jill"></span>的值。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">原子性问题</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>原子性操作</b></span><span class="inline-wrap">：一般我们认为原子是不可再分的，在编程领域中，原子性操作指的是一组操作是不可再分的，这组操作是一个统一的整体，这组操作在执行的过程中不会其它因素干扰，例如执行过程中被中断、或者执行过程中所用到的值被偷偷修改了。在<span class="jill"></span>Java<span class="jill"></span>中，对基本数据类型的变量的读取和赋值操作是原子性操作。例如</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
y <span class="token operator">=</span> x<span class="token punctuation">;</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>注意</b></span><span class="inline-wrap">：在<span class="jill"></span>32<span class="jill"></span>位平台下，对<span class="jill"></span>64<span class="jill"></span>位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的<span class="jill"></span>JDK<span class="jill"></span>中，JVM<span class="jill"></span>已经保证对<span class="jill"></span>64<span class="jill"></span>位数据的读取和赋值也是原子性操作了。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre>x <span class="token operator">+=</span> <span class="token number">1</span>；
x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">// 上面这种就不是原子性操作了，</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>原子性问题</b></span><span class="inline-wrap">：我想不到、也找不到一个正式的定义，只能通过例子来讲。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">例如 </span><span class="inline-wrap"><code>x = x + 1;</code></span><span class="inline-wrap">这个操作。
</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">假设当前</span><span class="inline-wrap"><code>x = 9</code></span><span class="inline-wrap">，然后有两个线程同时执行上面这条语句。
</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">由于两个线程都读到<span class="jill"></span>x<span class="jill"></span>的值为<span class="jill"></span>9，然后都执行递增操作，最后<span class="jill"></span>x<span class="jill"></span>的值变为<span class="jill"></span>10， 而不是预期的<span class="jill"></span>11。
</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">这种问题就是原子性问题。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>解决方案</b></span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">原子类</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">synchronized</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Lock</span></li></ul><h3 class="wolai-block"><span class="inline-wrap">有序性问题</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>有序性问题</b></span><span class="inline-wrap">：程序执行的顺序与编写代码的先后顺序不一致。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>产生的原因</b></span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">编译器指令重排</span><span class="inline-wrap">
</span><span class="inline-wrap">编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">CPU<span class="jill"></span>乱序执行</span><span class="inline-wrap">
</span><span class="inline-wrap">现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">内存系统的重排序</span><span class="inline-wrap">
</span><span class="inline-wrap">由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>解决方案</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Java<span class="jill"></span>中，可以使用</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>volatile</code></span><span class="inline-wrap">来保证多线程之间操作的有序性。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>volatile</code></span><span class="inline-wrap">关键字会禁止指令重排。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">关键字保证同一时刻只允许一条线程操作。进出锁住的代码块是串行的，因为只能有一个线程拿到锁，这就使得使用同一个锁的两个执行过程<span class="jill"></span>A<span class="jill"></span>和<span class="jill"></span>B<span class="jill"></span>之间，A<span class="jill"></span>看<span class="jill"></span>B<span class="jill"></span>的操作是有序的，B<span class="jill"></span>看<span class="jill"></span>A<span class="jill"></span>的操作也是有序的，是因为执行过程内部无论会不会指令重排序，结果都是一致的。但是锁的内部代码依然会指令重排序。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">2.多线程编程的硬件基础</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">软件是运行在硬件之上的, 特别是多线程编程, 有些并发问题的根本原因就是由于某些硬件的特性所导致的,了解与多线程编程有关的硬件知识, 有利于我们编写高质量的多线程程序.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">这里介绍的许多硬件部件都有一个共同的特点, 硬件的设计者为了解决某个问题而引入了一个新的部件, 然后这个部件又会引入新的问题, 掌握这些部件之间的关系, 有助于我们更好的理解相关的部件.</span></div></div><h3 class="wolai-block"><span class="inline-wrap">超线程</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">现在买<span class="jill"></span>CPU,通常可以听到这个<span class="jill"></span>CPU<span class="jill"></span>几核几线程这样的术语,这究竟是什么意思是?
例如四核八线程是什么意思?</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">单核<span class="jill"></span>CPU:只有一个核心,同一时刻只能执行一条指令</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">多核<span class="jill"></span>CPU:有多个核心,同一时刻可以执行多条指令</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">超线程: 把一个物理核心在软件层变成两个逻辑核心，可以使核心在某一时刻，同步并行处理更多指令和数据(多个线程)，当然了实际效能不可实现双倍提升，毕竟干活的核心只有一个。 </span><span class="inline-wrap"><a href="https://www.expreview.com/56674.html"><span>超线程/SMT<span class="jill"></span>多线程技术有什么用？</span></a></span></li></ul><h3 class="wolai-block"><span class="inline-wrap">高速缓存</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">现代处理器的运行速度要远高于内存的运行速度, 内存一次读/写操作的时间,足以让处理器执行上百条指令, 为了弥补这个差距,硬件设计者在处理器和主内存之间引入了高速缓存.</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>一个<span class="jill"></span>CPU<span class="jill"></span>具有多个处理器,每个处理器都有各自的高速缓存</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>高速缓存是分级的，有一、二、三级高速缓存，其中每个核心都有一、二级高速缓存，所有核心共享三级高速缓存</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">高速缓存是一种存取速率远比内存大而容量远比内存小的存储部件, 引入高速缓存后,处理器执行内存读写、操作并不直接与内存打交道,而是通过高速缓存进行的.</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">从内部结构来看,高速缓存相当于一个拉链散列表,它包含若干个桶,每个桶包含若干条</span><span class="inline-wrap"><b>缓存条目</b></span><span class="inline-wrap">.</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" style="width: 756.5px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">一个缓存条目可分为三部分:</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/%E5%86%85%E5%AD%98%E6%9D%A1%E7%9B%AE%E7%9A%84%E7%BB%93%E6%9E%84.png" style="width: 754px"/></figure></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Data Block:数据块(也称缓存行),存储从主内存中获取的数据</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Tag:存储缓存行中数据的内存地址的部分信息(内存地址的高位部分比特).</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Flag:标记位,表示该条目是否有效</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">处理器在执行内存访问操作时,会对内存地址进行解析,解析的结果包括</span><span class="inline-wrap"><code>index</code></span><span class="inline-wrap"> 、</span><span class="inline-wrap"><code>tag</code></span><span class="inline-wrap">、</span><span class="inline-wrap"><code>offset</code></span><span class="inline-wrap">这三部分数据.</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>index</code></span><span class="inline-wrap">:相当于桶编号</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>tag</code></span><span class="inline-wrap">:相当于缓存条目的编号</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>offset</code></span><span class="inline-wrap">:缓存行内的位置偏移,用于定位数据在缓存行中的起始位置</span></li></ul><h3 class="wolai-block"><span class="inline-wrap">缓存一致性协议</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">现代处理器都有多个核心，每个核心又有各自的一、二级高速缓存，这就带来了一个新问题，一个处理器对其高速缓存中的数据进行修改后，如何让其它处理器“察觉”并作出相应的调整，这就是缓存一致性问题，为了解决这个问题，处理器之间需要一种通信机制----缓存一致性协议。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">MESI（Modified-Exclusive-Shared-Invalid）协议是一种广为使用的缓存一致性协议。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">MESI<span class="jill"></span>协议对内存数据访问的控制类似于读写锁，可以并发读取同一内存地址的值，但是对于同一内存地址的写是独占的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">MESI<span class="jill"></span>协议中，一个缓存条目的<span class="jill"></span>Flag<span class="jill"></span>有四种取值，分别是<span class="jill"></span>Modified、Exclusive、Shared、Invalid，在此基础上还定义了一组消息（Message）用于协调各个处理器的读、写操作。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Invalid：表示相应缓存行中不包含任何内存地址对应的有效副本数据，这也是缓存条目的初始状态</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Shared：表示相应缓存行包含相应内存地址所对应的副本数据，并且其它处理器的高速缓存也可能包含相同内存地址对应的副本</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Exclusive：表示相应缓存行包含相应内存地址锁对应的副本数据，并且其它处理器的高速缓存没有包含相同内存地址对应的副本</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Modified：表示相应缓存行包含相应内存地址所做的更新结果数据。MESI<span class="jill"></span>协议规定任一时刻只能有一个处理器对同一内存地址对应的数据进行更新，因此<span class="jill"></span>Tag<span class="jill"></span>相同的缓存条目中，只有一条缓存条目它的<span class="jill"></span>Flag<span class="jill"></span>是<span class="jill"></span>Modified<span class="jill"></span>的</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">MESI<span class="jill"></span>协议定义了一组消息，用来协调各个处理器的读、写内存操作。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Read</span><span class="inline-wrap">
</span><span class="inline-wrap">处理器发出<span class="jill"></span>Read<span class="jill"></span>消息，告诉其它处理器和主内存准备读取某个数据，该消息包含读取的数据的内存地址</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Read Response</span><span class="inline-wrap">
</span><span class="inline-wrap">该消息包含被请求读取的数据，该消息可能是主内存发送的，也可能是嗅探<span class="jill"></span>Read<span class="jill"></span>消息的其它高速缓存提供的</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Invalidate</span><span class="inline-wrap">
</span><span class="inline-wrap">处理器发出<span class="jill"></span>Invalidate<span class="jill"></span>消息，要求其它处理器将其高速缓存中指定内存地址所对应的缓存条目设置状态为<span class="jill"></span>I，也就是要求处理器删除指定内存地址的副本数据</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Invalidate Acknowledge</span><span class="inline-wrap">
</span><span class="inline-wrap">接收到<span class="jill"></span>Invalidate<span class="jill"></span>消息的处理器必须回复消息，以表示删除了高速缓存上相应的副本数据</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Read Invalidate</span><span class="inline-wrap">
</span><span class="inline-wrap">处理器发出<span class="jill"></span>Read Invalidate<span class="jill"></span>消息</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Writeback</span><span class="inline-wrap">
</span><span class="inline-wrap">处理器发出<span class="jill"></span>Writeback<span class="jill"></span>消息，该请求包含需要写入主内存的数据以及对应的内存地址</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>MESI<span class="jill"></span>协议实战</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">假设内存地址<span class="jill"></span>A<span class="jill"></span>上的数据<span class="jill"></span>D<span class="jill"></span>是处理器<span class="jill"></span>P0<span class="jill"></span>和<span class="jill"></span>P1<span class="jill"></span>可能共享的数据。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">P0<span class="jill"></span>从缓存系统中读取数据</span><span class="inline-wrap">
</span><span class="inline-wrap">P0<span class="jill"></span>根据<span class="jill"></span>A<span class="jill"></span>找到对应的缓存条目，如果缓存条目的状态(Flag)是<span class="jill"></span>M/E/S,那么该处理器直接从缓存行相应的位置读取数据，不需要向总线发送任何消息</span><span class="inline-wrap">
</span><span class="inline-wrap">如果缓存条目的状态是<span class="jill"></span>I，那么<span class="jill"></span>P0<span class="jill"></span>会往总线发送<span class="jill"></span>Read<span class="jill"></span>消息，其它处理器或主内存则需要回复<span class="jill"></span>Read Response<span class="jill"></span>消息</span><span class="inline-wrap">
</span><span class="inline-wrap">如果<span class="jill"></span>P1<span class="jill"></span>收到了<span class="jill"></span>Read<span class="jill"></span>消息，它会到缓存系统查看是否有对应且合法(Flag<span class="jill"></span>为<span class="jill"></span>M/E/S)的数据，如果有则构造<span class="jill"></span>Read Response<span class="jill"></span>消息，把该缓存条目的整个缓存行都发送出去，并且把缓存行标记为<span class="jill"></span>S</span><span class="inline-wrap">
</span><span class="inline-wrap">如果<span class="jill"></span>P1<span class="jill"></span>对应的缓存条目的状态是<span class="jill"></span>I，那么<span class="jill"></span>P0<span class="jill"></span>需要的数据就由主内存提供，获取数据后<span class="jill"></span>P0<span class="jill"></span>对应的缓存行会被标记为<span class="jill"></span>E</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">P0<span class="jill"></span>修改缓存系统中的数据</span><span class="inline-wrap">
</span><span class="inline-wrap">P0<span class="jill"></span>找到对应的缓存条目，如果该缓存条目状态为<span class="jill"></span>E/M，则说明该处理器已经拥有相应数据的所有权，可以直接把修改后的数据写入到缓存条目</span><span class="inline-wrap">
</span><span class="inline-wrap">如果缓存条目的状态为<span class="jill"></span>S，则<span class="jill"></span>P0<span class="jill"></span>发送<span class="jill"></span>Invalidate<span class="jill"></span>消息，要求其它处理器把对应的缓存条目设置为<span class="jill"></span>I，并返回<span class="jill"></span>Invalidate Response<span class="jill"></span>消息，收到所有处理的<span class="jill"></span>Invalidate Response<span class="jill"></span>消息后，P0<span class="jill"></span>才能把修改后的数据写入到缓存条目</span><span class="inline-wrap">
</span><span class="inline-wrap">如果缓存条目的状态为<span class="jill"></span>I，则<span class="jill"></span>P0<span class="jill"></span>发送<span class="jill"></span>Read Invalidate<span class="jill"></span>消息，P0<span class="jill"></span>接收到<span class="jill"></span>Read Response<span class="jill"></span>更新数据，接收所有处理器的<span class="jill"></span>Invalidate Acknowledge<span class="jill"></span>消息后，把缓存条目的状态修改为<span class="jill"></span>E，之后<span class="jill"></span>P0<span class="jill"></span>就可以把新数据写入对应的缓存条目，并修改状态为<span class="jill"></span>M。</span></li></ul><h3 class="wolai-block"><span class="inline-wrap">写缓冲区与无效化队列</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">MESI<span class="jill"></span>协议虽然解决了缓存一致性问题，但是它也带来了一个性能弱点---处理器执行写内存操作的时候，需要等待所有处理器从高速缓存中删除对应的数据，并返回<span class="jill"></span>Invalidate Acknowledge<span class="jill"></span>消息之后才能把数据写入高速缓存。为此硬件设计者引入了写缓冲区与无效化队列。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>写缓冲区</b></span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">当处理器在执行写操作时，如果缓存条目状态为<span class="jill"></span>E<span class="jill"></span>和<span class="jill"></span>M，那就直接写入。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果状态为<span class="jill"></span>S，那么处理器会将写操作相关的数据，存入写缓冲区的条目之中，并发送<span class="jill"></span>Invalidate<span class="jill"></span>消息，然后处理器执行后面的指令，而不再阻塞的等待响应</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果状态为<span class="jill"></span>I，处理器同样将写操作相关的数据，存入写缓冲区的条目之中，然后发送<span class="jill"></span>Read Invalidate<span class="jill"></span>消息，然后处理器执行后面的指令，而不再阻塞的等待响应</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">当处理器收到所有其它处理器针对同一条缓存条目的所有<span class="jill"></span>Invalidate Acknowledge<span class="jill"></span>消息的时候，处理器才把写缓冲区中针对相应地址的写操作写入相应的缓存行中</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>无效化队列</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">处理器接收到<span class="jill"></span>Invalidate<span class="jill"></span>消息后，并不删除消息中指定地址对应的副本数据，而是将消息存入无效化队列之后就回复<span class="jill"></span>Invalidate Acknowledge<span class="jill"></span>消息，从而减少对方的等待时间。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">写缓冲区与无效化队列的引入又带来了新的问题，那就是可见性问题与内存重排序。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">可见性问题</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">由于写缓冲区是处理器私有的，写缓冲区所存储的内容是无法被其它处理器所读取的，因此一个处理器上运行的线程对一个共享变量进行更新之后，其它处理器上运行的线程再来读取该变量时，这些线程可能仍然无法读取到前一个线程对该变量所做的更新，所以说写缓冲区是可见性问题的根本原因。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">为了解决这个问题，我们就需要一些指令，它可以强制写缓冲器把存储的内容更新到高速缓存中，然后由于缓存一致性协议，处理器也就能读取到有效的数据。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">由于无效化队列的存在，导致处理器有可能读取到过期的数据，因此我们也需要一些指令，它强制处理器根据无效化队列中的消息把对应的数据设置为无效。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">上面所说的指令就是内存屏障指令。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">内存重排序</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">写缓冲器可能导致<span class="jill"></span>StoreLoad<span class="jill"></span>重排序，因为<span class="jill"></span>Store<span class="jill"></span>写入写缓冲器，别的处理器无法及时意识到<span class="jill"></span>P1<span class="jill"></span>发生了<span class="jill"></span>Store<span class="jill"></span>操作，导致别的处理器认为<span class="jill"></span>P1<span class="jill"></span>是执行先<span class="jill"></span>Load<span class="jill"></span>然后再<span class="jill"></span>Store<span class="jill"></span>的操作。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">写缓冲器也可能导致<span class="jill"></span>StoreStore<span class="jill"></span>重排序，例如<span class="jill"></span>P1<span class="jill"></span>先修改变量<span class="jill"></span>v1，后修改变量<span class="jill"></span>v2，但是<span class="jill"></span>v1<span class="jill"></span>存储到写缓冲器，v2<span class="jill"></span>直接写入了高速缓存，导致其它处理器认为<span class="jill"></span>P1<span class="jill"></span>是先修改变量<span class="jill"></span>v2，后修改变量<span class="jill"></span>v1。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">无效化队列可能导致<span class="jill"></span>LoadLoad<span class="jill"></span>重排序</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/%E6%97%A0%E6%95%88%E5%8C%96%E9%98%9F%E5%88%97-loadload%E9%87%8D%E6%8E%92%E5%BA%8F.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">假设，data<span class="jill"></span>和<span class="jill"></span>ready<span class="jill"></span>初始值为<span class="jill"></span>0，P0<span class="jill"></span>高速缓存有<span class="jill"></span>data<span class="jill"></span>和<span class="jill"></span>ready<span class="jill"></span>的副本，P1<span class="jill"></span>高速缓存只有<span class="jill"></span>data<span class="jill"></span>的副本。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">P0<span class="jill"></span>对<span class="jill"></span>data<span class="jill"></span>进行更新，发送消息给<span class="jill"></span>P1，P1<span class="jill"></span>把消息存在无效化队列中</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">P0<span class="jill"></span>直接把<span class="jill"></span>ready<span class="jill"></span>写入高速缓存</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">P1<span class="jill"></span>发送消息读取<span class="jill"></span>ready，读取以后写入到高速缓存</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">P1<span class="jill"></span>打印<span class="jill"></span>data，由于无效化队列的原因，P1<span class="jill"></span>从高速缓存中读取的<span class="jill"></span>data，可能还没更新</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">从<span class="jill"></span>P0<span class="jill"></span>的角度，如果<span class="jill"></span>P1<span class="jill"></span>是先执行<span class="jill"></span>L3<span class="jill"></span>再执行<span class="jill"></span>L4，那么<span class="jill"></span>data<span class="jill"></span>应该为<span class="jill"></span>1，但是它输出为<span class="jill"></span>0，那么<span class="jill"></span>P0<span class="jill"></span>会认为<span class="jill"></span>P1<span class="jill"></span>是先执行了<span class="jill"></span>L4<span class="jill"></span>再执行<span class="jill"></span>L3，也就是<span class="jill"></span>LoadLoad<span class="jill"></span>重排序了</span></li></ul><h3 class="wolai-block"><span class="inline-wrap">基本内存屏障</span></h3><h2 class="wolai-block"><span class="inline-wrap">3.Java<span class="jill"></span>内存模型</span></h2><h3 class="wolai-block"><span class="inline-wrap">内存模型</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">缓存一致性协议确保了一个处理器对某个内存地址进行的写操作的结果最终能够被其它处理器所读取，所谓“最终”也就是带有不确定性，换而言之，即一个处理器对共享变量所做的更新具体在什么时候被其它处理器读取，是无法保证的。写缓冲区和无效化队列可能导致处理器在某一时刻读取到共享变量的旧值。</span></div></div><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">因此，从底层的角度来看，计算机系统必须解决两个问题：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="pink inline-wrap">一个处理器对共享变量所做的更新在什么时候才能够被其它处理器所读取--可见性问题</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="pink inline-wrap">一个处理器先后更新多个共享变量的情况下，其它处理器是以何种顺序读取到这些更新的--有序性问题</span></li></ul><div class="wolai-block wolai-text"><div><span class="pink inline-wrap">用于解决上述问题的模型被称为内存一致性模型，也被称为内存模型。</span><span class="inline-wrap">（内存模型规定了一个处理器对共享变量所做的更新在什么时候才能够被其它处理器所读取，一个处理器先后更新多个共享变量的情况下，其它处理器是以何种顺序读取到这些更新的）</span></div></div><h3 class="wolai-block"><span class="inline-wrap">Java<span class="jill"></span>内存模型</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">不同的处理器架构有着不同的内存模型，而<span class="jill"></span>Java<span class="jill"></span>作为一个跨平台（操作系统和硬件）的语言，自然需要屏蔽不同处理器的内存模型差异，为开发人员提供一个统一的内存模型，以便开发人员无需根据不同的处理器编写不同的代码，这个内存模型就是<span class="jill"></span>Java<span class="jill"></span>内存模型。</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">Chapter 17. Threads and Locks</a><div class="info-box"><div class="text-pane"><div data-title="Chapter 17. Threads and Locks"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://docs.oracle.com/favicon.ico&quot;)"></div><div data-hostname="docs.oracle.com"></div></div></div><div class="preview-pane"></div></div></div><div class="wolai-block wolai-text"><div></div></div><h2 class="wolai-block"><span class="inline-wrap">轻量级同步机制：volatile</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用</span><span class="inline-wrap"><code>volatile</code></span><span class="inline-wrap">关键字修饰的变量，对它的读操作都是从主内存中读取，写操作的结果会立即写回主内存。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">自从<span class="jill"></span>JDK5<span class="jill"></span>以来，</span><span class="inline-wrap"><code>volatile</code></span><span class="inline-wrap">关键字不仅解决可见性问题，还提供了别的特性，在讲解这些特性之前，我们先来看一下<span class="jill"></span>happens-before</span></div></div><h3 class="wolai-block"><span class="inline-wrap">happens-before</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">JVM<span class="jill"></span>规范中定义了一些动作，这些动作包括变量的读/写、锁的申请与释放，以及线程的<span class="jill"></span>start<span class="jill"></span>和<span class="jill"></span>join<span class="jill"></span>等等。假设动作<span class="jill"></span>A<span class="jill"></span>和动作<span class="jill"></span>B<span class="jill"></span>之间存在<span class="jill"></span>happens-before<span class="jill"></span>关系，称之为 A happens-before B。那么<span class="jill"></span>JVM<span class="jill"></span>保证<span class="jill"></span>A<span class="jill"></span>的操作结果对<span class="jill"></span>B<span class="jill"></span>可见。happens-before<span class="jill"></span>关系具有传递性，如果<span class="jill"></span>A happens-before B，B happens-before C 则<span class="jill"></span>A HB C。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">JVM<span class="jill"></span>定义了一些关于<span class="jill"></span>happens-before<span class="jill"></span>关系的规则，这些规则规定了两个动作，在身情况下具有<span class="jill"></span>happens-before<span class="jill"></span>关系。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">程序顺序规则：一个线程中的每一个动作都<span class="jill"></span>happens-before<span class="jill"></span>该线程中程序顺序上排在该动作之后的每一个动作</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">内部锁规则：内部锁的释放 happens-before<span class="jill"></span>后续每一个对该锁的申请</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">线程启动规则：调用一个线程的<span class="jill"></span>start<span class="jill"></span>方法<span class="jill"></span>happens-before<span class="jill"></span>被启动的这个线程中的任何一个动作</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">线程终止规则：被调用<span class="jill"></span>join<span class="jill"></span>方法的线程，它的任何一个动作都<span class="jill"></span>happens-before<span class="jill"></span>调用改方法的线程，在<span class="jill"></span>join<span class="jill"></span>方法后面的动作</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">volatile<span class="jill"></span>变量规则：对一个<span class="jill"></span>volatile<span class="jill"></span>变量的写操作，happens-before<span class="jill"></span>后续每一个针对该变量的读操作</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token comment">// Thread 1</span>
<span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token keyword">boolean</span> <span class="token keyword">volatile</span> b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//  2 对一个volatile变量的写操作</span>

<span class="token comment">// Thread 2:</span>
<span class="token keyword">boolean</span> flag <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token keyword">int</span> newS <span class="token operator">=</span> s<span class="token punctuation">;</span>     <span class="token comment">// 4</span>

<span class="token comment">// 根据程序顺序规则，1 happens-before 2  3 happens-before 4</span>
<span class="token comment">// 根据volatile变量规则, 2 happens-before 3</span>
<span class="token comment">// 也就是 1 happens-before 4</span></pre></div></code-block></li></ul><h3 class="wolai-block"><span class="inline-wrap">为什么双检测锁机制需要使用<span class="jill"></span>volatile<span class="jill"></span>变量</span></h3><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">class</span> <span class="token class-name">Single</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Single</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span>  <span class="token class-name">Single</span> single<span class="token punctuation">;</span>

    <span class="token keyword">public</span>  <span class="token keyword">static</span>  <span class="token class-name">Single</span> getInstance <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> single<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Single</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> single<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    single <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span>  single<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">上面是常见的双检测锁单例模式，为什么<span class="jill"></span>single<span class="jill"></span>要用<span class="jill"></span>volatile<span class="jill"></span>修饰呢？答案就是</span><span class="inline-wrap"><code>single = new Single();</code></span><span class="inline-wrap">并不是一个原子操作。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token comment">// 创建 Cache 对象实例，分配内存</span>
<span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">5</span>                  <span class="token comment">// class com/query/Cache</span>
<span class="token comment">// 复制栈顶地址，并再将其压入栈顶</span>
<span class="token number">3</span><span class="token operator">:</span> dup
<span class="token comment">// 调用构造器方法，初始化 Cache 对象</span>
<span class="token number">4</span><span class="token operator">:</span> invokespecial #<span class="token number">6</span>                  <span class="token comment">// Method "&lt;init>":()V</span>
<span class="token comment">// 存入局部方法变量表</span>
<span class="token number">7</span><span class="token operator">:</span> astore_1</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">从字节码可以看到创建一个对象实例，可以分为三步：</span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">分配对象内存</span></li><li><div class="marker"></div><span class="inline-wrap">调用构造器方法，执行初始化</span></li><li><div class="marker"></div><span class="inline-wrap">将对象引用赋值给变量。</span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap">第二步和第三步有可能会发生指令重排，然后就有可能导致别的线程在执行</span><span class="inline-wrap"><code>null == single</code></span><span class="inline-wrap">时，得到错误的结果，当<span class="jill"></span>single<span class="jill"></span>被<span class="jill"></span>volatile<span class="jill"></span>修饰时，根据<span class="jill"></span>volatile<span class="jill"></span>变量规则，当别的线程执行</span><span class="inline-wrap"><code>null == single</code></span><span class="inline-wrap">得到<span class="jill"></span>false<span class="jill"></span>时，single<span class="jill"></span>必定已初始化完毕。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://www.cnblogs.com/goodAndyxublog/p/11356402.html"><span>为什么双重检测锁机制需要使用<span class="jill"></span>volatile<span class="jill"></span>关键字</span></a></span></div></div><h2 class="wolai-block"><span class="inline-wrap">final<span class="jill"></span>关键字</span></h2><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果一个构造函数在运行过程中初始化一个<span class="jill"></span>final<span class="jill"></span>变量，那么该构造函数必须等待该变量初始化完毕才能退出</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"></span><br/></li></ul></article><footer></footer></body></html>
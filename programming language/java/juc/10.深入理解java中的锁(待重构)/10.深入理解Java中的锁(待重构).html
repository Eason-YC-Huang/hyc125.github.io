<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>10.深入理解Java中的锁(待重构) - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="10.深入理解Java中的锁(待重构)" class="main-title"></div></div></header><article><h2 class="wolai-block"><span class="inline-wrap">锁的分类</span></h2><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB.jpg" style="width: 759.5px"/></figure></div><h3 class="wolai-block"><span class="inline-wrap">自旋锁 VS 适应性自旋锁</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>阻塞或唤醒一个<span class="jill"></span>Java<span class="jill"></span>线程需要操作系统切换<span class="jill"></span>CPU<span class="jill"></span>状态来完成</b></span><span class="inline-wrap"> (什么意思?)，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃<span class="jill"></span>CPU<span class="jill"></span>的执行时间，看看持有锁的线程是否很快就会释放锁。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数，没有成功获得锁，就应当挂起线程。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%94%81.jpg" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">适应性自旋锁意味着自旋的时间（或次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://coderbee.net/index.php/concurrent/20131115/577"><span>自旋锁、排队自旋锁、MCS<span class="jill"></span>锁、CLH<span class="jill"></span>锁</span></a></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">自旋锁在<span class="jill"></span>JDK1.4.2<span class="jill"></span>中引入，使用</span><span class="inline-wrap"><code>-XX:+UseSpinning</code></span><span class="inline-wrap">来开启，使用</span><span class="inline-wrap"><code>-XX:PreBlockSpin</code></span><span class="inline-wrap">来限制自旋次数。JDK 6<span class="jill"></span>中变为默认开启，并且引入了适应性自旋锁。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">这四种锁是指锁的状态，专门针对<span class="jill"></span>synchronized<span class="jill"></span>的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Java<span class="jill"></span>对象头</b></span><span class="inline-wrap">
synchronized<span class="jill"></span>是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在<span class="jill"></span>Java<span class="jill"></span>对象头里的，而<span class="jill"></span>Java<span class="jill"></span>对象头又是什么呢？以<span class="jill"></span>Hotspot<span class="jill"></span>虚拟机为例，对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Mark Word：默认存储对象的<span class="jill"></span>HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以<span class="jill"></span>Mark Word<span class="jill"></span>被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间<span class="jill"></span>Mark Word<span class="jill"></span>里存储的数据会随着锁标志位的变化而变化。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Klass Pointer：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Monitor</b></span><span class="inline-wrap">
Monitor<span class="jill"></span>可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个<span class="jill"></span>Java<span class="jill"></span>对象就有一把看不见的锁，称为内部锁或者<span class="jill"></span>Monitor<span class="jill"></span>锁。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Monitor<span class="jill"></span>是线程私有的数据结构，每一个线程都有一个可用<span class="jill"></span>monitor record<span class="jill"></span>列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个<span class="jill"></span>monitor<span class="jill"></span>关联，同时<span class="jill"></span>monitor<span class="jill"></span>中有一个<span class="jill"></span>Owner<span class="jill"></span>字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">AbstractQueuedSynchronizer<span class="jill"></span>现在话题回到<span class="jill"></span>synchronized，synchronized<span class="jill"></span>通过<span class="jill"></span>Monitor<span class="jill"></span>来实现线程同步，Monitor<span class="jill"></span>是依赖于底层的操作系统的<span class="jill"></span>Mutex Lock（互斥锁）来实现的线程同步。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如同我们在自旋锁中提到的“阻塞或唤醒一个<span class="jill"></span>Java<span class="jill"></span>线程需要操作系统切换<span class="jill"></span>CPU<span class="jill"></span>状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是<span class="jill"></span>synchronized<span class="jill"></span>最初实现同步的方式，这就是<span class="jill"></span>JDK 6<span class="jill"></span>之前<span class="jill"></span>synchronized<span class="jill"></span>效率低的原因。这种依赖于操作系统<span class="jill"></span>Mutex Lock<span class="jill"></span>所实现的锁我们称之为“重量级锁”，JDK 6<span class="jill"></span>中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">所以目前锁一共有<span class="jill"></span>4<span class="jill"></span>种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。
通过上面的介绍，我们对<span class="jill"></span>synchronized<span class="jill"></span>的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的<span class="jill"></span>Mark Word<span class="jill"></span>内容，然后再分别讲解四种锁状态的思路以及特点：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>无锁</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。
无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>偏向锁</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">当一个线程访问同步代码块并获取锁时，会在<span class="jill"></span>Mark Word<span class="jill"></span>里存储锁偏向的线程<span class="jill"></span>ID。在线程进入和退出同步块时不再通过<span class="jill"></span>CAS<span class="jill"></span>操作来加锁和解锁，而是检测<span class="jill"></span>Mark Word<span class="jill"></span>里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次<span class="jill"></span>CAS<span class="jill"></span>原子指令，而偏向锁只需要在置换<span class="jill"></span>ThreadID<span class="jill"></span>的时候依赖一次<span class="jill"></span>CAS<span class="jill"></span>原子指令即可。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。
偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。
偏向锁在<span class="jill"></span>JDK 6<span class="jill"></span>及以后的<span class="jill"></span>JVM<span class="jill"></span>里是默认启用的。可以通过<span class="jill"></span>JVM<span class="jill"></span>参数关闭偏向锁：</span><span class="inline-wrap"><code>-XX:-UseBiasedLocking=false</code></span><span class="inline-wrap">，关闭之后程序默认会进入轻量级锁状态。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>轻量级锁</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。
在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的<span class="jill"></span>Mark Word<span class="jill"></span>的拷贝，然后拷贝对象头中的<span class="jill"></span>Mark Word<span class="jill"></span>复制到锁记录中。拷贝成功后，虚拟机将使用<span class="jill"></span>CAS<span class="jill"></span>操作尝试将对象的<span class="jill"></span>Mark Word<span class="jill"></span>更新为指向<span class="jill"></span>Lock Record<span class="jill"></span>的指针，并将<span class="jill"></span>Lock Record<span class="jill"></span>里的<span class="jill"></span>owner<span class="jill"></span>指针指向对象的<span class="jill"></span>Mark Word。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象<span class="jill"></span>Mark Word<span class="jill"></span>的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的<span class="jill"></span>Mark Word<span class="jill"></span>是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>重量级锁</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">升级为重量级锁时，锁标志的状态值变为“10”，此时<span class="jill"></span>Mark Word<span class="jill"></span>中存储的是指向重量级锁的指针，此时
等待锁的线程都会进入阻塞状态。
整体的锁状态升级流程如下：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">综上，偏向锁通过对比<span class="jill"></span>Mark Word<span class="jill"></span>解决加锁问题，避免执行<span class="jill"></span>CAS<span class="jill"></span>操作。而轻量级锁是通过用<span class="jill"></span>CAS<span class="jill"></span>操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>锁的粒度</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">一个锁实例可以保护一个或多个共享数据,保护的共享数据越多,锁的粒度就越粗.</span></div></div><h2 class="wolai-block"><span class="inline-wrap">锁的实现</span></h2><h3 class="wolai-block"><span class="inline-wrap">synchronize</span></h3><h3 class="wolai-block"><span class="inline-wrap">AbstractQueuedSynchronizer</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>AbstractQueuedSynchronizer</code></span><span class="inline-wrap">提供一个框架方便我们实现基于<span class="jill"></span>FIFO<span class="jill"></span>同步队列的阻塞锁和相应的同步者。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">通过单个<span class="jill"></span>int<span class="jill"></span>类型来表示同步状态，子类必须定义改变状态的方法，以及在获取和释放锁时状态的含义。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">该类的子类不应该声明为<span class="jill"></span>Public<span class="jill"></span>方法，而应该是某个类内部用于提供同步机制的工具。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">该类提供排它锁和共享锁模式，默认是排它锁模式。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">简单来说，如果你想实现一个锁，可以继承</span><span class="inline-wrap"><code>AbstractQueuedSynchronizer</code></span><span class="inline-wrap">类，然后重写以下方法</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>tryAcquire(int)</code></span><span class="inline-wrap">: 尝试获取独占锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>tryRelease(int)</code></span><span class="inline-wrap">: 尝试释放独占锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>tryAcquireShared(int)</code></span><span class="inline-wrap">: 尝试获取共享锁</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>tryReleaseShared(int)</code></span><span class="inline-wrap">: 尝试释放共享锁，如果你不需要实现共享锁，你甚至不需要实现这两个方法</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>isHeldExclusively()</code></span><span class="inline-wrap">：</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>实战</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">实现一个不可重入的独占锁</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">class</span> <span class="token class-name">Mutex</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span> <span class="token punctuation">{</span>

    <span class="token comment">// Our internal helper class</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1表示获取锁，0</span>
        
        <span class="token comment">// Reports whether in locked state</span>
        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// While a non-reentrant lock does not strictly require recording of the current owner thread</span>
            <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Acquires the lock if state is zero</span>
        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">assert</span> acquires <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Otherwise unused</span>
            <span class="token keyword">return</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Releases the lock by setting state to zero</span>
        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">assert</span> releases <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Otherwise unused</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Provides a Condition</span>
        <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConditionObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// The sync object does all the hard work. We just forward to it.</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span> sync<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">{</span> <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              <span class="token punctuation">{</span> sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span> <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span> <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">hasQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        sync<span class="token punctuation">.</span><span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><h3 class="wolai-block"><span class="inline-wrap">AbstractQueuedSynchronizer<span class="jill"></span>进阶</span></h3></article><footer></footer></body></html>
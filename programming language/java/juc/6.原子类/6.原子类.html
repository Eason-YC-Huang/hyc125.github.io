<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>6.原子类 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="6.原子类" class="main-title"></div></div></header><article><h1 class="wolai-block"><span class="inline-wrap">1.何谓<span class="jill"></span>Atomic？</span></h1><div class="wolai-block wolai-text"><div><span class="inline-wrap">Atomic<span class="jill"></span>一词跟原子有点关系，后者曾被人认为是最小物质的单位。计算机中的<span class="jill"></span>Atomic<span class="jill"></span>是指不能分割成若干部分的意思。如果一段代码被认为是<span class="jill"></span>Atomic，则表示这段代码在执行过程中，是不能被中断的。通常来说，原子指令由硬件提供，供软件来实现原子方法（某个线程进入该方法后，就不会被中断，直到其执行完成）</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>x86 平台上，CPU<span class="jill"></span>提供了在指令执行期间对总线加锁的手段。CPU<span class="jill"></span>芯片上有一条引线#HLOCK pin，如果汇编语言的程序中在一条指令前面加上前缀&quot;LOCK&quot;，经过汇编以后的机器代码就使<span class="jill"></span>CPU<span class="jill"></span>在执行这条指令的时候把#HLOCK pin<span class="jill"></span>的电位拉低，持续到这条指令结束时放开，从而把总线锁住，这样同一总线上别的<span class="jill"></span>CPU<span class="jill"></span>就暂时不能通过总线访问内存了，保证了这条指令在多处理器环境中的原子性。</span></div></div><h1 class="wolai-block"><span class="inline-wrap">2.原子操作类</span></h1><div class="wolai-block wolai-text"><div><span class="inline-wrap">当多个线程同时更新公共变量，会导致线程不安全，通常大家可以会想到使用<span class="jill"></span>synchronized<span class="jill"></span>关键字或者<span class="jill"></span>Lock<span class="jill"></span>来解决这个问题，synchronized<span class="jill"></span>和<span class="jill"></span>Lock<span class="jill"></span>可以保证多个线程不会同时更新该公共变量。为了使用更简单，性能更高效，jdk1.5<span class="jill"></span>提出原子操作类。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">原子操作类主要集中在<span class="jill"></span>Atomic（</span><span class="inline-wrap"><code>java.util.concurrent.atomic</code></span><span class="inline-wrap">）包下，按照原子更新方式，这些原子操作类大致可以分为四种：原子更新基本类型、原子更新数组、原子更新引用以及原子更新属性，接下来就这四种类型原子操作类的具体实现做相关分析。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">2.1<span class="jill"></span>原子更新基本类型</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Atomic<span class="jill"></span>包主要提供三个类来更新基本类型变量：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicBoolean：用来更新布尔型变量；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicInteger：用来更新整型变量；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicLong：用来更新长整型变量；</span></li></ul><h2 class="wolai-block"><span class="inline-wrap">2.2<span class="jill"></span>原子更新数组</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Atomic<span class="jill"></span>包提供三个类来以原子的方式更新数组里的元素：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicIntegerArray：用来更新整型数组里的元素；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicLongArray：用来更新长整型数组里的元素；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicReferenceArray：用来更新引用类型数组里的元素。</span></li></ul><h2 class="wolai-block"><span class="inline-wrap">2.3<span class="jill"></span>原子更新引用类型</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">原子更新基本类型每次只能更新一个变量，假如需要更新多个变量怎么办呢？针对这个问题，Atomic<span class="jill"></span>包提供引用类型类来一次更新多个变量：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicReference：用于更新引用类型，可以理解为更新<span class="jill"></span>Object；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicMarkableReference：用于更新带有标记位的引用类型；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicStampedReference：用于更新带有版本号的引用类型，该类将版本号与引用类型关联起来，可以解决使用<span class="jill"></span>CAS<span class="jill"></span>进行原子更新时可能会出现的<span class="jill"></span>ABA<span class="jill"></span>问题。</span></li></ul><h2 class="wolai-block"><span class="inline-wrap">2.4<span class="jill"></span>原子更新属性</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">AtomicReference<span class="jill"></span>系列可以更新<span class="jill"></span>Object，同样的，针对<span class="jill"></span>Object<span class="jill"></span>的属性，Atomic<span class="jill"></span>提供一下方法来更新<span class="jill"></span>Object<span class="jill"></span>的属性：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicIntegerFieldUpdater：用于更新<span class="jill"></span>Object<span class="jill"></span>的整型属性；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicLongFieldUpdater：用于更新<span class="jill"></span>Object<span class="jill"></span>的长整型属性；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicReferenceFieldUpdater：用于更新<span class="jill"></span>Object<span class="jill"></span>的引用类型属性。</span></li></ul><h1 class="wolai-block"><span class="inline-wrap">3.原子操作类源码分析</span></h1><h2 class="wolai-block"><span class="inline-wrap">3.1<span class="jill"></span>原子更新基本类型</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">对于原子更新基本类型，我们以</span><span class="inline-wrap"><code>AtomicLong</code></span><span class="inline-wrap">为切入点，分析一下具体的源码实现。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>AtomicLong</code></span><span class="inline-wrap">有以下比较常用的方法：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>boolean compareAndSet(long expect, long update)</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>long getAndSet(long newValue)</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">add<span class="jill"></span>系列方法</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>long addAndGet(long delta)</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>long getAndAdd(long delta)</code></span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">increment<span class="jill"></span>系列方法</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">decrement<span class="jill"></span>系列方法</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>void lazySet(long newValue)</code></span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>compareAndSet</b></span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token comment">// 使用了CAS机制：CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</span>
<span class="token comment">// 调用Unsafe的compareAndSwapLong方法实现比较设置，如果当前value与预期值expect相等，则将value设置为update的值。</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">long</span> expect<span class="token punctuation">,</span> <span class="token keyword">long</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token comment">// 当对象是数组的时候，offset才有用的，如果其他，offset其实是没用的</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span>
                                               <span class="token keyword">long</span> expected<span class="token punctuation">,</span>
                                               <span class="token keyword">long</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>getAndSet</b></span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token keyword">long</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndSetLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getAndSetLong</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">long</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> v<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        v <span class="token operator">=</span> <span class="token function">getLongVolatile</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> v<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>add<span class="jill"></span>系列方法</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>AtomicLong</code></span><span class="inline-wrap">提供</span><span class="inline-wrap"><code>addAndGet</code></span><span class="inline-wrap">方法和</span><span class="inline-wrap"><code>getAndAdd</code></span><span class="inline-wrap">方法来做加法运算。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token keyword">long</span> delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">addAndGet</span><span class="token punctuation">(</span><span class="token keyword">long</span> delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> delta<span class="token punctuation">)</span> <span class="token operator">+</span> delta<span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>increment<span class="jill"></span>系列方法</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">同<span class="jill"></span>add<span class="jill"></span>一样，</span><span class="inline-wrap"><code>AtomicLong</code></span><span class="inline-wrap">同样提供两个方法：</span><span class="inline-wrap"><code>incrementAndGet</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>getAndIncrement</code></span><span class="inline-wrap">方法来做自增操作。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>decrement<span class="jill"></span>系列方法</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">同样的，</span><span class="inline-wrap"><code>AtomicLong</code></span><span class="inline-wrap">也提供两个方法：</span><span class="inline-wrap"><code>decrementAndGet</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>getAndDecrement</code></span><span class="inline-wrap">方法来做自减操作。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>lazySet<span class="jill"></span>方法</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>练习</b></span><span class="inline-wrap">：实现自增计数器，要求线程安全。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">3.2<span class="jill"></span>原子更新数组</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Atomic<span class="jill"></span>包提供三个类来以原子的方式更新数组里的元素：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicIntegerArray：用来更新整型数组里的元素；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicLongArray：用来更新长整型数组里的元素；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicReferenceArray：用来更新引用类型数组里的元素。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">接下来还是以<span class="jill"></span>AtomicLongArray<span class="jill"></span>为例，分析具体的源码实现。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">AtomicLongArray<span class="jill"></span>同<span class="jill"></span>AtomicLong<span class="jill"></span>对外提供的方法大致一致，只不过前者是操作数组，后者是操作基本类型。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token comment">//AtomicLongArray自己维护一个长整型数组array，对数组元素的操作实质是对array的操作。</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span></pre></div></code-block><h2 class="wolai-block"><span class="inline-wrap">3.3<span class="jill"></span>原子更新引用类型</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">原子更新基本类型每次只能更新一个变量，假如需要更新多个变量怎么办呢？针对这个问题，Atomic<span class="jill"></span>包提供引用类型类来一次更新多个变量：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicReference：用于更新引用类型，可以理解为更新<span class="jill"></span>Object；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicMarkableReference：用于更新带有标记位的引用类型；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicStampedReference：用于更新带有版本号的引用类型，该类将版本号与引用类型关联起来，可以解决使用<span class="jill"></span>CAS<span class="jill"></span>进行原子更新时可能会出现的<span class="jill"></span>ABA<span class="jill"></span>问题。</span></li></ul><h2 class="wolai-block"><span class="inline-wrap">3.4<span class="jill"></span>原子更新属性</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">AtomicReference<span class="jill"></span>系列可以更新<span class="jill"></span>Object，同样的，针对<span class="jill"></span>Object<span class="jill"></span>的属性，Atomic<span class="jill"></span>提供一下方法来更新<span class="jill"></span>Object<span class="jill"></span>的属性：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicIntegerFieldUpdater：用于更新<span class="jill"></span>Object<span class="jill"></span>的整型属性；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicLongFieldUpdater：用于更新<span class="jill"></span>Object<span class="jill"></span>的长整型属性；</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">AtomicReferenceFieldUpdater：用于更新<span class="jill"></span>Object<span class="jill"></span>的引用类型属性。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">以<span class="jill"></span>AtomicIntegerFieldUpdater<span class="jill"></span>为例，分析一下源码的具体实现。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在使用<span class="jill"></span>AtomicIntegerFieldUpdater<span class="jill"></span>来更改<span class="jill"></span>Object<span class="jill"></span>整型属性大致分为两步：</span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">使用静态方法<span class="jill"></span>newUpdater<span class="jill"></span>创建一个更新器，设置需要更新的类和属性；</span></li><li><div class="marker"></div><span class="inline-wrap">调用相关<span class="jill"></span>CAS<span class="jill"></span>系列方法更新属性，</span><span class="inline-wrap"><b>需要注意的是，更新的属性必须使用<span class="jill"></span>public volatile<span class="jill"></span>修饰</b></span><span class="inline-wrap">。</span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h1 class="wolai-block"><span class="inline-wrap">4.CAS</span></h1><div class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>
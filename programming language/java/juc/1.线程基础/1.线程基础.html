<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>1.线程基础 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="1.线程基础" class="main-title"></div></div></header><article><h2 class="wolai-block"><span class="inline-wrap">1.线程简介</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>中用<span class="jill"></span>Thread<span class="jill"></span>类代表线程,它有两个很重要的方法：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">run()：包含线程运行时要执行的代码</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">start()：用于启动线程</span></li></ul><h2 class="wolai-block"><span class="inline-wrap">2.创建线程实例</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">有两种方法可以创建<span class="jill"></span>Thread<span class="jill"></span>的实例</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">继承<span class="jill"></span>Thread<span class="jill"></span>类,重写</span><span class="inline-wrap"><code>run</code></span><span class="inline-wrap">方法</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">调用<span class="jill"></span>Thread<span class="jill"></span>的构造器方法,并传递一个</span><span class="inline-wrap"><code>Runnable</code></span><span class="inline-wrap">实例</span></li></ul><h3 class="wolai-block"><span class="inline-wrap">2.1<span class="jill"></span>重写<span class="jill"></span>run<span class="jill"></span>方法</span></h3><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token string">"--"</span><span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 启动线程</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">Strig</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">MyThread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>关于调用<span class="jill"></span>Thread<span class="jill"></span>类的<span class="jill"></span>run()方法</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果我们调用了<span class="jill"></span>Thread<span class="jill"></span>的<span class="jill"></span>run()方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用</span><span class="inline-wrap"><code>Thread.start()</code></span><span class="inline-wrap">方法。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">2.2</span><span class="inline-wrap"><code>Runnable</code></span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">由于<span class="jill"></span>Java<span class="jill"></span>不支持多继承，也就是说如果我们继承了<span class="jill"></span>Thread<span class="jill"></span>类，就不能继承其他类。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">为了解决这个问题，Java<span class="jill"></span>提供了<span class="jill"></span>Runnable<span class="jill"></span>接口。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token string">"--"</span><span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><h3 class="wolai-block"><span class="inline-wrap">2.3 获取当前线程的引用</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">Thread<span class="jill"></span>类的</span><span class="inline-wrap"><code>currentThread</code></span><span class="inline-wrap">静态方法返回当前线程对象的引用。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">3.线程的状态</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Thread<span class="jill"></span>类内部有一个叫<span class="jill"></span>State<span class="jill"></span>的枚举类,定义了线程有哪些状态</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>新建状态 NEW</b></span><div class="wolai-block wolai-text"><div><span class="inline-wrap">用<span class="jill"></span>new<span class="jill"></span>语句创建的线程对象处于新建状态。</span></div></div></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>可运行状态 RUNNABLE</b></span><div class="wolai-block wolai-text"><div><span class="inline-wrap">调用了线程的<span class="jill"></span>start()方法，线程就处于可运行状态，即使线程正在等待<span class="jill"></span>CPU<span class="jill"></span>资源，也是处于<span class="jill"></span>RUNNABLE。</span></div></div></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>阻塞状态 BLOCKED</b></span><div class="wolai-block wolai-text"><div><span class="inline-wrap">当线程试图获取某个对象的内部锁时，如果该对象的内部锁已经被其他线程占用，Java<span class="jill"></span>虚拟机会把这个线程放到这个对象的锁池中，线程进入了阻塞状态。</span></div></div></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>等待状态 WAITING</b></span><div class="wolai-block wolai-text"><div><span class="inline-wrap">当线程等待一个条件时，例如调用</span><span class="inline-wrap"><code>Object.wait</code></span><span class="inline-wrap">、</span><span class="inline-wrap"><code>Thread.join</code></span><span class="inline-wrap">、或者等待</span><span class="inline-wrap"><code>Lock</code></span><span class="inline-wrap">、</span><span class="inline-wrap"><code>Condition</code></span><span class="inline-wrap">的时候，就会进入等待状态</span></div></div></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>计时等待状态 TIMED_WAITING</b></span><div class="wolai-block wolai-text"><div><span class="inline-wrap">当线程</span><span class="inline-wrap"><b>定时</b></span><span class="inline-wrap">等待一个条件时,就会进入定时等待状态 例如 </span><span class="inline-wrap"><code>Thread.sleep()</code></span></div></div></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>终止状态 TERMINATED</b></span><div class="wolai-block wolai-text"><div><span class="inline-wrap">当线程执行完<span class="jill"></span>run<span class="jill"></span>方法，或者在执行过程中出现了异常，那么该线程就会退出，然后进入终止状态。</span></div></div></li></ul><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="media/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" style="width: 415.5px"/></figure></div><h2 class="wolai-block"><span class="inline-wrap">4.线程的调度</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">线程的调度是指按照特定的机制为多个线程分配<span class="jill"></span>CPU<span class="jill"></span>的使用权，有两种调度模型：分时调度模型和抢占式调度模型。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">分时调度模型是让所有线程轮流获得<span class="jill"></span>CPU<span class="jill"></span>的使用权，并且平均分配每个线程占用<span class="jill"></span>CPU<span class="jill"></span>的时间片。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>虚拟机采用抢占式调度模型，它优先让可运行池中的优先级高的线程占用<span class="jill"></span>CPU，如果可运行池中线程的优先级相同，那么就随机地选择一个线程，使其占用<span class="jill"></span>CPU。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">4.1<span class="jill"></span>调整各个线程的优先级</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">Thread<span class="jill"></span>类提供了<span class="jill"></span>setPriority(int)和<span class="jill"></span>getPripority()方法设置和读取优先级。优先级的取值范围是<span class="jill"></span>1~10，越大有越优先，默认优先级为<span class="jill"></span>5。Thread<span class="jill"></span>类提供了<span class="jill"></span>3<span class="jill"></span>个静态变量，分别用来对应三个优先级，分别是</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">MAX_PRIORITY:10</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">NORM_PRIORITY:5</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">MIN_PRIPROTY:1</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">虽然说是分了<span class="jill"></span>10<span class="jill"></span>个优先级，但不是所有操作系统的支持的，所以一般推荐使用上面三个静态变量。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">4.2<span class="jill"></span>线程的让步</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>让步</b></span><span class="inline-wrap">：调用线程的静态<span class="jill"></span>yield<span class="jill"></span>方法，如果此时具有相同优先级的其他线程处于就绪状态，该方法就会把当前运行的线程放到可运行池中，并运行那个线程。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">5.线程的中断</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">在大部分情况下，我们会让线程运行直到结束，然而有些时候，我们希望能提前结束线程。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>没有提供任何机制来安全的终止线程，但它提供了“中断”，这是一种协作机制，能使一个线程终止另一个线程的当前工作。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">之所以需要协作，是因为我们很少希望某个线程立即停止，我们希望线程先执行清理工作，然后再停止。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>Thread</code></span><span class="inline-wrap">类提供了中断线程以及查询线程中断状态的方法。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>
    <span class="token comment">// 中断该线程(处于中断状态的线程，执行任何会抛出InterruptedException的方法，都会直接触发该异常)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 返回该线程是否处于中断状态，不会清除中断标记</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 返回当前线程是否处于中断状态，并清除中断标记</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 上面两者都是调用了isInterrupted(boolean)方法，区别就在于是否清除中断标记</span>
    <span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> <span class="token class-name">ClearInterrupted</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 触发了InterruptedException后，线程的中断状态会被清除</span>
<span class="token punctuation">}</span></pre></div></code-block><h2 class="wolai-block"><span class="inline-wrap">6.线程异常处理</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>Thread</code></span><span class="inline-wrap">提供了</span><span class="inline-wrap"><code>UncaughtExceptionHandler</code></span><span class="inline-wrap">，它能检测出某个线程由于未捕获的异常而终结的情况。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UncaughtExceptionHandler</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">uncaughtException</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><h2 class="wolai-block"><span class="inline-wrap">7.守护线程</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">用户线程即运行在前台的线程，而守护线程是运行在后台的线程。 守护线程作用是为其他前台线程的运行提供便利服务，而且仅在普通、非守护线程仍然运行时才需要，比如垃圾回收线程就是一个守护线程。当<span class="jill"></span>JVM<span class="jill"></span>检测仅剩一个守护线程，而用户线程都已经退出运行时，JVM<span class="jill"></span>就会退出。如果有非守护线程仍然存活，JVM<span class="jill"></span>就不会退出。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">守护线程并非只有虚拟机内部提供，用户在编写程序时也可以自己设置守护线程。用户可以用<span class="jill"></span>Thread<span class="jill"></span>的</span><span class="inline-wrap"><code>setDaemon(true)</code></span><span class="inline-wrap">方法设置当前线程为守护线程。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">虽然守护线程可能非常有用，但必须小心确保其他所有非守护线程消亡时，不会由于它的终止而产生任何危害。因为你不可能知道在所有的用户线程退出运行前，守护线程是否已经完成了预期的服务任务。一旦所有的用户线程退出了，虚拟机也就退出运行了。 因此，不要在守护线程中执行业务逻辑操作（比如对数据的读写等）。</span></div></div></article><footer></footer></body></html>
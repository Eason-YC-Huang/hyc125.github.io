<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../css/wolai.css"/><title>K8S - wolai 笔记</title><link rel="shortcut icon"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="K8S" class="main-title"></div></div></header><article><h2 class="wolai-block"><span class="inline-wrap"><b>什么是<span class="jill"></span>K8S？</b></span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/"><span>Kubernetes</span></a></span><span class="inline-wrap"> 是用于管理容器化应用程序(部署在容器内的应用程序)的开源系统。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">解决的问题就是服务多导致容器多，容器多导致容器不好统一管理的问题。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">你只需要通过配置文件，告诉<span class="jill"></span>K8S<span class="jill"></span>你需要部署多少个容器，每个容器的内容分别是什么，它就会帮你创建并管理好这些容器。</span></div></div><h2 class="wolai-block"><span class="inline-wrap"><b>基础概念</b></span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">节点：一个<span class="jill"></span>K8S<span class="jill"></span>进程就是一个节点</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">集群：由多个节点组成的就叫集群</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">通过安装不同的组件，节点分为主节点和从节点，主节点负责核心的调度、管理和运维，从节点负责执行用户的程序。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">主节点的组件</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>API Server</b></span><span class="inline-wrap">。</span><span class="inline-wrap"><b>K8S<span class="jill"></span>的请求入口服务</b></span><span class="inline-wrap">。API Server<span class="jill"></span>负责接收<span class="jill"></span>K8S<span class="jill"></span>所有请求（来自<span class="jill"></span>UI<span class="jill"></span>界面或者<span class="jill"></span>CLI<span class="jill"></span>命令行工具），然后，API Server<span class="jill"></span>根据用户的具体请求，去通知其他组件干活。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Scheduler</b></span><span class="inline-wrap">。</span><span class="inline-wrap"><b>K8S<span class="jill"></span>所有<span class="jill"></span>Worker Node<span class="jill"></span>的调度器</b></span><span class="inline-wrap">。当用户要部署服务时，Scheduler<span class="jill"></span>会选择最合适的<span class="jill"></span>Worker Node（服务器）来部署。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Controller Manager</b></span><span class="inline-wrap">。</span><span class="inline-wrap"><b>K8S<span class="jill"></span>所有<span class="jill"></span>Worker Node<span class="jill"></span>的控制器</b></span><span class="inline-wrap">。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">从节点的组件</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Kubelet</b></span><span class="inline-wrap">。</span><span class="inline-wrap"><b>Worker Node<span class="jill"></span>的监视器，以及与<span class="jill"></span>Master Node<span class="jill"></span>的通讯器</b></span><span class="inline-wrap">。Kubelet<span class="jill"></span>是<span class="jill"></span>Master Node<span class="jill"></span>安插在<span class="jill"></span>Worker Node<span class="jill"></span>上的“眼线”，它会定期向<span class="jill"></span>Worker Node<span class="jill"></span>汇报自己<span class="jill"></span>Node<span class="jill"></span>上运行的服务的状态，并接受来自<span class="jill"></span>Master Node<span class="jill"></span>的指示采取调整措施。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Kube-Proxy</b></span><span class="inline-wrap">。</span><span class="inline-wrap"><b>K8S<span class="jill"></span>的网络代理</b></span><span class="inline-wrap">。负责<span class="jill"></span>Node<span class="jill"></span>在<span class="jill"></span>K8S<span class="jill"></span>的网络通讯、以及对外部网络流量的负载均衡。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Container Runtime</b></span><span class="inline-wrap">。</span><span class="inline-wrap"><b>Worker Node<span class="jill"></span>的运行环境</b></span><span class="inline-wrap">。即安装了容器化所需的软件环境确保容器化程序能够跑起来，比如<span class="jill"></span>Docker Engine。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Logging Layer</b></span><span class="inline-wrap">。</span><span class="inline-wrap"><b>K8S<span class="jill"></span>的监控状态收集器</b></span><span class="inline-wrap">。私以为称呼为<span class="jill"></span>Monitor<span class="jill"></span>可能更合适？Logging Layer<span class="jill"></span>负责采集<span class="jill"></span>Node<span class="jill"></span>上所有服务的<span class="jill"></span>CPU、内存、磁盘、网络等监控项信息。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Add-Ons</b></span><span class="inline-wrap">。</span><span class="inline-wrap"><b>K8S<span class="jill"></span>管理运维<span class="jill"></span>Worker Node<span class="jill"></span>的插件组件</b></span><span class="inline-wrap">。有些文章认为<span class="jill"></span>Worker Node<span class="jill"></span>只有三大组件，不包含<span class="jill"></span>Add-On，但笔者认为<span class="jill"></span>K8S<span class="jill"></span>系统提供了<span class="jill"></span>Add-On<span class="jill"></span>机制，让用户可以扩展更多定制化功能，是很不错的亮点。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap">其它</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><a href="https://kind.sigs.k8s.io/docs/"><span><code>kind</code></span></a></span><span class="inline-wrap">：让你能够在本地计算机上运行 Kubernetes。 </span><span class="inline-wrap"><code>kind</code></span><span class="inline-wrap"> 要求你安装并配置好 </span><span class="inline-wrap"><a href="https://docs.docker.com/get-docker/"><span>Docker</span></a></span><span class="inline-wrap">。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>minikube</code></span><span class="inline-wrap">：与 </span><span class="inline-wrap"><code>kind</code></span><span class="inline-wrap"> 类似，</span><span class="inline-wrap"><a href="https://minikube.sigs.k8s.io/"><span><code>minikube</code></span></a></span><span class="inline-wrap"> 是一个工具， 能让你在本地运行 Kubernetes。 </span><span class="inline-wrap"><code>minikube</code></span><span class="inline-wrap"> 在你本地的个人计算机运行一个单节点的 Kubernetes 集群。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>kubeadm</code></span><span class="inline-wrap">：创建和管理 Kubernetes 集群。 该工具能够执行必要的动作并用一种用户友好的方式启动一个可用的、安全的集群。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>kubectl</code></span><span class="inline-wrap">：Kubernetes 命令行工具，可以用来部署应用、监测和管理集群资源以及查看日志。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">简单来说，本地学习的话，通过</span><span class="inline-wrap"><code>minikube</code></span><span class="inline-wrap">安装一个单机版的<span class="jill"></span>kubernetes<span class="jill"></span>就行了。</span></li></ul><hr class="wolai-block"/><div class="wolai-block wolai-text"><div><span class="inline-wrap">Pod 和 ReplicaSet 和 Deployment</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Pod<span class="jill"></span>是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元</b></span><span class="inline-wrap">。Pod<span class="jill"></span>是豆荚的意思，一个豆荚里面会有多个豆豆，顾名思义，一个<span class="jill"></span>Pod<span class="jill"></span>里面可以有多个容器。同一个<span class="jill"></span>Pod<span class="jill"></span>之间的<span class="jill"></span>Container<span class="jill"></span>可以通过<span class="jill"></span>localhost<span class="jill"></span>互相访问，并且可以挂载<span class="jill"></span>Pod<span class="jill"></span>内所有的数据卷；但是不同的<span class="jill"></span>Pod<span class="jill"></span>之间的<span class="jill"></span>Container<span class="jill"></span>不能用<span class="jill"></span>localhost<span class="jill"></span>访问，也不能挂载其他<span class="jill"></span>Pod<span class="jill"></span>的数据卷。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ReplicaSet<span class="jill"></span>和<span class="jill"></span>Deployment：ReplicaSet<span class="jill"></span>的作用就是管理和控制<span class="jill"></span>Pod，管控他们好好干活。但是，ReplicaSet<span class="jill"></span>受控于<span class="jill"></span>Deployment。形象来说，</span><span class="inline-wrap"><b>ReplicaSet<span class="jill"></span>就是总包工头(Deployment)手下的小包工头</b></span><span class="inline-wrap">。</span></li></ul><hr class="wolai-block"/><div class="wolai-block wolai-text"><div><span class="inline-wrap">Service<span class="jill"></span>和<span class="jill"></span>Ingress：</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Service<span class="jill"></span>是<span class="jill"></span>K8S<span class="jill"></span>服务的核心，屏蔽了服务细节，统一对外暴露服务接口，真正做到了“微服务”</b></span><span class="inline-wrap">。举个例子，我们的一个服务<span class="jill"></span>A，部署了<span class="jill"></span>3<span class="jill"></span>个备份，也就是<span class="jill"></span>3<span class="jill"></span>个<span class="jill"></span>Pod；对于用户来说，只需要关注一个<span class="jill"></span>Service<span class="jill"></span>的入口就可以，而不需要操心究竟应该请求哪一个<span class="jill"></span>Pod。优势非常明显：</span><span class="inline-wrap"><b>一方面外部用户不需要感知因为<span class="jill"></span>Pod<span class="jill"></span>上服务的意外崩溃、K8S<span class="jill"></span>重新拉起<span class="jill"></span>Pod<span class="jill"></span>而造成的<span class="jill"></span>IP<span class="jill"></span>变更，外部用户也不需要感知因升级、变更服务带来的<span class="jill"></span>Pod<span class="jill"></span>替换而造成的<span class="jill"></span>IP<span class="jill"></span>变化，另一方面，Service<span class="jill"></span>还可以做流量负载均衡</b></span><span class="inline-wrap">。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">但是，Service<span class="jill"></span>主要负责<span class="jill"></span>K8S<span class="jill"></span>集群内部的网络拓扑。那么集群外部怎么访问集群内部呢？这个时候就需要<span class="jill"></span>Ingress<span class="jill"></span>了，Ingress<span class="jill"></span>是整个<span class="jill"></span>K8S<span class="jill"></span>集群的接入层，负责集群内外通讯。</span></li></ul><hr class="wolai-block"/><div class="wolai-block wolai-text"><div><span class="inline-wrap">namespace 命名空间：</span><span class="inline-wrap"><b>namespace<span class="jill"></span>是为了把一个<span class="jill"></span>K8S<span class="jill"></span>集群划分为若干个资源不可共享的虚拟集群而诞生的</b></span><span class="inline-wrap">，</span><span class="inline-wrap"><b>可以通过在<span class="jill"></span>K8S<span class="jill"></span>集群内创建<span class="jill"></span>namespace<span class="jill"></span>来分隔资源和对象</b></span><span class="inline-wrap">。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">安装<span class="jill"></span>minikube</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">安装<span class="jill"></span>K8S<span class="jill"></span>还是很麻烦的，本地体验的话我们可以用<span class="jill"></span>minikube<span class="jill"></span>代替，minikube<span class="jill"></span>可以看做是迷你版的<span class="jill"></span>k8s</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="PowerShell" class="marker"></div><pre><span class="token comment"># 设置代理</span>
export HTTP_PROXY=<span class="token string">"127.0.0.1:1081"</span>
export HTTPS_PROXY=<span class="token string">"127.0.0.1:1081"</span>
export ALL_PROXY=<span class="token string">"socks5://127.0.0.1:1080"</span>
export NO_PROXY=<span class="token string">"\
localhost,\
127.0.0.1,\
10.96.0.0/12,\
192.168.0.0/16 \
"</span>
<span class="token comment"># 安装minikube</span>
brew install minikube
<span class="token comment"># 启动minikube</span>
minikube <span class="token function">start</span></pre></div></code-block><h2 class="wolai-block"><span class="inline-wrap">基本操作</span></h2><h3 class="wolai-block"><span class="inline-wrap">语法</span></h3><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="PowerShell" class="marker"></div><pre><span class="token comment"># 现在minikube已经启动了，我们可以发送命令给它</span>
<span class="token comment"># 我们可以通过kubectl发送命令给minikube让它干活</span>
<span class="token comment"># 问题</span>
<span class="token comment"># 1.kubectl是怎么发送命令给k8s的？HTTP还是TCP？</span>
<span class="token comment"># 2.kubectl怎么知道k8s的IP地址和端口？</span>
<span class="token comment"># 3.</span>

<span class="token comment"># 解答</span>
<span class="token comment"># 1.</span>
<span class="token comment"># 2.在$HOME/.kube目录下有个config文件，该文件存放了连接到K8S集群的相关信息</span>

<span class="token comment"># kubectl语法: kubectl [command] [TYPE] [NAME] [flags]</span>
<span class="token comment"># command : create, get, run, expose，delete ...</span>
<span class="token comment"># TYPE : (资源类型) </span>
<span class="token comment"># NAME : (资源的名称)</span>
<span class="token comment"># flags ： 命令参数</span></pre></div></code-block><h3 class="wolai-block"><span class="inline-wrap">deployment<span class="jill"></span>与<span class="jill"></span>pod<span class="jill"></span>的基本操作</span></h3><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="PowerShell" class="marker"></div><pre><span class="token comment"># 创建一个部署任务，名叫hello-minikube</span>
<span class="token comment"># -r 3 创建三个pod来部署 （一个pod可以看做一台虚拟机）</span>
<span class="token comment"># 部署的内容是k8s.gcr.io/echoserver:1.4</span>
kubectl create deployment hello<span class="token operator">-</span>minikube <span class="token operator">-</span>r 3 <span class="token operator">--</span>image=k8s<span class="token punctuation">.</span>gcr<span class="token punctuation">.</span>io<span class="token operator">/</span>echoserver:1<span class="token punctuation">.</span>4 
<span class="token comment"># 查看部署结果</span>
kubectl get pods
<span class="token comment"># ssh进pod</span>
kubectl exec <span class="token operator">--</span>stdin <span class="token operator">--</span>tty pod<span class="token operator">-</span>name <span class="token operator">--</span> <span class="token operator">/</span>bin<span class="token operator">/</span>bash
<span class="token comment"># 删除某个pod (不过删除pod没啥用，因为你deployment指定了pod的数量，如果少于这个数，它会自动创建pod)</span>
kubectl delete pod pod<span class="token operator">-</span>name
<span class="token comment"># 删除deployment</span>
kubectl delete deployment deploymetn<span class="token operator">-</span>name</pre></div></code-block><h2 class="wolai-block"><span class="inline-wrap">HelloWorld</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">把一个可执行的<span class="jill"></span>Jar<span class="jill"></span>包打成镜像发布到<span class="jill"></span>DockerHub，然后通过<span class="jill"></span>K8S<span class="jill"></span>拉取镜像，并部署</span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">编写<span class="jill"></span>dockerfile</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Docker" class="marker"></div><pre><span class="token instruction"><span class="token keyword">FROM</span> openjdk:8-jdk-alpine</span>
<span class="token instruction"><span class="token keyword">VOLUME</span> /tmp</span>
<span class="token instruction"><span class="token keyword">ADD</span> target/k8s-image-0.0.1-SNAPSHOT.jar app.jar</span>
<span class="token instruction"><span class="token keyword">ENV</span> JAVA_OPTS=<span class="token string">""</span></span>
<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> exec java <span class="token variable">$JAVA_OPTS</span> -jar /app.jar</span></pre></div></code-block></li><li><div class="marker"></div><span class="inline-wrap">打包镜像</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>docker build <span class="token punctuation">\</span>
--build-arg  <span class="token assign-left variable">http_proxy</span><span class="token operator">=</span><span class="token string">"127.0.0.1:1081"</span> <span class="token punctuation">\</span>
--build-arg <span class="token assign-left variable">https_proxy</span><span class="token operator">=</span><span class="token string">"127.0.0.1:1081"</span> <span class="token punctuation">\</span>
-t huangdaren/docker-image-demo:v1 <span class="token builtin class-name">.</span></pre></div></code-block></li><li><div class="marker"></div><span class="inline-wrap">推送镜像到<span class="jill"></span>DockerHub</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="PowerShell" class="marker"></div><pre>docker push huangdaren<span class="token operator">/</span>docker<span class="token operator">-</span>image<span class="token operator">-</span>demo:v1</pre></div></code-block></li><li><div class="marker"></div><span class="inline-wrap">编写创建<span class="jill"></span>Pod<span class="jill"></span>的配置</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Yaml" class="marker"></div><pre><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> hyc<span class="token punctuation">-</span>demo<span class="token punctuation">-</span>pod
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> hyc<span class="token punctuation">-</span>demo<span class="token punctuation">-</span>pod<span class="token punctuation">-</span>label
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo
      <span class="token key atrule">image</span><span class="token punctuation">:</span> huangdaren/docker<span class="token punctuation">-</span>image<span class="token punctuation">-</span>demo<span class="token punctuation">:</span>v1
      <span class="token key atrule">ports</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span></pre></div></code-block></li><li><div class="marker"></div><span class="inline-wrap">创建<span class="jill"></span>Pod</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>kubectl create -f pod.yaml
kubectl expose pod hyc-demo-pod --type<span class="token operator">=</span>NodePort --port<span class="token operator">=</span><span class="token number">8080</span>
minikube <span class="token function">service</span> hello-minikube</pre></div></code-block></li></ol><div class="wolai-block wolai-text"><div></div></div><div class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86.html"><span>资源管理</span></a></div><div class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="%E6%B7%B1%E5%85%A5pod/%E6%B7%B1%E5%85%A5Pod.html"><span>深入Pod</span></a></div><div class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="%E6%B7%B1%E5%85%A5pod%E6%8E%A7%E5%88%B6%E5%99%A8/%E6%B7%B1%E5%85%A5Pod%E6%8E%A7%E5%88%B6%E5%99%A8.html"><span>深入Pod控制器</span></a></div><div class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="%E6%B7%B1%E5%85%A5service/%E6%B7%B1%E5%85%A5Service.html"><span>深入Service</span></a></div><div class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8.html"><span>数据存储</span></a></div><div class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81.html"><span>安全认证</span></a></div><div class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF/%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF.html"><span>控制面板</span></a></div></article><footer></footer></body></html>